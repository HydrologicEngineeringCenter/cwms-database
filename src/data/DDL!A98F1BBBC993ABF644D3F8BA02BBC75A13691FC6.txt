
  CREATE OR REPLACE PACKAGE "CWMS_20"."CWMS_BASIN" 
/**
 * Routines to work with CWMS basins
 *
 * @author Mike Perryman
 *
 * @since CWMS 2.1
 */
as
-- not documented
function get_basin_code(
   p_basin_id  in varchar2,
   p_office_id in varchar2 default null)
   return number;
/**
 * Stores a basin to the database
 *
 * @param p_basin_id                   The location identifier of the basin
 * @param p_fail_if_exists             A flag ('T' or 'F') that specifies whether the routine should fail if the specified basin already exists.  If 'F' and the basin already exists, it will be updated with the specified parameters.
 * @param p_ignore_nulls               A flag ('T' or 'F') that specifies whether NULL parameters should be ignored when updating a basin.  If 'T', no existing information will be overwritten by a NULL value.
 * @param p_parent_basin_id            The location identifier of the parent basin if this is a sub-basin
 * @param p_sort_order                 A number to be used in sorting the sub-basins of the parent basin
 * @param p_primary_stream_id          The location identifier of the primary stream that drains the basin
 * @param p_total_drainage_area        The total area of the basin, including non-contributing drainage area
 * @param p_contributing_drainage_area The area of the basin that contributes flow to the primary stream
 * @param p_area_unit                  The unit of the area parameters
 * @param p_office_id                  The office that owns the basin location
 *
 * @exception ITEM_ALREADY_EXISTS if p_fail_if_exists is 'T' and the basin location already exists
 * @exception ERROR if the basin location identifier already exists and is not a CWMS basin
 */
procedure store_basin(
   p_basin_id                   in varchar2,
   p_fail_if_exists             in varchar2,
   p_ignore_nulls               in varchar2,
   p_parent_basin_id            in varchar2 default null,
   p_sort_order                 in binary_double default null,
   p_primary_stream_id          in varchar2 default null,
   p_total_drainage_area        in binary_double default null,
   p_contributing_drainage_area in binary_double default null,
   p_area_unit                  in varchar2 default null,
   p_office_id                  in varchar2 default null);
/**
 * Retrieves a basin from the database
 *
 * @param p_parent_basin_id            The location identifier of the parent basin if this is a sub-basin
 * @param p_sort_order                 A number to be used in sorting the sub-basins of the parent basin
 * @param p_primary_stream_id          The location identifier of the primary stream that drains the basin
 * @param p_total_drainage_area        The total area of the basin, including non-contributing drainage area
 * @param p_contributing_drainage_area The area of the basin that contributes flow to the primary stream
 * @param p_basin_id                   The location identifier of the basin
 * @param p_area_unit                  The unit to return areas in
 * @param p_office_id                  The office that owns the basin location
 *
 * @exception ITEM_DOES_NOT_EXIST if no such basin location exists
 */
procedure retrieve_basin(
   p_parent_basin_id            out varchar2,
   p_sort_order                 out binary_double,
   p_primary_stream_id          out varchar2,
   p_total_drainage_area        out binary_double,
   p_contributing_drainage_area out binary_double,
   p_basin_id                   in  varchar2,
   p_area_unit                  in  varchar2,
   p_office_id                  in  varchar2 default null);
/**
 * Deletes a basin from the database
 *
 * @see constant cwms_util.delete_key
 * @see constant cwms_util.delete_data
 * @see constant cwms_util.delete_all
 *
 * @param p_basin_id The location identifier of the basin
 *
 * @param p_delete_action Specifies what to delete.  Actions are as follows:
 * <p>
 * <table class="descr">
 *   <tr>
 *     <th class="descr">p_delete_action</th>
 *     <th class="descr">Action</th>
 *   </tr>
 *   <tr>
 *     <td class="descr">cwms_util.delete_key</td>
 *     <td class="descr">deletes only this basin, and then only if it has no sub-basins</td>
 *   </tr>
 *   <tr>
 *     <td class="descr">cwms_util.delete_data</td>
 *     <td class="descr">deletes only sub-basins of this basin, if any</td>
 *   </tr>
 *   <tr>
 *     <td class="descr">cwms_util.delete_all</td>
 *     <td class="descr">deletes this basin and its sub-basins, if any</td>
 *   </tr>
 * </table>
 * @param p_office_id The office that owns the basin location
 *
 * @exception ITEM_DOES_NOT_EXIST if no such basin location exists
 */
procedure delete_basin(
   p_basin_id      in varchar2,
   p_delete_action in varchar2 default cwms_util.delete_key,
   p_office_id     in varchar2 default null);
/**
 * Renames an existing basin
 *
 * @param p_old_basin_id The existing location identifier of the basin
 * @param p_new_basin_id The new location identifier of the basin
 * @param p_office_id        The office that owns the basin location
 *
 * @exception ITEM_DOES_NOT_EXIST if no such basin location exists
 */
procedure rename_basin(
   p_old_basin_id in varchar2,
   p_new_basin_id in varchar2,
   p_office_id    in varchar2 default null);
/**
 * Catalogs basins in the database that match input parameters. Matching is
 * accomplished with glob-style wildcards, as shown below, instead of sql-style
 * wildcards.
 * <p>
 * <table class="descr">
 *   <tr>
 *     <th class="descr">Wildcard</th>
 *     <th class="descr">Meaning</th>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">*</td>
 *     <td class="descr">Match zero or more characters</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">?</td>
 *     <td class="descr">Match a single character</td>
 *   </tr>
 * </table>
 *
 * @param p_basins_catalog A cursor containing all matching basins.  The cursor contains
 * the following columns:
 * <p>
 * <table class="descr">
 *   <tr>
 *     <th class="descr">Column No.</th>
 *     <th class="descr">Column Name</th>
 *     <th class="descr">Data Type</th>
 *     <th class="descr">Contents</th>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">1</td>
 *     <td class="descr">office_id</td>
 *     <td class="descr">varchar2(16)</td>
 *     <td class="descr">The office that owns the basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">2</td>
 *     <td class="descr">basin_id</td>
 *     <td class="descr">varchar2(49)</td>
 *     <td class="descr">The location identifier of the basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">3</td>
 *     <td class="descr">parent_basin_id</td>
 *     <td class="descr">varchar2(49)</td>
 *     <td class="descr">The location identifier of the parent basin, if any</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">4</td>
 *     <td class="descr">sort_order</td>
 *     <td class="descr">binary_double</td>
 *     <td class="descr">The sort order of the basin within it parent basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">5</td>
 *     <td class="descr">primary_stream_id</td>
 *     <td class="descr">varchar2(49)</td>
 *     <td class="descr">The location identifier of the primary stream</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">6</td>
 *     <td class="descr">total_drainage_area</td>
 *     <td class="descr">binary_double</td>
 *     <td class="descr">The total drainage area of the basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">7</td>
 *     <td class="descr">contributing_drainage_area</td>
 *     <td class="descr">binary_double</td>
 *     <td class="descr">The contributing area of the basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">8</td>
 *     <td class="descr">area_unit</td>
 *     <td class="descr">varchar2(16)</td>
 *     <td class="descr">The unit of the total and contributing drainage areas</td>
 *   </tr>
 * </table>
 *
 * @param p_basin_id_mask  The basin location pattern to match. Use glob-style
 * wildcard characters as shown above instead of sql-style wildcard characters for pattern
 * matching.
 *
 * @param p_parent_basin_id_mask  The parent basin location pattern to match. Use glob-style
 * wildcard characters as shown above instead of sql-style wildcard characters for pattern
 * matching.
 *
 * @param p_primary_stream_id_mask   The primary stream location pattern to match. Use glob-style
 * wildcard characters as shown above instead of sql-style wildcard characters for pattern
 * matching.
 *
 * @param p_area_unit The unit in which to list areas
 *
 * @param p_office_id_mask  The office pattern to match.  If the routine is called
 * without this parameter, or if this parameter is set to NULL, the session user's
 * default office will be used. For matching multiple office, use glob-style
 * wildcard characters as shown above instead of sql-style wildcard characters for pattern
 * matching.
 */
procedure cat_basins(
   p_basins_catalog         out sys_refcursor,
   p_basin_id_mask          in  varchar2 default '*',
   p_parent_basin_id_mask   in  varchar2 default '*',
   p_primary_stream_id_mask in  varchar2 default '*',
   p_area_unit              in  varchar2 default null,
   p_office_id_mask         in  varchar2 default null);
/**
 * Catalogs basins in the database that match input parameters. Matching is
 * accomplished with glob-style wildcards, as shown below, instead of sql-style
 * wildcards.
 * <p>
 * <table class="descr">
 *   <tr>
 *     <th class="descr">Wildcard</th>
 *     <th class="descr">Meaning</th>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">*</td>
 *     <td class="descr">Match zero or more characters</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">?</td>
 *     <td class="descr">Match a single character</td>
 *   </tr>
 * </table>
 *
 * @param p_basin_id_mask  The basin location pattern to match. Use glob-style
 * wildcard characters as shown above instead of sql-style wildcard characters for pattern
 * matching.
 *
 * @param p_parent_basin_id_mask  The parent basin location pattern to match. Use glob-style
 * wildcard characters as shown above instead of sql-style wildcard characters for pattern
 * matching.
 *
 * @param p_primary_stream_id_mask   The primary stream location pattern to match. Use glob-style
 * wildcard characters as shown above instead of sql-style wildcard characters for pattern
 * matching.
 *
 * @param p_area_unit The unit in which to list areas
 *
 * @param p_office_id_mask  The office pattern to match.  If the routine is called
 * without this parameter, or if this parameter is set to NULL, the session user's
 * default office will be used. For matching multiple office, use glob-style
 * wildcard characters as shown above instead of sql-style wildcard characters for pattern
 * matching.
 *
 * @return A cursor containing all matching basins.  The cursor contains
 * the following columns:
 * <p>
 * <table class="descr">
 *   <tr>
 *     <th class="descr">Column No.</th>
 *     <th class="descr">Column Name</th>
 *     <th class="descr">Data Type</th>
 *     <th class="descr">Contents</th>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">1</td>
 *     <td class="descr">office_id</td>
 *     <td class="descr">varchar2(16)</td>
 *     <td class="descr">The office that owns the basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">2</td>
 *     <td class="descr">basin_id</td>
 *     <td class="descr">varchar2(49)</td>
 *     <td class="descr">The location identifier of the basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">3</td>
 *     <td class="descr">parent_basin_id</td>
 *     <td class="descr">varchar2(49)</td>
 *     <td class="descr">The location identifier of the parent basin, if any</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">4</td>
 *     <td class="descr">sort_order</td>
 *     <td class="descr">binary_double</td>
 *     <td class="descr">The sort order of the basin within it parent basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">5</td>
 *     <td class="descr">primary_stream_id</td>
 *     <td class="descr">varchar2(49)</td>
 *     <td class="descr">The location identifier of the primary stream</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">6</td>
 *     <td class="descr">total_drainage_area</td>
 *     <td class="descr">binary_double</td>
 *     <td class="descr">The total drainage area of the basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">7</td>
 *     <td class="descr">contributing_drainage_area</td>
 *     <td class="descr">binary_double</td>
 *     <td class="descr">The contributing area of the basin</td>
 *   </tr>
 *   <tr>
 *     <td class="descr-center">8</td>
 *     <td class="descr">area_unit</td>
 *     <td class="descr">varchar2(16)</td>
 *     <td class="descr">The unit of the total and contributing drainage areas</td>
 *   </tr>
 * </table>
 */
function cat_basins_f(
   p_basin_id_mask          in varchar2 default '*',
   p_parent_basin_id_mask   in varchar2 default '*',
   p_primary_stream_id_mask in varchar2 default '*',
   p_area_unit              in varchar2 default null,
   p_office_id_mask         in varchar2 default null)
   return sys_refcursor;
/**
 * Retrieves the volume of runoff from a depth of excess precipitation
 *
 * @param p_runoff_volume       The volume of runoff in the specified unit
 * @param p_basin_id            The location identifier of the basin
 * @param p_precip_excess_depth The excess depth of precipitation in the specified unit
 * @param p_precip_unit         The precipitation unit
 * @param p_volume_unit         The volume unit
 * @param p_office_id           The office that owns the basin
 *
 * @exception ITEM_DOES_NOT_EXIST if no such basin location exists
 */
procedure get_runoff_volume(
   p_runoff_volume       out binary_double,
   p_basin_id            in  varchar2,
   p_precip_excess_depth in  binary_double,
   p_precip_unit         in  varchar2,
   p_volume_unit         in  varchar2,
   p_office_id           in  varchar2 default null);
/**
 * Retrieves the volume of runoff from a depth of excess precipitation
 *
 * @param p_basin_id            The location identifier of the basin
 * @param p_precip_excess_depth The excess depth of precipitation in the specified unit
 * @param p_precip_unit         The precipitation unit
 * @param p_volume_unit         The volume unit
 * @param p_office_id           The office that owns the basin
 *
 * @return The volume of runoff in the specified unit
 *
 * @exception ITEM_DOES_NOT_EXIST if no such basin location exists
 */
function get_runoff_volume_f(
   p_basin_id            in varchar2,
   p_precip_excess_depth in binary_double,
   p_precip_unit         in varchar2,
   p_volume_unit         in varchar2,
   p_office_id           in varchar2 default null)
   return binary_double;

end cwms_basin;
CREATE OR REPLACE PACKAGE BODY "CWMS_20"."CWMS_BASIN" as
--------------------------------------------------------------------------------
-- function get_basin_code
--------------------------------------------------------------------------------
function get_basin_code(
   p_basin_id  in varchar2,
   p_office_id in varchar2 default null)
   return number
is
   l_basin_code number(10);
   l_office_id  varchar2(16);
begin
   ------------------
   -- sanity check --
   ------------------
   cwms_util.check_inputs(str_tab_t(p_basin_id, p_office_id));
   if p_basin_id is null then
      cwms_err.raise(
         'INVALID_ITEM',
         '<NULL>',
         'CWMS basin identifier');
   end if;
   l_office_id := nvl(upper(p_office_id), cwms_util.user_office_id);
   begin
      l_basin_code := cwms_loc.get_location_code(l_office_id, p_basin_id);
      select basin_location_code
        into l_basin_code
        from at_basin
       where basin_location_code = l_basin_code;
   exception
      when others then
         cwms_err.raise(
            'ITEM_DOES_NOT_EXIST',
            'CWMS basin identifier.',
            l_office_id
            ||'/'
            ||p_basin_id);
   end;
   return l_basin_code;
end get_basin_code;

--------------------------------------------------------------------------------
-- procedure store_basin
--------------------------------------------------------------------------------
procedure store_basin(
   p_basin_id                   in varchar2,
   p_fail_if_exists             in varchar2,
   p_ignore_nulls               in varchar2,
   p_parent_basin_id            in varchar2 default null,
   p_sort_order                 in binary_double default null,
   p_primary_stream_id          in varchar2 default null,
   p_total_drainage_area        in binary_double default null,
   p_contributing_drainage_area in binary_double default null,
   p_area_unit                  in varchar2 default null,
   p_office_id                  in varchar2 default null)
is
   l_office_id        varchar2(16);
   l_location_kind_id varchar2(32);
   l_fail_if_exists   boolean;
   l_ignore_nulls     boolean;
   l_exists           boolean;
   l_rec              at_basin%rowtype;
begin
   -------------------
   -- sanity checks --
   -------------------
   cwms_util.check_inputs(str_tab_t(
      p_basin_id,
      p_fail_if_exists,
      p_ignore_nulls,
      p_parent_basin_id,
      p_primary_stream_id,
      p_area_unit,
      p_office_id));
   if p_basin_id is null then
      cwms_err.raise(
         'INVALID_ITEM',
         '<NULL>',
         'CWMS basin identifier');
   end if;
   if p_area_unit is null then
      if coalesce(p_total_drainage_area, p_contributing_drainage_area) is not null then
         cwms_err.raise(
            'ERROR',
            'Area unit must be specified if areas are specified');
      end if;
   end if;
   l_office_id := nvl(upper(p_office_id), cwms_util.user_office_id);
   l_fail_if_exists := cwms_util.is_true(p_fail_if_exists);
   l_ignore_nulls   := cwms_util.is_true(p_ignore_nulls);
   begin
      l_rec.basin_location_code := get_basin_code(l_office_id, p_basin_id);
      l_exists := true;
   exception
      when others then
         l_exists := false;
   end;
   if l_exists then
      if l_fail_if_exists then
         cwms_err.raise(
            'ITEM_ALREADY_EXISTS',
            'CWMS basin',
            l_office_id
            ||'/'
            ||p_basin_id);
      end if;
   else
      begin
         l_rec.basin_location_code := cwms_loc.get_location_code(l_office_id, p_basin_id);
      exception
         when others then null;
      end;
      if l_rec.basin_location_code is null then
         l_rec.basin_location_code := cwms_seq.nextval;
      else
         if cwms_loc.get_location_type(l_rec.basin_location_code) not in ('BASIN', 'NONE') then
            cwms_err.raise(
               'ERROR',
               'The location '
               ||l_office_id
               ||'/'
               ||p_basin_id
               ||' exists and is not a CWMS basin');
         end if;
      end if;
   end if;
   -------------------------
   -- populate the record --
   -------------------------
   if p_parent_basin_id is not null or l_ignore_nulls then
      if p_parent_basin_id is null then
         l_rec.parent_basin_code := null;
      else
         l_rec.parent_basin_code := get_basin_code(l_office_id, p_parent_basin_id);
      end if;
   end if;
   if p_primary_stream_id is not null or l_ignore_nulls then
      if p_primary_stream_id is null then
         l_rec.primary_stream_code := null;
      else
         l_rec.primary_stream_code := cwms_stream.get_stream_code(l_office_id, p_primary_stream_id);
      end if;
   end if;
   if p_sort_order is not null or l_ignore_nulls then
      l_rec.sort_order := p_sort_order;
   end if;
   if p_total_drainage_area is not null or l_ignore_nulls then
      l_rec.total_drainage_area := cwms_util.convert_units(
         p_total_drainage_area,
         cwms_util.get_unit_id(p_area_unit),
         'm2');
   end if;
   if p_contributing_drainage_area is not null or l_ignore_nulls then
      l_rec.contributing_drainage_area := cwms_util.convert_units(
         p_contributing_drainage_area,
         cwms_util.get_unit_id(p_area_unit),
         'm2');
   end if;
   ---------------------------------
   -- update or insert the record --
   ---------------------------------
   if l_exists then
      update at_basin
         set row = l_rec
       where basin_location_code = l_rec.basin_location_code;
   else
      insert
        into at_basin
      values l_rec;
   end if;
end store_basin;

--------------------------------------------------------------------------------
-- procedure retrieve_basin
--------------------------------------------------------------------------------
procedure retrieve_basin(
   p_parent_basin_id            out varchar2,
   p_sort_order                 out binary_double,
   p_primary_stream_id          out varchar2,
   p_total_drainage_area        out binary_double,
   p_contributing_drainage_area out binary_double,
   p_basin_id                   in  varchar2,
   p_area_unit                  in  varchar2,
   p_office_id                  in  varchar2 default null)
is
   l_rec at_basin%rowtype;
begin
   -------------------
   -- sanity checks --
   -------------------
   cwms_util.check_inputs(str_tab_t(
      p_basin_id,
      p_area_unit,
      p_office_id));
   if p_basin_id is null then
      cwms_err.raise(
         'INVALID_ITEM',
         '<NULL>',
         'CWMS basin identifier');
   end if;
   if p_area_unit is null then
      cwms_err.raise(
         'ERROR',
         'Area unit must not be null.');
   end if;
   --------------------
   -- get the record --
   --------------------
   select *
     into l_rec
     from at_basin
    where basin_location_code = get_basin_code(p_office_id, p_basin_id);
   -------------------------
   -- populate the output --
   -------------------------
   if l_rec.parent_basin_code is not null then
      select bl.base_location_id
             ||substr('-', 1, length(pl.sub_location_id))
             ||pl.sub_location_id
        into p_parent_basin_id
        from at_physical_location pl,
             at_base_location bl
       where pl.location_code = l_rec.parent_basin_code
         and bl.base_location_code = pl.base_location_code;
   end if;
   p_sort_order := l_rec.sort_order;
   if l_rec.primary_stream_code is not null then
      select bl.base_location_id
             ||substr('-', 1, length(pl.sub_location_id))
             ||pl.sub_location_id
        into p_primary_stream_id
        from at_physical_location pl,
             at_base_location bl
       where pl.location_code = l_rec.primary_stream_code
         and bl.base_location_code = pl.base_location_code;
   end if;
   p_total_drainage_area := cwms_util.convert_units(
      l_rec.total_drainage_area,
      'm2',
      cwms_util.get_unit_id(p_area_unit));
   p_contributing_drainage_area := cwms_util.convert_units(
      l_rec.contributing_drainage_area,
      'm2',
      cwms_util.get_unit_id(p_area_unit));
end retrieve_basin;

--------------------------------------------------------------------------------
-- procedure delete_basin
--------------------------------------------------------------------------------
procedure delete_basin(
   p_basin_id      in varchar2,
   p_delete_action in varchar2 default cwms_util.delete_key,
   p_office_id     in varchar2 default null)
is
   l_basin_code    number(10);
   l_delete_action varchar2(16);
begin
   -------------------
   -- sanity checks --
   -------------------
   cwms_util.check_inputs(str_tab_t(
      p_delete_action,
      p_office_id));
   if p_basin_id is null then
      cwms_err.raise(
         'INVALID_ITEM',
         '<NULL>',
         'CWMS basin identifier');
   end if;
   l_delete_action := upper(substr(p_delete_action, 1, 16));
   if l_delete_action not in (
      cwms_util.delete_key,
      cwms_util.delete_data,
      cwms_util.delete_all)
   then
      cwms_err.raise(
         'ERROR',
         'Delete action must be one of '''
         ||cwms_util.delete_key
         ||''',  '''
         ||cwms_util.delete_data
         ||''', or '''
         ||cwms_util.delete_all
         ||'');
   end if;
   l_basin_code := get_basin_code(p_office_id, p_basin_id);
   -------------------------------------------
   -- delete the child records if specified --
   -------------------------------------------
   if l_delete_action in (cwms_util.delete_data, cwms_util.delete_all) then
      for rec in
         (  select bl.base_location_id
                   ||substr('-', 1, length(pl.sub_location_id))
                   ||pl.sub_location_id as basin_id
              from at_physical_location pl,
                   at_base_location bl
             where pl.location_code in
                   ( select basin_location_code
                       from at_basin
                      where parent_basin_code = l_basin_code
                   )
               and bl.base_location_code = pl.base_location_code
         )
      loop
         delete_basin(rec.basin_id, cwms_util.delete_all, p_office_id);
      end loop;
   end if;
   ------------------------------------
   -- delete the record if specified --
   ------------------------------------
   if l_delete_action in (cwms_util.delete_key, cwms_util.delete_all) then
      delete
        from at_basin
       where basin_location_code = l_basin_code;
   end if;
end delete_basin;

--------------------------------------------------------------------------------
-- procedure rename_basin
--------------------------------------------------------------------------------
procedure rename_basin(
   p_old_basin_id in varchar2,
   p_new_basin_id in varchar2,
   p_office_id    in varchar2 default null)
is
   l_basin_code number(10);
begin
   -------------------
   -- sanity checks --
   -------------------
   cwms_util.check_inputs(str_tab_t(
      p_old_basin_id,
      p_new_basin_id,
      p_office_id));
   if p_old_basin_id is null then
      cwms_err.raise(
         'INVALID_ITEM',
         '<NULL>',
         'CWMS basin identifier');
   end if;
   if p_new_basin_id is null then
      cwms_err.raise(
         'INVALID_ITEM',
         '<NULL>',
         'CWMS basin identifier');
   end if;
   l_basin_code := get_basin_code(p_office_id, p_old_basin_id);
   -------------------------------
   -- rename the basin location --
   -------------------------------
   cwms_loc.rename_location(p_old_basin_id, p_new_basin_id, p_office_id);
end rename_basin;

--------------------------------------------------------------------------------
-- procedure cat_basins
--
-- the catalog contains the following fields, sorted by the first 4
--
--    office_id                  varchar2(16)
--    basin_id                   varchar2(49)
--    parent_basin_id            varchar2(49)
--    sort_order                 binary_double
--    primary_stream_id          varchar2(49)
--    total_drainage_area        binary_double
--    contributing_drainage_area binary_double
--    area_unit                  varchar2(16)
--
--------------------------------------------------------------------------------
procedure cat_basins(
   p_basins_catalog         out sys_refcursor,
   p_basin_id_mask          in  varchar2 default '*',
   p_parent_basin_id_mask   in  varchar2 default '*',
   p_primary_stream_id_mask in  varchar2 default '*',
   p_area_unit              in  varchar2 default null,
   p_office_id_mask         in  varchar2 default null)
is
   l_basin_id_mask          varchar2(49);
   l_parent_basin_id_mask   varchar2(49);
   l_primary_stream_id_mask varchar2(49);
   l_office_id_mask         varchar2(16);
   l_area_unit              varchar2(16);
begin
   ------------------
   -- sanity check --
   ------------------
   cwms_util.check_inputs(str_tab_t(
      p_basin_id_mask,
      p_parent_basin_id_mask,
      p_primary_stream_id_mask,
      p_area_unit,
      p_office_id_mask));
   l_basin_id_mask          := cwms_util.normalize_wildcards(upper(p_basin_id_mask));
   l_parent_basin_id_mask   := cwms_util.normalize_wildcards(upper(p_parent_basin_id_mask));
   l_primary_stream_id_mask := cwms_util.normalize_wildcards(upper(p_primary_stream_id_mask));
   l_office_id_mask         := cwms_util.normalize_wildcards(
                                  nvl(upper(p_office_id_mask), cwms_util.user_office_id));
   l_area_unit := cwms_util.get_unit_id(nvl(p_area_unit, 'm2'));

   open p_basins_catalog for
      select basin.office_id,
             basin.basin_id,
             parent_basin.basin_id as parent_basin_id,
             basin.sort_order,
             primary_stream.stream_id as primary_stream_id,
             basin.total_drainage_area,
             basin.contributing_drainage_area,
             l_area_unit as area_unit
        from ( select o.office_id,
                      bl.base_location_id
                      ||substr('-', 1, length(pl.sub_location_id))
                      ||pl.sub_location_id as basin_id,
                      sort_order,
                      cwms_util.convert_units(
                         total_drainage_area,
                         'm2',
                         l_area_unit) as total_drainage_area,
                      cwms_util.convert_units(
                         contributing_drainage_area,
                         'm2',
                         l_area_unit) as contributing_drainage_area,
                      b.parent_basin_code,
                      b.primary_stream_code
                 from at_basin b,
                      at_physical_location pl,
                      at_base_location bl,
                      cwms_office o
                where pl.location_code = b.basin_location_code
                  and bl.base_location_code = pl.base_location_code
                  and o.office_code = bl.db_office_code
                  and o.office_id like l_office_id_mask escape '\'
                  and upper(bl.base_location_id
                      ||substr('-', 1, length(pl.sub_location_id))
                      ||pl.sub_location_id) like l_basin_id_mask escape '\'
             ) basin

             left outer join
             ( select pl.location_code,
                      bl.base_location_id
                      ||substr('-', 1, length(pl.sub_location_id))
                      ||pl.sub_location_id as basin_id
                 from at_physical_location pl,
                      at_base_location bl,
                      cwms_office o
                where o.office_id like l_office_id_mask escape '\'
                  and bl.db_office_code = o.office_code
                  and pl.base_location_code = bl.base_location_code
                  and upper(bl.base_location_id
                      ||substr('-', 1, length(pl.sub_location_id))
                      ||pl.sub_location_id) like l_parent_basin_id_mask
             ) parent_basin
             on parent_basin.location_code = basin.parent_basin_code

             left outer join
             ( select pl.location_code,
                      bl.base_location_id
                      ||substr('-', 1, length(pl.sub_location_id))
                      ||pl.sub_location_id as stream_id
                 from at_physical_location pl,
                      at_base_location bl,
                      cwms_office o
                where o.office_id like l_office_id_mask escape '\'
                  and bl.db_office_code = o.office_code
                  and pl.base_location_code = bl.base_location_code
                  and upper(bl.base_location_id
                      ||substr('-', 1, length(pl.sub_location_id))
                      ||pl.sub_location_id) like l_primary_stream_id_mask
             ) primary_stream
             on primary_stream.location_code = basin.primary_stream_code

       where ( parent_basin.basin_id like l_parent_basin_id_mask escape '\'
               or
               (basin.parent_basin_code is null and l_parent_basin_id_mask = '%')
             )
         and ( primary_stream.stream_id like l_primary_stream_id_mask escape '\'
               or
               (basin.primary_stream_code is null and l_primary_stream_id_mask = '%')
             )
    order by basin.office_id,
             basin.basin_id,
             parent_basin.basin_id,
             basin.sort_order nulls first;
end cat_basins;

--------------------------------------------------------------------------------
-- function cat_basins_f
--
-- the catalog contains the following fields, sorted by the first 4
--
--    office_id                  varchar2(16)
--    basin_id                   varchar2(49)
--    parent_basin_id            varchar2(49)
--    sort_order                 binary_double
--    primary_stream_id          varchar2(49)
--    total_drainage_area        binary_double
--    contributing_drainage_area binary_double
--    area_unit                  varchar2(16)
--
--------------------------------------------------------------------------------
function cat_basins_f(
   p_basin_id_mask          in varchar2 default '*',
   p_parent_basin_id_mask   in varchar2 default '*',
   p_primary_stream_id_mask in varchar2 default '*',
   p_area_unit              in varchar2 default null,
   p_office_id_mask         in varchar2 default null)
   return sys_refcursor
is
   l_cursor sys_refcursor;
begin
   cat_basins(
      l_cursor,
      p_basin_id_mask,
      p_parent_basin_id_mask,
      p_primary_stream_id_mask,
      p_area_unit,
      p_office_id_mask);

   return l_cursor;
end cat_basins_f;

--------------------------------------------------------------------------------
-- procedure get_runoff_volume
--------------------------------------------------------------------------------
procedure get_runoff_volume(
   p_runoff_volume       out binary_double,
   p_basin_id            in  varchar2,
   p_precip_excess_depth in  binary_double,
   p_precip_unit         in  varchar2,
   p_volume_unit         in  varchar2,
   p_office_id           in  varchar2 default null)
is
   l_contributing_area binary_double;
begin
   -------------------
   -- sanity checks --
   -------------------
   cwms_util.check_inputs(str_tab_t(
      p_basin_id,
      p_precip_unit,
      p_volume_unit,
      p_office_id));
   if p_basin_id is null then
      cwms_err.raise(
         'INVALID_ITEM',
         '<NULL>',
         'CWMS basin identifier');
   end if;
   if p_precip_unit is null then
      cwms_err.raise(
         'ERROR',
         'Precipitation unit must not be null.');
   end if;
   if p_volume_unit is null then
      cwms_err.raise(
         'ERROR',
         'Volume unit must not be null.');
   end if;
   select contributing_drainage_area
     into l_contributing_area
     from at_basin
    where basin_location_code = get_basin_code(p_office_id, p_basin_id);
   p_runoff_volume := cwms_util.convert_units(
      l_contributing_area * cwms_util.convert_units(
         p_precip_excess_depth,
         cwms_util.get_unit_id(p_precip_unit),
         'm'),
      'm3',
      cwms_util.get_unit_id(p_volume_unit));
end get_runoff_volume;

--------------------------------------------------------------------------------
-- function get_runoff_volume_f
--------------------------------------------------------------------------------
function get_runoff_volume_f(
   p_basin_id            in varchar2,
   p_precip_excess_depth in binary_double,
   p_precip_unit         in varchar2,
   p_volume_unit         in varchar2,
   p_office_id           in varchar2 default null)
   return binary_double
is
   l_runoff_volume binary_double;
begin
   get_runoff_volume(
      l_runoff_volume,
      p_basin_id,
      p_precip_excess_depth,
      p_precip_unit,
      p_volume_unit,
      p_office_id);

   return l_runoff_volume;
end get_runoff_volume_f;

end cwms_basin;
 
  GRANT EXECUTE ON "CWMS_20"."CWMS_BASIN" TO "CWMS_USER"
 