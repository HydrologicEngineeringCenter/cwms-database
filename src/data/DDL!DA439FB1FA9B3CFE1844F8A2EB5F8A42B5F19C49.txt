
  CREATE OR REPLACE TYPE "CWMS_20"."LOC_LVL_INDICATOR_T" 
/**
 * Holds a location level indiator.  A location level indicator indicates the status
 * of a time series of values with respect to a location level.  A location level
 * indicator may have up to five conditions, each with a unique level value in the
 * range (1..5), and multiple conditions may be set simultaneously (e.g. the conditions
 * need not be mutually exclusive).
 *
 * @see type loc_lvl_ind_cond_tab_t
 * @see type loc_lvl_indicator_tab_t
 *
 * @member office_id              The office that owns the location and specified level
 * @member location_id            The location portion of the location level indicator
 * @member parameter_id           The parameter portion of the location level indicator
 * @member parameter_type_id      The parameter type portion of the location level indicator
 * @member duration_id            The duration portion of the location level indicator
 * @member specified_level_id     The specified level portion of the location level indicator
 * @member level_indicator_id     The indicator portion of the location level indicator
 * @member attr_value             The attribute value of the location level, if any, in the specified unit
 * @member attr_units_id          The specified unit of the location level attribute, if any
 * @member attr_parameter_id      The parameter of the location level attribute, if any
 * @member attr_parameter_type_id The parameter type of the location level attribute, if any
 * @member attr_duration_id       The duration of the location level attribute, if any
 * @member ref_specified_level_id The specified level portion of the referenced location level, if any
 * @member ref_attr_value         The attribute value of the referenced location level, if any, in the specified unit
 * @member minimum_duration       The minimum amount of time a condition must continuously evalutate to TRUE for that condition to be considered to be set
 * @member maximum_age            The maximum age of the most current time series value for any conditions to be evalutated
 * @member conditions             The location level indicator conditions
 */
is object
(
   office_id              varchar2(16),
   location_id            varchar2(49),
   parameter_id           varchar2(49),
   parameter_type_id      varchar2(16),
   duration_id            varchar2(16),
   specified_level_id     varchar2(256),
   level_indicator_id     varchar2(32),
   attr_value             number,
   attr_units_id          varchar2(16),
   attr_parameter_id      varchar2(49),
   attr_parameter_type_id varchar2(16),
   attr_duration_id       varchar2(16),
   ref_specified_level_id varchar2(256),
   ref_attr_value         number,
   minimum_duration       interval day to second,
   maximum_age            interval day to second,
   conditions             loc_lvl_ind_cond_tab_t,
   -- not documented
   constructor function loc_lvl_indicator_t(
      p_obj in zloc_lvl_indicator_t)
      return self as result,
   -- not documented
   constructor function loc_lvl_indicator_t(
      p_rowid in urowid)
      return self as result,
   -- not documented
   member procedure init(
      p_obj in zloc_lvl_indicator_t),
   -- not documented
   member function zloc_lvl_indicator
      return zloc_lvl_indicator_t,
   /**
    * Stores the loc_lvl_indicator_t object to the database
    */
   member procedure store,
   /**
    * Retrieves which indicator conditions are set, if any, for the specifed time
    * series values
    *
    * @see type ztsv_array
    * @see type number_tab_t
    *
    * @param p_ts        the time series to use in determining which indicator
    *                    conditions are set
    * @param p_eval_time the date/time to use in determining which indicator conditions
    *        are set.  If NULL, the current date/time is used.
    *
    * @return the condition values for each condition that is set. If no conditions are
    *         set, an empty collection (not NULL) is returned.
    */
   member function get_indicator_values(
      p_ts        in ztsv_array,
      p_eval_time in date default null)
      return number_tab_t,
   /**
    * Retrieves the maximum condition level that is set, if any, for the specified
    * time series values
    *
    * @see type ztsv_array
    *
    * @param p_ts        the time series to use in determining which indicator
    *                    conditions are set
    * @param p_eval_time the date/time to use in determining which indicator conditions
    *        are set.  If NULL, the current date/time is used.
    *
    * @return the maximum condition level that is set, if any, for the specified
    *         time series values. If no condition is set, 0 (zero) is returned.
    */
   member function get_max_indicator_value(
      p_ts        in ztsv_array,
      p_eval_time in date default null)
      return number,
   /**
    * Generates a time series of maximum set level conditions, if, any for the specified
    * time series.
    *
    * @see type ztsv_array
    *
    * @param p_ts         the time series to use in determining which indicator
    *                     conditions are set
    * @param p_start_time the earliest time for which to retrieve the maximum level
    *                     condition that is set
    *
    * @return a time series of the maximum set level conditions, if any. Each element
    *         of the returned time series has its fields set as:
    *         <dl>
    *           <dd>date_time</dd><dt>the time date_time field of the input time series</dt>
    *           <dd>value</dd><dt>the maximum location level condition that was set at that date/time, or 0 (zero) if none were set</dt>
    *           <dd>quality_code</dd><dt>Unused, always set to 0 (zero)</dt>
    *         </dl>
    */
   member function get_max_indicator_values(
      p_ts         in ztsv_array,
      p_start_time in date)
      return ztsv_array

);
CREATE OR REPLACE TYPE BODY "CWMS_20"."LOC_LVL_INDICATOR_T" 
as
   constructor function loc_lvl_indicator_t(
      p_obj in zloc_lvl_indicator_t)
      return self as result
   is
   begin
      init(p_obj);
      return;
   end loc_lvl_indicator_t;

   constructor function loc_lvl_indicator_t(
      p_rowid in urowid)
      return self as result
   is
   begin
      init(zloc_lvl_indicator_t(p_rowid));
      return;
   end loc_lvl_indicator_t;

   member procedure init(
      p_obj in zloc_lvl_indicator_t)
   is
   begin
      select o.office_id,
             bl.base_location_id
             || substr('-', 1, length(pl.sub_location_id))
             || pl.sub_location_id
        into office_id,
             location_id
        from at_physical_location pl,
             at_base_location bl,
             cwms_office o
       where pl.location_code = p_obj.location_code
         and bl.base_location_code = pl.base_location_code
         and o.office_code = bl.db_office_code;

      select bp.base_parameter_id
             || substr('-', 1, length(p.sub_parameter_id))
             || p.sub_parameter_id
        into parameter_id
        from at_parameter p,
             cwms_base_parameter bp
       where p.parameter_code = p_obj.parameter_code
         and bp.base_parameter_code = p.base_parameter_code;

      select parameter_type_id
        into parameter_type_id
        from cwms_parameter_type
       where parameter_type_code = p_obj.parameter_type_code;

      select duration_id
        into duration_id
        from cwms_duration
       where duration_code = p_obj.duration_code;

      select specified_level_id
        into specified_level_id
        from at_specified_level
       where specified_level_code = p_obj.specified_level_code;

      if p_obj.attr_value is not null then
         select bp.base_parameter_id
                || substr('-', 1, length(p.sub_parameter_id))
                || p.sub_parameter_id,
                u.unit_id
           into attr_parameter_id,
                attr_units_id
           from at_parameter p,
                cwms_base_parameter bp,
                cwms_unit u
          where p.parameter_code = p_obj.attr_parameter_code
            and bp.base_parameter_code = p.base_parameter_code
            and u.unit_code = bp.unit_code;

         select parameter_type_id
           into attr_parameter_type_id
           from cwms_parameter_type
          where parameter_type_code = p_obj.attr_parameter_type_code;

         select duration_id
           into attr_duration_id
           from cwms_duration
          where duration_code = p_obj.attr_duration_code;
         attr_value := p_obj.attr_value;
      end if;

      if p_obj.ref_specified_level_code is not null then
         select specified_level_id
           into ref_specified_level_id
           from at_specified_level
          where specified_level_code = p_obj.ref_specified_level_code;
         ref_attr_value := p_obj.ref_attr_value;
      end if;

      level_indicator_id := p_obj.level_indicator_id;
      minimum_duration   := p_obj.minimum_duration;
      maximum_age        := p_obj.maximum_age;
      conditions         := p_obj.conditions;
   end init;

   member function zloc_lvl_indicator
      return zloc_lvl_indicator_t
   is
      l_parts       str_tab_t;
      l_obj         zloc_lvl_indicator_t := new zloc_lvl_indicator_t;
      l_sub_id      varchar2(48);
      l_id          varchar2(256);
      l_factor      binary_double;
      l_offset      binary_double;
   begin
      l_parts := cwms_util.split_text(location_id, '-', 1);
      l_sub_id := case l_parts.count
                     when 1 then null
                     else l_parts(2)
                  end;
      select pl.location_code
        into l_obj.location_code
        from at_physical_location pl,
             at_base_location bl,
             cwms_office o
       where upper(o.office_id) = upper(self.office_id)
         and bl.db_office_code = o.office_code
         and upper(bl.base_location_id) = upper(l_parts(1))
         and pl.base_location_code = bl.base_location_code
         and upper(nvl(pl.sub_location_id, '@')) = upper(nvl(l_sub_id, '@'));

      l_parts := cwms_util.split_text(parameter_id, '-', 1);
      l_sub_id := case l_parts.count
                     when 1 then null
                     else l_parts(2)
                  end;
      select p.parameter_code
        into l_obj.parameter_code
        from at_parameter p,
             cwms_base_parameter bp
       where upper(bp.base_parameter_id) = upper(l_parts(1))
         and p.base_parameter_code = bp.base_parameter_code
         and upper(nvl(p.sub_parameter_id, '@')) = upper(nvl(l_sub_id, '@'))
         and p.db_office_code in (cwms_util.get_db_office_code(self.office_id), cwms_util.db_office_code_all);

      l_id := parameter_type_id;
      select parameter_type_code
        into l_obj.parameter_type_code
        from cwms_parameter_type
       where upper(parameter_type_id) = upper(l_id);

      l_id := duration_id;
      select duration_code
        into l_obj.duration_code
        from cwms_duration
       where upper(duration_id) = upper(l_id);

      l_id := specified_level_id;
      select specified_level_code
        into l_obj.specified_level_code
        from at_specified_level
       where upper(specified_level_id) = upper(l_id);

      if attr_value is not null then
         l_parts := cwms_util.split_text(attr_parameter_id, '-', 1);
         l_sub_id := case l_parts.count
                        when 1 then null
                        else l_parts(2)
                     end;
         select p.parameter_code
           into l_obj.attr_parameter_code
           from at_parameter p,
                cwms_base_parameter bp
          where upper(bp.base_parameter_id) = upper(l_parts(1))
            and p.base_parameter_code = bp.base_parameter_code
            and upper(nvl(p.sub_parameter_id, '@')) = upper(nvl(l_sub_id, '@'));
         select parameter_type_code
           into l_obj.attr_parameter_type_code
           from cwms_parameter_type
          where upper(parameter_type_id) = upper(attr_parameter_type_id);

         select duration_code
           into l_obj.attr_duration_code
           from cwms_duration
          where upper(duration_id) = upper(attr_duration_id);

         select factor,
                offset
           into l_factor,
                l_offset
           from cwms_unit_conversion
          where from_unit_id = attr_units_id
            and to_unit_id = cwms_util.get_default_units(attr_parameter_id);
      end if;

      if ref_specified_level_id is not null then
         select sl.specified_level_code
           into l_obj.ref_specified_level_code
           from at_specified_level sl
          where upper(sl.specified_level_id) = upper(ref_specified_level_id)
            and sl.office_code in (
                select office_code
                  from cwms_office
                 where office_id in (self.office_id, 'CWMS'));
      end if;

      l_obj.level_indicator_id := level_indicator_id;
      l_obj.attr_value         := attr_value * l_factor + l_offset;
      l_obj.ref_attr_value     := ref_attr_value * l_factor + l_offset;
      l_obj.minimum_duration   := minimum_duration;
      l_obj.maximum_age        := maximum_age;
      l_obj.conditions         := conditions;

      return l_obj;
   end zloc_lvl_indicator;

   member procedure store
   is
      l_obj zloc_lvl_indicator_t := zloc_lvl_indicator;
   begin
      l_obj.store;
   end store;

   member function get_indicator_values(
      p_ts        in ztsv_array,
      p_eval_time in date default null)
      return number_tab_t
   is
      l_eval_time            date := nvl(p_eval_time, cast(systimestamp at time zone 'UTC' as date));
      l_max_age              number;
      l_min_dur              number;
      l_indicator_values     number_tab_t := number_tab_t();
      l_rate_of_change       boolean := false;
      l_is_set               boolean;
      l_set                  boolean;
      l_last                 pls_integer;
      l_level_values_1       ztsv_array;
      l_level_values_2       ztsv_array;
      l_level_values_array_1 double_tab_t := double_tab_t();
      l_level_values_array_2 double_tab_t := double_tab_t();
      l_rate_values_array    double_tab_t := double_tab_t();
      i                      binary_integer;
      j                      binary_integer;
      function is_valid(
         p_quality_code in number)
         return boolean
      is
         -- l_validity_id varchar2(16);
      begin
         /*
         select validity_id
           into l_validity_id
           from cwms_data_quality
          where quality_code = p_quality_code;
         return l_validity_id not in ('MISSING', 'REJECTED');
         */
         return bitand(p_quality_code, 20) = 0; -- 30 x faster!
      end is_valid;
   begin
      --------------------------------------
      -- create day values from durations --
      --------------------------------------
      l_max_age := extract(day    from maximum_age) +
                  (extract(hour   from maximum_age) / 24) +
                  (extract(minute from maximum_age) / 1440) +
                  (extract(second from maximum_age) / 86400);
      l_min_dur := extract(day    from minimum_duration) +
                  (extract(hour   from minimum_duration) / 24) +
                  (extract(minute from minimum_duration) / 1440) +
                  (extract(second from minimum_duration) / 86400);
      -------------------------------------
      -- determine whether we need rates --
      -------------------------------------
      for i in 1..conditions.count loop
         if not l_rate_of_change and conditions(i).rate_expression is not null then
            l_rate_of_change := true;
         end if;
         exit when l_rate_of_change;
      end loop;
      ----------------------------------------------------------------
      -- find the last valid value on or before the evaluation time --
      ----------------------------------------------------------------
      if p_ts is null or p_ts.count = 0 then
         return l_indicator_values;
      end if;
      for i in reverse 1..p_ts.count loop
         l_last := i;
         continue when p_ts(l_last).date_time > l_eval_time;
         exit when bitand(p_ts(l_last).quality_code, 20) = 0; --is_valid(p_ts(l_last).quality_code);
      end loop;
      -------------------------------------------------------
      -- only evaluate if last valid time is recent enough --
      -------------------------------------------------------
      if l_eval_time - p_ts(l_last).date_time <= l_max_age then
         l_rate_values_array.extend(l_last);
         if l_rate_of_change then
            -------------------------------------------------------
            -- compute the hourly rates of change if using rates --
            -------------------------------------------------------
            for i in reverse 2..l_last loop
               continue when bitand(p_ts(i).quality_code, 20) != 0; --not is_valid(p_ts(i).quality_code);
               for j in reverse 1..i-1 loop
                  get_indicator_values.j := j;
                  exit when bitand(p_ts(j).quality_code, 20) = 0; --is_valid(p_ts(j).quality_code);
               end loop;
               l_rate_values_array(i) :=
                  (p_ts(i).value - p_ts(j).value) /
                  ((p_ts(i).date_time - p_ts(j).date_time) * 24);
               -- cwms_msg.log_db_message('z', 7, ''||i||', '||j||': '||l_rate_values_array(i));
            end loop;
         end if;
         --------------------------------------------------
         -- retrieve the level values to compare against --
         --------------------------------------------------
         l_level_values_1 := cwms_level.retrieve_location_level_values(
            cwms_level.get_location_level_id(
               location_id,
               parameter_id,
               parameter_type_id,
               duration_id,
               specified_level_id),
            cwms_util.get_default_units(parameter_id),
            p_ts(1).date_time,
            p_ts(l_last).date_time,
            cwms_level.get_attribute_id(
               attr_parameter_id,
               attr_parameter_type_id,
               attr_duration_id),
            attr_value,
            attr_units_id,
            'UTC',
            office_id);
         if ref_specified_level_id is not null then
            l_level_values_2 := cwms_level.retrieve_location_level_values(
               cwms_level.get_location_level_id(
                  location_id,
                  parameter_id,
                  parameter_type_id,
                  duration_id,
                  ref_specified_level_id),
               cwms_util.get_default_units(parameter_id),
               p_ts(1).date_time,
               p_ts(l_last).date_time,
               cwms_level.get_attribute_id(
                  attr_parameter_id,
                  attr_parameter_type_id,
                  attr_duration_id),
               ref_attr_value,
               attr_units_id,
               'UTC',
               office_id);
         end if;
         ----------------------------------
         -- build tables of level values --
         ----------------------------------
         l_level_values_array_1.extend(l_last);
         l_level_values_array_2.extend(l_last);
         j := l_level_values_1.count;
         for i in reverse 1..l_last loop
            while l_level_values_1(j).date_time > p_ts(i).date_time loop
               exit when j = 1;
               j := j - 1;
            end loop;
            l_level_values_array_1(i) := l_level_values_1(j).value;
         end loop;
         if ref_specified_level_id is not null then
            j := l_level_values_2.count;
            for i in reverse 1..l_last loop
               while l_level_values_2(j).date_time > p_ts(i).date_time loop
                  exit when j = 1;
                  j := j - 1;
               end loop;
               l_level_values_array_2(i) := l_level_values_2(j).value;
            end loop;
         end if;
         -----------------------------
         -- evaluate each condition --
         -----------------------------
         for i in 1..conditions.count loop
            l_set := false;
            for j in reverse 1..l_last loop
               continue when bitand(p_ts(j).quality_code, 20) != 0; --not is_valid(p_ts(j).quality_code);
               exit when not conditions(i).is_set(
                  p_ts(j).value,
                  l_level_values_array_1(j),
                  l_level_values_array_2(j),
                  l_rate_values_array(j));
               if (p_ts(l_last).date_time - p_ts(j).date_time) >= l_min_dur then
                  l_set := true;
                  exit;
               end if;
            end loop;
            if l_set then
               l_indicator_values.extend;
               l_indicator_values(l_indicator_values.count) := conditions(i).indicator_value;
            end if;
         end loop;
      end if;
      return l_indicator_values;
   end get_indicator_values;

   member function get_max_indicator_value(
      p_ts        in ztsv_array,
      p_eval_time in date default null)
      return number
   is
      l_indicator_values number_tab_t;
   begin
      l_indicator_values := get_indicator_values(p_ts, p_eval_time);
      return case l_indicator_values.count > 0
                when true then  l_indicator_values(l_indicator_values.count)
                when false then 0
             end;
   end get_max_indicator_value;

   member function get_max_indicator_values(
      p_ts         in ztsv_array,
      p_start_time in date)
      return ztsv_array
   is
      l_results ztsv_array := new ztsv_array();
   begin
      for i in 1..p_ts.count loop
         continue when p_ts(i).date_time < p_start_time;
         l_results.extend;
         l_results(l_results.count) := new ztsv_type(
            p_ts(i).date_time,
            get_max_indicator_value(p_ts, p_ts(i).date_time),
            0);
      end loop;
      return l_results;
   end get_max_indicator_values;

end;
 
  GRANT EXECUTE ON "CWMS_20"."LOC_LVL_INDICATOR_T" TO "CWMS_USER"
 