------------------------------------------
-- RUN THIS SCRIPT AS CWMS_20 OR SYSDBA --
------------------------------------------
set define on
define cwms_schema = CWMS_20
set verify off
whenever sqlerror exit sql.sqlcode
alter session set current_schema = &cwms_schema;

spool updateCwmsSchema30.log; 
----------------------------------------------------------
-- verify that the schema is the version that we expect --
----------------------------------------------------------
begin
   for rec in 
      (select version,
              to_char(version_date, 'DDMONYYYY') as version_date
         from av_db_change_log
        where version_date = (select max(version_date) from av_db_change_log)
      )
   loop
      if rec.version != '3.0.2' or rec.version_date != '21OCT2015' then
      	cwms_err.raise('ERROR', 'Expected version 3.0.2 (21OCT2015), got version '||rec.version||' ('||rec.version_date||')');
      end if;
   end loop;
end;
/
prompt update for package spec cwms_env
create or replace package cwms_env
AS
/**
 * Routines that manage the cwms environmen variables.
 *
 * @author Various
 *
 * @since CWMS 2.2
 */


   PROCEDURE set_session_office_id (p_office_id IN VARCHAR2);
   PROCEDURE set_session_privileges;
   PROCEDURE clear_session_privileges;
END cwms_env;
/

SHOW error;

prompt update for package body cwms_env
create or replace package BODY cwms_env
AS

  PROCEDURE set_cwms_env (p_attribute IN VARCHAR2,p_value IN VARCHAR2)
  IS
   l_namespace   VARCHAR2 (30) := 'CWMS_ENV';
   l_attribute   VARCHAR2 (30) := NULL;
   l_value       VARCHAR2 (4000) := NULL;
  BEGIN
   l_attribute := p_attribute;
   l_value := p_value;

   DBMS_SESSION.set_context (l_namespace, l_attribute, l_value);

   END set_cwms_env;


   PROCEDURE set_session_office_id (p_office_id IN VARCHAR2)
   IS
      l_attribute   VARCHAR2 (30) := 'SESSION_OFFICE_ID';
      l_office_id   VARCHAR2 (16);
      --
      l_cnt         NUMBER;
      l_username    VARCHAR2 (31);
   BEGIN
      BEGIN
         l_office_id := CWMS_UTIL.GET_DB_OFFICE_ID (p_office_id);
      EXCEPTION
         WHEN OTHERS
         THEN
            cwms_err.raise (
               'ERROR',
                  'Unable to set a default SESSION_OFFICE_ID. The user: '
               || l_username
               || ' either has no assigned CWMS database privileges or has privileges to more than one office. Please see your CWMS Application Admin.');
      END;

      --
      -- Check if l_office_id is a valid office_id for this user, i.e.,
      -- does this user have any privileges assigned for the requested
      -- l_office_id.
      --
      SELECT COUNT (*)
        INTO l_cnt
        FROM TABLE (cwms_sec.get_assigned_priv_groups_tab)
       WHERE db_office_id = l_office_id;

      IF l_cnt > 0
      THEN
         SET_CWMS_ENV (l_attribute, l_office_id);
         SET_SESSION_PRIVILEGES; 
      ELSE
         l_username := cwms_util.get_user_id;
         cwms_err.raise (
            'ERROR',
               'Unable to set SESSION_OFFICE_ID to: '
            || l_office_id
            || ' because user: '
            || l_username
            || ' does not have any assigned privileges for that office.');
      END IF;
   END set_session_office_id;

   PROCEDURE clear_session_privileges
   IS
   BEGIN
    set_cwms_env ('CWMS_PRIVILEGE', 'READ_ONLY');
   END;

   PROCEDURE set_session_privileges
   IS
      l_office_id   VARCHAR2 (16);
      l_username    VARCHAR2 (32);
      l_canwrite    BOOLEAN;
      l_cnt         NUMBER;
   BEGIN
      l_canwrite := FALSE;
      l_cnt := 0;
      l_username := CWMS_UTIL.GET_USER_ID;
      set_cwms_env ('CWMS_PRIVILEGE', 'READ_ONLY'); 


      SELECT SYS_CONTEXT ('CWMS_ENV', 'SESSION_OFFICE_ID')
        INTO l_office_id
        FROM DUAL;

      IF l_office_id IS NULL
      THEN
         BEGIN
            SELECT a.office_id
              INTO l_office_id
              FROM cwms_office a, at_sec_user_office b
             WHERE     b.username = l_username
                   AND a.office_code = b.db_office_code;
         EXCEPTION
            WHEN OTHERS
            THEN
               NULL;
         END;
      END IF;

      SELECT COUNT (*)
        INTO l_cnt
        FROM TABLE (cwms_sec.get_assigned_priv_groups_tab)
       WHERE     db_office_id = l_office_id
             AND user_group_id IN ('CCP Mgr',
                                   'CCP Proc',
                                   'CWMS DBA Users',
                                   'CWMS PD Users',
                                   'CWMS User Admins',
                                   'Data Acquisition Mgr',
                                   'Data Exchange Mgr',
                                   'TS ID Creator',
                                   'VT Mgr');

      IF(l_cnt > 0)
      THEN
         l_canwrite := TRUE;
      END IF;

      IF (l_canwrite)
      THEN
         set_cwms_env ('CWMS_PRIVILEGE', 'CAN_WRITE');
      END IF;
   END set_session_privileges;
END cwms_env;
/

prompt update for package spec cwms_ts
/* Formatted on 12/29/2011 6:47:33 AM (QP5 v5.185.11230.41888) */
SET DEFINE OFF;

create or replace package cwms_ts
/**
 * Facilities for working with time series
 *
 * @author Various
 *
 * @since CWMS 2.0
 */
AS
   /**
    * Number of minutes in an hour.
    */
   min_in_hr CONSTANT NUMBER := 60;
   /**
    * Number of minutes in a day.
    */
   min_in_dy CONSTANT NUMBER := 1440;
   /**
    * Number of minutes in a week.
    */
   min_in_wk CONSTANT NUMBER := 10080;
   /**
    * Number of minutes in a month (30 days).
    */
   min_in_mo CONSTANT NUMBER := 43200;
   /**
    * Number of minutes in a year (365 days).
    */
   min_in_yr CONSTANT NUMBER := 525600;
   /**
    * Number of minutes in a decade (10 365-day years).
    */
   min_in_dc CONSTANT NUMBER := 5256000;
                                                  
   /**
    * Behavior for STORE_TS when storing data to remove nulls from the data that don't have quality code that indicates missing.
    */
   filter_out_null_values     constant number := 1; 
   /**
    * Behavior for STORE_TS when storing data to set all quality codes to missing for null values.
    */
   set_null_values_to_missing constant number := 2;
   /**
    * Behavior for STORE_TS when storing data to reject storing any data set that contains null values and non-missing quality.
    */
   reject_ts_with_null_values constant number := 3;                                      
   
   /**
    * Type for holding a time series value.
    *
    * @see type ztsv_type
    *
    * @member date_time    Same as for type ztsv_type
    * @member value        Same as for type ztsv_type
    * @member quality_code Same as for type ztsv_type
    */
   TYPE zts_rec_t IS RECORD
   (
      date_time      DATE,
      VALUE          BINARY_DOUBLE,
      quality_code   NUMBER
   );

   /**
    * Type for holding time series values.
    *
    * @see type ztsv_array
    */
   TYPE zts_tab_t IS TABLE OF zts_rec_t;

   /**
    * Type for passing collections of values from cx_Oracle scripts and possibly others
    */
   TYPE number_array IS TABLE OF NUMBER
                           INDEX BY BINARY_INTEGER;

   /**
    * Type for passing collections of values from cx_Oracle scripts and possibly others
    */
   TYPE double_array IS TABLE OF BINARY_DOUBLE
                           INDEX BY BINARY_INTEGER;

   -- not documented
   FUNCTION get_max_open_cursors
      RETURN INTEGER;

   /**
    * Retrieves the unique numeric code value for a time series
    *
    * @see view av_cwms_ts_id
    *
    * @param p_cwms_ts_id     The time series identifier
    * @param p_db_office_code The unique numeric code identifying the office owning the time series
    *
    * @return  the unique numeric code value for the specified time series
    */
   FUNCTION get_ts_code (p_cwms_ts_id       IN VARCHAR2,
                         p_db_office_code   IN NUMBER)
      RETURN NUMBER;

   /**
    * Retrieves the unique numeric code value for a time series
    *
    * @see view av_cwms_ts_id
    *
    * @param p_cwms_ts_id   The time series identifier
    * @param p_db_office_id The office owning the time series
    *
    * @return  the unique numeric code value for the specified time series
    */
   FUNCTION get_ts_code (p_cwms_ts_id     IN VARCHAR2,
                         p_db_office_id   IN VARCHAR2)
      RETURN NUMBER;

   /**
    * Retrieves the time series identifier from its unique numeric code
    *
    * @param p_ts_code The unique numeric code identifying the time series
    *
    * @return The time series identifier
    */
   FUNCTION get_ts_id (p_ts_code IN NUMBER)
      RETURN VARCHAR2;

   /**
    * Returns a case-corrected version of the specified time series identifier
    *
    * @param p_cwms_ts_id The case-insensitive version of the time series identifier
    * @param p_office_id  The office that owns the time series
    *
    * @return The case-corrected version of the time series identifier
    */
   FUNCTION get_cwms_ts_id (p_cwms_ts_id   IN VARCHAR2,
                            p_office_id    IN VARCHAR2)
      RETURN VARCHAR2;

   /**
    * Retreieves the database storage unit identifier for a time series
    *
    * @param p_cwms_ts_id The time series identifier
    *
    * @return The database storage unit for the time series
    */
   FUNCTION get_db_unit_id (p_cwms_ts_id IN VARCHAR2)
      RETURN VARCHAR2;

   /**
    * Retrieve the beginning time of the next interval a specified time, interval, and offset
    *
    * @param p_datetime    The UTC time to retrieve the start of the next interval for
    * @param p_ts_offset   The data offset into the UTC interval, in minutes
    * @param p_ts_interval The data interval length in minutes
    *
    * @return The beginning time of the next interval
    */
   FUNCTION get_time_on_after_interval (p_datetime      IN DATE,
                                        p_ts_offset     IN NUMBER,
                                        p_ts_interval   IN NUMBER)
      RETURN DATE;

   /**
    * Retrieve the beginning time of the current interval a specified time, interval, and offset
    *
    * @param p_datetime    The UTC time to retrieve the start of the next interval for
    * @param p_ts_offset   The data offset into the UTC interval, in minutes
    * @param p_ts_interval The data interval length in minutes
    *
    * @return The beginning time of the current interval
    */
   FUNCTION get_time_on_before_interval (p_datetime      IN DATE,
                                         p_ts_offset     IN NUMBER,
                                         p_ts_interval   IN NUMBER)
      RETURN DATE;

   /**
    * Retrieves the unique numeric code identifying a specified parameter
    *
    * @param p_base_parameter_id The base parameter identifier of the parameter
    * @param p_sub_parameter_id  The sub-parameter identifier, if any, for the parameter
    * @param p_office_id         The office owning the parameter
    * @param p_create            A flag ('T' or 'F') specifying whether to create the
    *                            parameter if it doesn't already exist.
    *
    * @return The unique numeric code identifying the parameter
    */
   FUNCTION get_parameter_code (
      p_base_parameter_id   IN VARCHAR2,
      p_sub_parameter_id    IN VARCHAR2,
      p_office_id           IN VARCHAR2 DEFAULT NULL,
      p_create              IN VARCHAR2 DEFAULT 'T')
      RETURN NUMBER;

   -- not documented
   FUNCTION get_display_parameter_code (
      p_base_parameter_id   IN VARCHAR2,
      p_sub_parameter_id    IN VARCHAR2,
      p_office_id           IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER;

   -- not documented
   FUNCTION get_display_parameter_code2 (
      p_base_parameter_id   IN VARCHAR2,
      p_sub_parameter_id    IN VARCHAR2,
      p_office_id           IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER;

   /**
    * Retrieves the unique numeric code identifying a specified parameter
    *
    * @param p_base_parameter_id The base parameter identifier of the parameter
    * @param p_sub_parameter_id  The sub-parameter identifier, if any, for the parameter
    * @param p_office_id         The unique numeric code identifying the office owning the parameter
    * @param p_create            Specifies whether to create the parameter if it doesn't already exist.
    *
    * @return The unique numeric code identifying the parameter
    */
   FUNCTION get_parameter_code (
      p_base_parameter_code   IN NUMBER,
      p_sub_parameter_id      IN VARCHAR2,
      p_office_code           IN NUMBER,
      p_create                IN BOOLEAN DEFAULT TRUE)
      RETURN NUMBER;

   /**
    * Retrieve the unique numeric code specifying the parameter for a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The unique numeric code specifying the parameter for the time series
    */
   FUNCTION get_parameter_code (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER;

   /**
    * Retrieve the unique numeric code specifying the base parameter for a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The unique numeric code specifying the base parameter for the time series
    */
   FUNCTION get_base_parameter_code (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER;

   /**
    * Retrieve the unique numeric code specifying the parameter type for a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The unique numeric code specifying the parameter type for the time series
    */
   FUNCTION get_parameter_type_code (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER;

   /**
    * Retrieve the unique numeric code specifying the office owning a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The unique numeric code specifying the office that owns the time series
    */
   FUNCTION get_db_office_code (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER;

   /**
    * Retrieve the parameter for a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The parameter for the time series
    */
   FUNCTION get_parameter_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2;

   /**
    * Retrieve the base parameter for a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The base parameter for the time series
    */
   FUNCTION get_base_parameter_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2;

   /**
    * Retrieve the parameter type for a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The parameter type for the time series
    */
   FUNCTION get_parameter_type_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2;

   /**
    * Retrieve the office that owns a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The office that owns the time series
    */
   FUNCTION get_db_office_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2;

   --   FUNCTION get_ts_ni_hash (
   --  p_parameter_code   IN NUMBER,
   --  p_parameter_type_code IN NUMBER,
   --  p_duration_code   IN NUMBER
   --   )
   --  RETURN VARCHAR2;

   --   FUNCTION create_ts_ni_hash (
   --  p_parameter_id IN  VARCHAR2,
   --  p_parameter_type_id IN  VARCHAR2,
   --  p_duration_id  IN VARCHAR2,
   --  p_db_office_id IN  VARCHAR2 DEFAULT NULL
   --   )
   --  RETURN VARCHAR2;
   /**
    * Retrieve the location for a time series
    *
    * @param p_cwms_ts_id   The time series identifier
    * @param p_db_office_id The office that owns the time series
    *
    * @return The location for the time series
    */
   FUNCTION get_location_id (p_cwms_ts_id     IN VARCHAR2,
                             p_db_office_id   IN VARCHAR2)
      RETURN VARCHAR2;

   /**
    * Retrieve the location for a time series
    *
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    *
    * @return The location for the time series
    */
   FUNCTION get_location_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2;

   /**
    * Deletes a time series from the database
    *
    * @see constant cwms_util.delete_key
    * @see constant cwms_util.delete_data
    * @see constant cwms_util.delete_all
    * @see constant cwms_util.delete_ts_id
    * @see constant cwms_util.delete_ts_data
    * @see constant cwms_util.delete_ts_cascade
    *
    * @param p_cwms_ts_id     The identifier of the time series to delete
    * @param p_delete_action Specifies what to delete.  Actions are as follows:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">p_delete_action</th>
    *     <th class="descr">Action</th>
    *   </tr>
    *   <tr>
    *     <td class="descr">cwms_util.delete_ts_id<br>cwms_util.delete_key</td>
    *     <td class="descr">deletes only the time series identifier, and then only if it has no time series values</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">cwms_util.delete_ts_data<br>cwms_util.delete_data</td>
    *     <td class="descr">deletes only the time series values, if any</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">delete_ts_cascade<br>cwms_util.delete_all</td>
    *     <td class="descr">deletes the time series identifier and any time series values</td>
    *   </tr>
    * </table>
    * @param p_db_office_id   The office that owns the time series.  If not specified or NULL, the session user's default office will be used.
    */
   PROCEDURE delete_ts (
      p_cwms_ts_id      IN VARCHAR2,
      p_delete_action   IN VARCHAR2 DEFAULT cwms_util.delete_ts_id,
      p_db_office_id    IN VARCHAR2 DEFAULT NULL);

   /**
    * Deletes a time series from the database
    *
    * @see constant cwms_util.delete_key
    * @see constant cwms_util.delete_data
    * @see constant cwms_util.delete_all
    * @see constant cwms_util.delete_ts_id
    * @see constant cwms_util.delete_ts_data
    * @see constant cwms_util.delete_ts_cascade
    *
    * @param p_cwms_ts_id     The identifier of the time series to delete
    * @param p_delete_action Specifies what to delete.  Actions are as follows:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">p_delete_action</th>
    *     <th class="descr">Action</th>
    *   </tr>
    *   <tr>
    *     <td class="descr">cwms_util.delete_ts_id<br>cwms_util.delete_key</td>
    *     <td class="descr">deletes only the time series identifier, and then only if it has no time series values</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">cwms_util.delete_ts_data<br>cwms_util.delete_data</td>
    *     <td class="descr">deletes only the time series values, if any</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">delete_ts_cascade<br>cwms_util.delete_all</td>
    *     <td class="descr">deletes the time series identifier and any time series values</td>
    *   </tr>
    * </table>
    * @param p_db_office_code The unique numeric code that identifies the office that owns the time series
    */
   PROCEDURE delete_ts (p_cwms_ts_id       IN VARCHAR2,
                        p_delete_action    IN VARCHAR2,
                        p_db_office_code   IN NUMBER);

   /**
    * Deletes time series values for a specified time series, version date, and time window or specified times
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.all_version_dates
    * @see constant cwms_util.ts_values
    * @see constant cwms_util.ts_std_text
    * @see constant cwms_util.ts_text
    * @see constant cwms_util.ts_all_text
    * @see constant cwms_util.ts_binary
    * @see constant cwms_util.ts_all_non_values
    * @see constant cwms_util.ts_all
    *
    * @param p_cwms_ts_id            The identifier of the time series to delete
    * @param p_override_protection   A flag ('T'/'F') specifying whether to delete protected data, may also be set to 'E' (or 'ERROR', or anything in between) to raise an exception if protected values are encountered.
    * @param p_start_time            The start of the time window in the specified or default time zone
    * @param p_end_time              The end of the time window in the specified or default time zone
    * @param p_start_time_inclusive  A flag ('T'/'F') specifying whether any data at the start time should be deleted ('T') or only data <b><em>after</em></b> the start time ('F')
    * @param p_end_time_inclusive    A flag ('T'/'F') specifying whether any data at the end time should be deleted ('T') or only data <b><em>before</em></b> the end time ('F')
    * @param p_version_date          The version date/time of the time series in the specified or default time zone. If NULL, the earliest or latest version date will be used depending on p_max_version.
    * @param p_time_zone             The time zone of any/all specified times. If not specified or NULL, the local time zone of the time series location is used.
    * @param p_date_times            A table of specific times to use, instead of a time window, in the specified or default time zone.
    * @param p_max_version           A flag ('T'/'F') specifying whether to use the earliest ('F') or latest ('T') version date for each time if p_version_date is NULL.
    * @param p_ts_item_mask          A cookie specifying what time series items to purge.
    * @param p_db_office_id          The office that owns the time series.  If not specified or NULL, the session user's default office will be used.
    */
   PROCEDURE delete_ts (
      p_cwms_ts_id           in varchar2,
      p_override_protection  in varchar2,
      p_start_time           in date,
      p_end_time             in date,                        
      p_start_time_inclusive in varchar2,
      p_end_time_inclusive   in varchar2,
      p_version_date         in date,
      p_time_zone            in varchar2 default null,
      p_date_times           in date_table_type default null,
      p_max_version          in varchar2 default 'T',
      p_ts_item_mask         in integer default cwms_util.ts_all,
      p_db_office_id         in varchar2 default null);

   /**
    * Deletes time series values for specified time series, version date, and time windows
    *                    
    * @see type timeseries_req_array
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.all_version_dates
    * @see constant cwms_util.ts_values
    * @see constant cwms_util.ts_std_text
    * @see constant cwms_util.ts_text
    * @see constant cwms_util.ts_all_text
    * @see constant cwms_util.ts_binary
    * @see constant cwms_util.ts_all_non_values
    * @see constant cwms_util.ts_all
    *
    * @param p_timeseries_info       Identifies the combinations of time series and time windows to delete data for.  The unit member of each element is ignored.
    * @param p_override_protection   A flag ('T'/'F') specifying whether to delete protected data, may also be set to 'E' (or 'ERROR', or anything in between) to raise an exception if protected values are encountered.
    * @param p_start_time_inclusive  A flag ('T'/'F') specifying whether any data at the start time should be deleted ('T') or only data <b><em>after</em></b> the start time ('F')
    * @param p_end_time_inclusive    A flag ('T'/'F') specifying whether any data at the end time should be deleted ('T') or only data <b><em>before</em></b> the end time ('F')
    * @param p_version_date          The version date/time of the time series in the specified or default time zone. If NULL, the earliest or latest version date will be used depending on p_max_version.
    * @param p_time_zone             The time zone of any/all specified times. If not specified or NULL, the local time zone of the time series location is used.
    * @param p_max_version           A flag ('T'/'F') specifying whether to use the earliest ('F') or latest ('T') version date for each time if p_version_date is NULL.
    * @param p_ts_item_mask          A cookie specifying what time series items to purge.
    * @param p_db_office_id          The office that owns the time series.  If not specified or NULL, the session user's default office will be used.
    */
   PROCEDURE delete_ts (
      p_timeseries_info      in timeseries_req_array,
      p_override_protection  in varchar2,
      p_start_time_inclusive in varchar2,
      p_end_time_inclusive   in varchar2,
      p_version_date         in date,
      p_time_zone            in varchar2 default null,
      p_max_version          in varchar2 default 'T',
      p_ts_item_mask         in integer default cwms_util.ts_all,
      p_db_office_id         in varchar2 default null);

   /**
    * Deletes time series values for a specified time series, version date, and time window or specified times. Raises an exception if protected values are encountered.
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.all_version_dates
    * @see constant cwms_util.ts_values
    * @see constant cwms_util.ts_std_text
    * @see constant cwms_util.ts_text
    * @see constant cwms_util.ts_all_text
    * @see constant cwms_util.ts_binary
    * @see constant cwms_util.ts_all_non_values
    * @see constant cwms_util.ts_all
    *
    * @param p_ts_code          The unique numeric code identifying the time series
    * @param p_version_date_utc The UTC version date/time of the time series. If NULL, the earliest or latest version date will be used depending on p_max_version.
    * @param p_start_time_utc   The UTC start of the time window
    * @param p_end_time_utc     The UTC end of the time window
    * @param p_date_times_utc   A table of specific times to use instead of a time window.
    * @param p_max_version      A flag ('T'/'F') specifying whether to use the earliest ('F') or latest ('T') version date for each time if p_version_date_utc is NULL.
    * @param p_ts_item_mask     A cookie specifying what time series items to purge.
    */
   PROCEDURE purge_ts_data (p_ts_code            IN NUMBER,
                            p_version_date_utc   IN DATE,
                            p_start_time_utc     IN DATE,
                            p_end_time_utc       IN DATE,
                            p_date_times_utc     IN date_table_type DEFAULT NULL,
                            p_max_version        IN VARCHAR2 DEFAULT 'T',
                            p_ts_item_mask       IN INTEGER DEFAULT cwms_util.ts_all);

   /**
    * Deletes time series values for a specified time series, version date, and time window or specified times
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.all_version_dates
    * @see constant cwms_util.ts_values
    * @see constant cwms_util.ts_std_text
    * @see constant cwms_util.ts_text
    * @see constant cwms_util.ts_all_text
    * @see constant cwms_util.ts_binary
    * @see constant cwms_util.ts_all_non_values
    * @see constant cwms_util.ts_all
    *
    * @param p_ts_code             The unique numeric code identifying the time series
    * @param p_override_protection A flag ('T'/'F') specifying whether to delete protected data, may also be set to 'E' (or 'ERROR', or anything in between) to raise an exception if protected values are encountered.
    * @param p_version_date_utc    The UTC version date/time of the time series. If NULL, the earliest or latest version date will be used depending on p_max_version.
    * @param p_start_time_utc      The UTC start of the time window
    * @param p_end_time_utc        The UTC end of the time window
    * @param p_date_times_utc      A table of specific times to use instead of a time window.
    * @param p_max_version         A flag ('T'/'F') specifying whether to use the earliest ('F') or latest ('T') version date for each time if p_version_date_utc is NULL.
    * @param p_ts_item_mask        A cookie specifying what time series items to purge.
    */
   PROCEDURE purge_ts_data (p_ts_code             IN NUMBER,
                            p_override_protection IN VARCHAR2,
                            p_version_date_utc    IN DATE,
                            p_start_time_utc      IN DATE,
                            p_end_time_utc        IN DATE,
                            p_date_times_utc      IN date_table_type DEFAULT NULL,
                            p_max_version         IN VARCHAR2 DEFAULT 'T',
                            p_ts_item_mask        IN INTEGER DEFAULT cwms_util.ts_all);

   /**
    * Changes the version date for a time series, version date, and time window
    *
    * @see constant cwms_util.non_versioned
    *
    * @param p_ts_code              The unique numeric code identifying the time series
    * @param p_old_version_date_utc The existing UTC version date/time of the time series
    * @param p_new_version_date_utc The new UTC version date/time of the time series
    * @param p_start_time_utc       The UTC start of the time window
    * @param p_end_time_utc         The UTC end of the time window
    * @param p_date_times_utc       A table of specific times to use instead of a time window.
    * @param p_ts_item_mask         A cookie specifying what time series items to purge.
    */
   PROCEDURE change_version_date (p_ts_code                IN NUMBER,
                                  p_old_version_date_utc   IN DATE,
                                  p_new_version_date_utc   IN DATE,
                                  p_start_time_utc         IN DATE,
                                  p_end_time_utc           IN DATE,
                                  p_date_times_utc         IN date_table_type DEFAULT NULL,
                                  p_ts_item_mask           IN INTEGER DEFAULT cwms_util.ts_all);

   -- not documented, for LRTS
   PROCEDURE set_ts_time_zone (p_ts_code          IN NUMBER,
                               p_time_zone_name   IN VARCHAR2);

   -- not documented, for LRTS
   PROCEDURE set_tsid_time_zone (p_ts_id            IN VARCHAR2,
                                 p_time_zone_name   IN VARCHAR2,
                                 p_office_id        IN VARCHAR2 DEFAULT NULL);

   -- not documented, for LRTS
   FUNCTION get_ts_time_zone (p_ts_code IN NUMBER)
      RETURN VARCHAR2;

   -- not documented, for LRTS
   FUNCTION get_tsid_time_zone (p_ts_id       IN VARCHAR2,
                                p_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2;

   /**
    * Sets a time series to versioned or non-versioned.  A time series can only
    * be set to non-versioned if it contains no versioned data.
    *
    * @param p_cwms_ts_code The unique numeric code that identifies the time series
    * @param p_versioned    A flag ('T' or 'F') that specifies if the time series is to be versioned.
    */
   PROCEDURE set_ts_versioned (p_cwms_ts_code   IN NUMBER,
                               p_versioned      IN VARCHAR2 DEFAULT 'T');

   /**
    * Sets a time series to versioned or non-versioned.  A time series can only
    * be set to non-versioned if it contains no versioned data.
    *
    * @param p_cwms_ts_id The time series identifier
    * @param p_office_id  The office that owns the time series. If not specified or NULL, the session user's default office is used.
    * @param p_versioned  A flag ('T' or 'F') that specifies if the time series is to be versioned.
    */
   PROCEDURE set_tsid_versioned (p_cwms_ts_id     IN VARCHAR2,
                                 p_versioned      IN VARCHAR2 DEFAULT 'T',
                                 p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves whether a time series is currently versioned
    *
    * @param p_is_versioned A flag ('T' or 'F') that specifies if the time series is to be versioned.
    * @param p_cwms_ts_code The unique numeric code that identifies the time series
    */
   PROCEDURE is_ts_versioned (p_is_versioned      OUT VARCHAR2,
                              p_cwms_ts_code   IN     NUMBER);

   /**
    * Retrieves whether a time series is currently versioned
    *
    * @param p_is_versioned A flag ('T' or 'F') that specifies if the time series is to be versioned.
    * @param p_cwms_ts_id   The time series identifier
    * @param p_office_id    The office that owns the time series. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE is_tsid_versioned (
      p_is_versioned      OUT VARCHAR2,
      p_cwms_ts_id     IN     VARCHAR2,
      p_db_office_id   IN     VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves whether a time series is currently versioned
    *
    * @param p_cwms_ts_id   The time series identifier
    * @param p_office_id    The office that owns the time series. If not specified or NULL, the session user's default office is used.
    *
    * @return A flag ('T' or 'F') that specifies if the time series is to be versioned.
    */
   FUNCTION is_tsid_versioned_f (p_cwms_ts_id     IN VARCHAR2,
                                 p_db_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2;

   /**
    * Returns all version dates for a specified time series and time window
    *
    * @param p_date_cat     A cursor containing the version dates. The cursor contains a single unnamed column of type VERSION_DATE, sorted in ascending order.
    *                       VERSION_DATE will be in the specified time zone, except that non-versioned date signature is preserved regardless of time zone.
    * @param p_cwms_ts_code The unique numeric code identifying the time series
    * @param p_start_time   The start of the time window
    * @param p_end_time     The end of the time window
    * @param p_time_zone    The time zone for the time window and the retrieved version dates. If not specified or NULL, UTC will be used.
    */
   PROCEDURE get_ts_version_dates (
      p_date_cat          OUT SYS_REFCURSOR,
      p_cwms_ts_code   IN     NUMBER,
      p_start_time     IN     DATE,
      p_end_time       IN     DATE,
      p_time_zone      IN     VARCHAR2 DEFAULT 'UTC');

   /**
    * Returns all version dates for a specified time series and time window
    *
    * @param p_date_cat     A cursor containing the version dates. The cursor contains a single unnamed column of type VERSION_DATE, sorted in ascending order.
    *                       VERSION_DATE will be in the specified time zone, except that non-versioned date signature is preserved regardless of time zone.
    * @param p_cwms_ts_id   The time series identifier
    * @param p_start_time   The start of the time window
    * @param p_end_time     The end of the time window
    * @param p_time_zone    The time zone for the time window and the retrieved version dates. If not specified or NULL, UTC will be used.
    * @param p_office_id    The office that owns the time series. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE get_tsid_version_dates (
      p_date_cat          OUT SYS_REFCURSOR,
      p_cwms_ts_id     IN     VARCHAR2,
      p_start_time     IN     DATE,
      p_end_time       IN     DATE,
      p_time_zone      IN     VARCHAR2 DEFAULT 'UTC',
      p_db_office_id   IN     VARCHAR2 DEFAULT NULL);

   /**
    * Creates a new time series
    *
    * @param p_office_id  The office that owns the time series
    * @param p_cwms_ts_id The time series identifier
    * @param p_utc_offset The UTC regular interval offset in minutes, if applicable and known
    */
   PROCEDURE create_ts (p_office_id    IN VARCHAR2,
                        p_cwms_ts_id   IN VARCHAR2,
                        p_utc_offset   IN NUMBER DEFAULT NULL);

   /**
    * Creates a new time series
    *
    * @param p_cwms_ts_id        The time series identifier
    * @param p_utc_offset        The UTC regular interval offset in minutes, if applicable and known. If not specified or NULL, the offset will be set by the first time series value stored.
    * @param p_interval_forward  The UTC regular interval forward tolerance in minutes, if applicable. If not specified or NULL, 0 minutes will be used. This specifies the number of minutes after the expected data time to treat data as being on the expected time.
    * @param p_interval_backward The UTC regular interval backward tolerance in minutes, if applicable If not specified or NULL, 0 minutes will be used. This specifies the number of minutes before the expected data time to treat data as being on the expected time.
    * @param p_versioned         A flag ('T' or 'F') specifying whether the time series is versioned
    * @param p_active_flag       A flag ('T' or 'F') specifying whether the time series is active
    * @param p_office_id         The office that owns the time series. If not specified or NULL, the session_user's default office_will be used
    */
   PROCEDURE create_ts (p_cwms_ts_id          IN VARCHAR2,
                        p_utc_offset          IN NUMBER DEFAULT NULL,
                        p_interval_forward    IN NUMBER DEFAULT NULL,
                        p_interval_backward   IN NUMBER DEFAULT NULL,
                        p_versioned           IN VARCHAR2 DEFAULT 'F',
                        p_active_flag         IN VARCHAR2 DEFAULT 'T',
                        p_office_id           IN VARCHAR2 DEFAULT NULL);

   -- not documented, for LRTS
   PROCEDURE create_ts_tz (p_cwms_ts_id          IN VARCHAR2,
                           p_utc_offset          IN NUMBER DEFAULT NULL,
                           p_interval_forward    IN NUMBER DEFAULT NULL,
                           p_interval_backward   IN NUMBER DEFAULT NULL,
                           p_versioned           IN VARCHAR2 DEFAULT 'F',
                           p_active_flag         IN VARCHAR2 DEFAULT 'T',
                           p_time_zone_name      IN VARCHAR2 DEFAULT 'UTC',
                           p_office_id           IN VARCHAR2 DEFAULT NULL);

   /**
    * Creates a new time series and returns its unique numeric code
    *
    * @param p_ts_code           The unique numeric code identifying the time series
    * @param p_cwms_ts_id        The time series identifier
    * @param p_utc_offset        The UTC regular interval offset in minutes, if applicable and known. If not specified or NULL, the offset will be set by the first time series value stored.
    * @param p_interval_forward  The UTC regular interval forward tolerance in minutes, if applicable. If not specified or NULL, 0 minutes will be used. This specifies the number of minutes after the expected data time to treat data as being on the expected time.
    * @param p_interval_backward The UTC regular interval backward tolerance in minutes, if applicable If not specified or NULL, 0 minutes will be used. This specifies the number of minutes before the expected data time to treat data as being on the expected time.
    * @param p_versioned         A flag ('T' or 'F') specifying whether the time series is versioned
    * @param p_active_flag       A flag ('T' or 'F') specifying whether the time series is active
    * @param p_fail_if_exists    A flag ('T' or 'F') specifying whether to fail if the time series already exists.  If 'F' and the time series exists, the existing numeric code is retreieved.
    * @param p_office_id         The office that owns the time series. If not specified or NULL, the session_user's default office_will be used
    */
   PROCEDURE create_ts_code (
      p_ts_code                OUT NUMBER,
      p_cwms_ts_id          IN     VARCHAR2,
      p_utc_offset          IN     NUMBER DEFAULT NULL,
      p_interval_forward    IN     NUMBER DEFAULT NULL,
      p_interval_backward   IN     NUMBER DEFAULT NULL,
      p_versioned           IN     VARCHAR2 DEFAULT 'F',
      p_active_flag         IN     VARCHAR2 DEFAULT 'T',
      p_fail_if_exists      IN     VARCHAR2 DEFAULT 'T',
      p_office_id           IN     VARCHAR2 DEFAULT NULL);

   -- not documented, for LRTS
   PROCEDURE create_ts_code_tz (
      p_ts_code                OUT NUMBER,
      p_cwms_ts_id          IN     VARCHAR2,
      p_utc_offset          IN     NUMBER DEFAULT NULL,
      p_interval_forward    IN     NUMBER DEFAULT NULL,
      p_interval_backward   IN     NUMBER DEFAULT NULL,
      p_versioned           IN     VARCHAR2 DEFAULT 'F',
      p_active_flag         IN     VARCHAR2 DEFAULT 'T',
      p_fail_if_exists      IN     VARCHAR2 DEFAULT 'T',
      p_time_zone_name      IN     VARCHAR2 DEFAULT 'UTC',
      p_office_id           IN     VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves time series data for a specified time series and time window
    *
    * @param p_at_tsv_rc       A cursor containing the time series data.  The cursor
    * contains the following columns, sorted by date_time:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The date/time of the value, in the specified time zone</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">value</td>
    *     <td class="descr">binary_double</td>
    *     <td class="descr">The data value</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">3</td>
    *     <td class="descr">quality_code</td>
    *     <td class="descr">number</td>
    *     <td class="descr">The quality code for the data value</td>
    *   </tr>
    * </table>
    * @param p_cwms_ts_id_out  The case-corrected version of the time series identifier
    * @param p_units_out       The unit of the retrieved data values
    * @param p_cwms_ts_id      The time series identifier to retrieve data for
    * @param p_units           The unit to retrieve the data values in
    * @param p_start_time      The start time of the time window
    * @param p_end_time        The end time of the time window
    * @param p_time_zone       The time zone for the time window and retrieved times. Either a standard (constant offset from UTC) or local (observes Daylight Savings)
    * time zone can be specified. For local time zones there are two behaviors that can be specified for retrieving data across a (Spring or Autum)
    * Daylight Savings boundary.
    * <ul><li>The <strong>default behavior</strong> is to retrieve the data normally and label it according to the local time zone, which will result in time discontinuities
    *         at the DST boundaries. The Spring discontinuity will result in a missing 0200 hour; the Autum discontinuity will result in a repeated
    *         0100 hour (with possibly different values).</li>
    *     <li>The <strong>alternate behavior</strong> - specified by pre-pending <strong><code>!</code></strong> to the time zone (e.g. <code>!US/Pacific</code>) - is to retrieve data that can be used
    *         as a valid time series. This results in the absence of time discontinuities in the dataset, but at the expense of inserting a manufactured
    *         0200 hour in the Spring (with null values and "missing" quality codes) for regular time series and not returing earliest 0100 hour (the
    *         one corresponding to Daylight Savings) in the Autum.</li></ul>
    * @param p_trim            A flag ('T' or 'F') that specifies whether to trim missing values from the beginning and end of the retrieved values
    * @param p_start_inclusive A flag ('T' or 'F') that specifies whether the time window begins on ('T') or after ('F') the start time
    * @param p_end_inclusive   A flag ('T' or 'F') that specifies whether the time window ends on ('T') or before ('F') the end time
    * @param p_previous        A flag ('T' or 'F') that specifies whether to retrieve the latest value before the start of the time window
    * @param p_next            A flag ('T' or 'F') that specifies whether to retrieve the earliest value after the end of the time window
    * @param p_version_date    The version date of the data to retrieve. If not specified or NULL, the version date is determined by p_max_version
    * @param p_max_version     A flag ('T' or 'F') that specifies whether to retrieve the maximum ('T') or minimum ('F') version date if p_version_date is NULL
    * @param p_office_id       The office that owns the time series
    */
   PROCEDURE retrieve_ts_out (
      p_at_tsv_rc            OUT SYS_REFCURSOR,
      p_cwms_ts_id_out       OUT VARCHAR2,
      p_units_out            OUT VARCHAR2,
      p_cwms_ts_id        IN     VARCHAR2,
      p_units             IN     VARCHAR2,
      p_start_time        IN     DATE,
      p_end_time          IN     DATE,
      p_time_zone         IN     VARCHAR2 DEFAULT 'UTC',
      p_trim              IN     VARCHAR2 DEFAULT 'F',
      p_start_inclusive   IN     VARCHAR2 DEFAULT 'T',
      p_end_inclusive     IN     VARCHAR2 DEFAULT 'T',
      p_previous          IN     VARCHAR2 DEFAULT 'F',
      p_next              IN     VARCHAR2 DEFAULT 'F',
      p_version_date      IN     DATE DEFAULT NULL,
      p_max_version       IN     VARCHAR2 DEFAULT 'T',
      p_office_id         IN     VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves a table of time series data for a specified time series and time window
    *
    * @param p_cwms_ts_id      The time series identifier to retrieve data for
    * @param p_units           The unit to retrieve the data values in
    * @param p_start_time      The start time of the time window
    * @param p_end_time        The end time of the time window
    * @param p_time_zone       The time zone for the time window and retrieved times. Either a standard (constant offset from UTC) or local (observes Daylight Savings)
    * time zone can be specified. For local time zones there are two behaviors that can be specified for retrieving data across a (Spring or Autum)
    * Daylight Savings boundary.
    * <ul><li>The <strong>default behavior</strong> is to retrieve the data normally and label it according to the local time zone, which will result in time discontinuities
    *         at the DST boundaries. The Spring discontinuity will result in a missing 0200 hour; the Autum discontinuity will result in a repeated
    *         0100 hour (with possibly different values).</li>
    *     <li>The <strong>alternate behavior</strong> - specified by pre-pending <strong><code>!</code></strong> to the time zone (e.g. <code>!US/Pacific</code>) - is to retrieve data that can be used
    *         as a valid time series. This results in the absence of time discontinuities in the dataset, but at the expense of inserting a manufactured
    *         0200 hour in the Spring (with null values and "missing" quality codes) for regular time series and not returing earliest 0100 hour (the
    *         one corresponding to Daylight Savings) in the Autum.</li></ul>
    * @param p_trim            A flag ('T' or 'F') that specifies whether to trim missing values from the beginning and end of the retrieved values
    * @param p_start_inclusive A flag ('T' or 'F') that specifies whether the time window begins on ('T') or after ('F') the start time
    * @param p_end_inclusive   A flag ('T' or 'F') that specifies whether the time window ends on ('T') or before ('F') the end time
    * @param p_previous        A flag ('T' or 'F') that specifies whether to retrieve the latest value before the start of the time window
    * @param p_next            A flag ('T' or 'F') that specifies whether to retrieve the earliest value after the end of the time window
    * @param p_version_date    The version date of the data to retrieve. If not specified or NULL, the version date is determined by p_max_version
    * @param p_max_version     A flag ('T' or 'F') that specifies whether to retrieve the maximum ('T') or minimum ('F') version date if p_version_date is NULL
    * @param p_office_id       The office that owns the time series
    *
    * @return  A collection of records containing the time series data. The records contains
    * the following columns, sorted by date_time:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The date/time of the value, in the specified time zone</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">value</td>
    *     <td class="descr">binary_double</td>
    *     <td class="descr">The data value</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">3</td>
    *     <td class="descr">quality_code</td>
    *     <td class="descr">number</td>
    *     <td class="descr">The quality code for the data value</td>
    *   </tr>
    * </table><p>
    * The record collection is suitable for casting to a table with the table() function.
    */
   FUNCTION retrieve_ts_out_tab (
      p_cwms_ts_id        IN VARCHAR2,
      p_units             IN VARCHAR2,
      p_start_time        IN DATE,
      p_end_time          IN DATE,
      p_time_zone         IN VARCHAR2 DEFAULT 'UTC',
      p_trim              IN VARCHAR2 DEFAULT 'F',
      p_start_inclusive   IN VARCHAR2 DEFAULT 'T',
      p_end_inclusive     IN VARCHAR2 DEFAULT 'T',
      p_previous          IN VARCHAR2 DEFAULT 'F',
      p_next              IN VARCHAR2 DEFAULT 'F',
      p_version_date      IN DATE DEFAULT NULL,
      p_max_version       IN VARCHAR2 DEFAULT 'T',
      p_office_id         IN VARCHAR2 DEFAULT NULL)
      RETURN zts_tab_t
      PIPELINED;

   /**
    * Retrieves time series data for a specified time series and time window
    *
    * @param p_at_tsv_rc       A cursor containing the time series data.  The cursor
    * contains the following columns, sorted by date_time:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">timestamp with time zone</td>
    *     <td class="descr">The date/time of the value</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">value</td>
    *     <td class="descr">binary_double</td>
    *     <td class="descr">The data value</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">3</td>
    *     <td class="descr">quality_code</td>
    *     <td class="descr">number</td>
    *     <td class="descr">The quality code for the data value</td>
    *   </tr>
    * </table>
    * @param p_units           The unit to retrieve the data values in
    * @param p_officeid        The office that owns the time series
    * @param p_cwms_ts_id      The time series identifier to retrieve data for
    * @param p_start_time      The start time of the time window
    * @param p_end_time        The end time of the time window
    * @param p_timezone        The time zone for the time window. Either a standard (constant offset from UTC) or local (observes Daylight Savings)
    * time zone can be specified. For local time zones there are two behaviors that can be specified for retrieving data across a (Spring or Autum)
    * Daylight Savings boundary.
    * <ul><li>The <strong>default behavior</strong> is to retrieve the data normally and label it according to the local time zone, which will result in time discontinuities
    *         at the DST boundaries. The Spring discontinuity will result in a missing 0200 hour; the Autum discontinuity will result in a repeated
    *         0100 hour (with possibly different values).</li>
    *     <li>The <strong>alternate behavior</strong> - specified by pre-pending <strong><code>!</code></strong> to the time zone (e.g. <code>!US/Pacific</code>) - is to retrieve data that can be used
    *         as a valid time series. This results in the absence of time discontinuities in the dataset, but at the expense of inserting a manufactured
    *         0200 hour in the Spring (with null values and "missing" quality codes) for regular time series and not returing earliest 0100 hour (the
    *         one corresponding to Daylight Savings) in the Autum.</li></ul>
    * @param p_trim            A flag ('T' or 'F') that specifies whether to trim missing values from the beginning and end of the retrieved values
    * @param p_inclusive       A flag ('T' or 'F') that specifies whether the start and end time are included in the time window
    * @param p_versiondate     The version date of the data to retrieve. If not specified or NULL, the version date is determined by p_max_version
    * @param p_max_version     A flag ('T' or 'F') that specifies whether to retrieve the maximum ('T') or minimum ('F') version date if p_versiondate is NULL
    */
   PROCEDURE retrieve_ts (
      p_at_tsv_rc     IN OUT SYS_REFCURSOR,
      p_units         IN     VARCHAR2,
      p_officeid      IN     VARCHAR2,
      p_cwms_ts_id    IN     VARCHAR2,
      p_start_time    IN     DATE,
      p_end_time      IN     DATE,
      p_timezone      IN     VARCHAR2 DEFAULT 'GMT',
      p_trim          IN     NUMBER DEFAULT cwms_util.false_num,
      p_inclusive     IN     NUMBER DEFAULT NULL,
      p_versiondate   IN     DATE DEFAULT NULL,
      p_max_version   IN     NUMBER DEFAULT cwms_util.true_num);

   -- not documented, same as retrieve_ts
   PROCEDURE retrieve_ts_2 (
      p_at_tsv_rc        OUT SYS_REFCURSOR,
      p_units         IN     VARCHAR2,
      p_officeid      IN     VARCHAR2,
      p_cwms_ts_id    IN     VARCHAR2,
      p_start_time    IN     DATE,
      p_end_time      IN     DATE,
      p_timezone      IN     VARCHAR2 DEFAULT 'GMT',
      p_trim          IN     NUMBER DEFAULT cwms_util.false_num,
      p_inclusive     IN     NUMBER DEFAULT NULL,
      p_versiondate   IN     DATE DEFAULT NULL,
      p_max_version   IN     NUMBER DEFAULT cwms_util.true_num);

   /**
    * Retrieves time series data for a specified time series and time window
    *
    * @param p_at_tsv_rc       A cursor containing the time series data.  The cursor
    * contains the following columns, sorted by date_time:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The date/time of the value, in the specified time zone</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">value</td>
    *     <td class="descr">binary_double</td>
    *     <td class="descr">The data value</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">3</td>
    *     <td class="descr">quality_code</td>
    *     <td class="descr">number</td>
    *     <td class="descr">The quality code for the data value</td>
    *   </tr>
    * </table>
    * @param p_cwms_ts_id      The time series identifier to retrieve data for
    * @param p_units           The unit to retrieve the data values in
    * @param p_start_time      The start time of the time window
    * @param p_end_time        The end time of the time window. Either a standard (constant offset from UTC) or local (observes Daylight Savings)
    * time zone can be specified. For local time zones there are two behaviors that can be specified for retrieving data across a (Spring or Autum)
    * Daylight Savings boundary.
    * <ul><li>The <strong>default behavior</strong> is to retrieve the data normally and label it according to the local time zone, which will result in time discontinuities
    *         at the DST boundaries. The Spring discontinuity will result in a missing 0200 hour; the Autum discontinuity will result in a repeated
    *         0100 hour (with possibly different values).</li>
    *     <li>The <strong>alternate behavior</strong> - specified by pre-pending <strong><code>!</code></strong> to the time zone (e.g. <code>!US/Pacific</code>) - is to retrieve data that can be used
    *         as a valid time series. This results in the absence of time discontinuities in the dataset, but at the expense of inserting a manufactured
    *         0200 hour in the Spring (with null values and "missing" quality codes) for regular time series and not returing earliest 0100 hour (the
    *         one corresponding to Daylight Savings) in the Autum.</li></ul>
    * @param p_time_zone       The time zone for the time window and retrieved times
    * @param p_trim            A flag ('T' or 'F') that specifies whether to trim missing values from the beginning and end of the retrieved values
    * @param p_start_inclusive A flag ('T' or 'F') that specifies whether the time window begins on ('T') or after ('F') the start time
    * @param p_end_inclusive   A flag ('T' or 'F') that specifies whether the time window ends on ('T') or before ('F') the end time
    * @param p_previous        A flag ('T' or 'F') that specifies whether to retrieve the latest value before the start of the time window
    * @param p_next            A flag ('T' or 'F') that specifies whether to retrieve the earliest value after the end of the time window
    * @param p_version_date    The version date of the data to retrieve. If not specified or NULL, the version date is determined by p_max_version
    * @param p_max_version     A flag ('T' or 'F') that specifies whether to retrieve the maximum ('T') or minimum ('F') version date if p_version_date is NULL
    * @param p_office_id       The office that owns the time series
    */
   PROCEDURE retrieve_ts (p_at_tsv_rc            OUT SYS_REFCURSOR,
                          p_cwms_ts_id        IN     VARCHAR2,
                          p_units             IN     VARCHAR2,
                          p_start_time        IN     DATE,
                          p_end_time          IN     DATE,
                          p_time_zone         IN     VARCHAR2 DEFAULT 'UTC',
                          p_trim              IN     VARCHAR2 DEFAULT 'F',
                          p_start_inclusive   IN     VARCHAR2 DEFAULT 'T',
                          p_end_inclusive     IN     VARCHAR2 DEFAULT 'T',
                          p_previous          IN     VARCHAR2 DEFAULT 'F',
                          p_next              IN     VARCHAR2 DEFAULT 'F',
                          p_version_date      IN     DATE DEFAULT NULL,
                          p_max_version       IN     VARCHAR2 DEFAULT 'T',
                          p_office_id         IN     VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves time series data for multiple time series
    *
    * @param p_at_tsv_rc       A cursor containing the time series data.  The cursor
    * contains the following columns, sorted by date_time:
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">sequence</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The position in p_timeseries_info that this record is associated with</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">tsid</td>
    *     <td class="descr">varchar2(183)</td>
    *     <td class="descr">The time series identifier for this record</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">3</td>
    *     <td class="descr">units</td>
    *     <td class="descr">varchar2(16)</td>
    *     <td class="descr">The data unit for this record</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">4</td>
    *     <td class="descr">start_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The start time of the time window for this record</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">5</td>
    *     <td class="descr">end_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The end time of the time window for this record</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">6</td>
    *     <td class="descr">time_zone</td>
    *     <td class="descr">varchar2(28)</td>
    *     <td class="descr">The time zone of the time window</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">7</td>
    *     <td class="descr">data</td>
    *     <td class="descr">cursor</td>
    *     <td class="descr">The time series data for this record
    *    <p>
    *    <table class="descr">
    *      <tr>
    *        <th class="descr">Column No.</th>
    *        <th class="descr">Column Name</th>
    *        <th class="descr">Data Type</th>
    *        <th class="descr">Contents</th>
    *      </tr>
    *      <tr>
    *        <td class="descr-center">1</td>
    *        <td class="descr">date_time</td>
    *        <td class="descr">timestamp with time zone</td>
    *        <td class="descr">The date/time of the value, in the specified time zone</td>
    *      </tr>
    *      <tr>
    *        <td class="descr-center">2</td>
    *        <td class="descr">value</td>
    *        <td class="descr">binary_double</td>
    *        <td class="descr">The data value</td>
    *      </tr>
    *      <tr>
    *        <td class="descr-center">3</td>
    *        <td class="descr">quality_code</td>
    *        <td class="descr">number</td>
    *        <td class="descr">The quality code for the data value</td>
    *      </tr>
    *    </table>
    *     </td>
    *   </tr>
    * </table>
    * @param p_timeseries_info The time series identifiers, time windows, and units to retrieve data for
    * @param p_time_zone       The time zone for the time windows and retrieved times. Either a standard (constant offset from UTC) or local (observes Daylight Savings)
    * time zone can be specified. For local time zones there are two behaviors that can be specified for retrieving data across a (Spring or Autum)
    * Daylight Savings boundary.
    * <ul><li>The <strong>default behavior</strong> is to retrieve the data normally and label it according to the local time zone, which will result in time discontinuities
    *         at the DST boundaries. The Spring discontinuity will result in a missing 0200 hour; the Autum discontinuity will result in a repeated
    *         0100 hour (with possibly different values).</li>
    *     <li>The <strong>alternate behavior</strong> - specified by pre-pending <strong><code>!</code></strong> to the time zone (e.g. <code>!US/Pacific</code>) - is to retrieve data that can be used
    *         as a valid time series. This results in the absence of time discontinuities in the dataset, but at the expense of inserting a manufactured
    *         0200 hour in the Spring (with null values and "missing" quality codes) for regular time series and not returing earliest 0100 hour (the
    *         one corresponding to Daylight Savings) in the Autum.</li></ul>
    * @param p_trim            A flag ('T' or 'F') that specifies whether to trim missing values from the beginning and end of the retrieved values
    * @param p_start_inclusive A flag ('T' or 'F') that specifies whether the time window begins on ('T') or after ('F') the start time
    * @param p_end_inclusive   A flag ('T' or 'F') that specifies whether the time window ends on ('T') or before ('F') the end time
    * @param p_previous        A flag ('T' or 'F') that specifies whether to retrieve the latest value before the start of the time window
    * @param p_next            A flag ('T' or 'F') that specifies whether to retrieve the earliest value after the end of the time window
    * @param p_version_date    The version date of the data to retrieve. If not specified or NULL, the version date is determined by p_max_version
    * @param p_max_version     A flag ('T' or 'F') that specifies whether to retrieve the maximum ('T') or minimum ('F') version date if p_version_date is NULL
    * @param p_office_id       The office that owns the time series
    */
   PROCEDURE retrieve_ts_multi (
      p_at_tsv_rc            OUT SYS_REFCURSOR,
      p_timeseries_info   IN     timeseries_req_array,
      p_time_zone         IN     VARCHAR2 DEFAULT 'UTC',
      p_trim              IN     VARCHAR2 DEFAULT 'F',
      p_start_inclusive   IN     VARCHAR2 DEFAULT 'T',
      p_end_inclusive     IN     VARCHAR2 DEFAULT 'T',
      p_previous          IN     VARCHAR2 DEFAULT 'F',
      p_next              IN     VARCHAR2 DEFAULT 'F',
      p_version_date      IN     DATE DEFAULT NULL,
      p_max_version       IN     VARCHAR2 DEFAULT 'T',
      p_office_id         IN     VARCHAR2 DEFAULT NULL);

   -- not documented, for LRTS
   FUNCTION shift_for_localtime (p_date_time IN DATE, p_tz_name IN VARCHAR2)
      RETURN DATE;

   -- not documented
   FUNCTION clean_quality_code (p_quality_code IN NUMBER)
      RETURN NUMBER
      RESULT_CACHE;

   FUNCTION use_first_table (p_timestamp IN TIMESTAMP DEFAULT NULL)
      RETURN BOOLEAN;

   /**
    * Stores time series data to the database
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.replace_all
    * @see constant cwms_util.do_not_replace
    * @see constant cwms_util.replace_missing_values_only
    * @see constant cwms_util.replace_with_non_missing
    * @see constant cwms_util.delete_insert
    *
    * @param p_office_id        The office owning the time series.
    * @param p_cwms_ts_id       The time series identifier
    * @param p_units            The unit of the data values
    * @param p_timeseries_data  The time series data
    * @param p_store_rule       The store rule to use
    * @param p_override_prot    A flag ('T' or 'F') specifying whether to override the protection flag on any existing data value
    * @param p_versiondate      The version date of the data
    */
   PROCEDURE store_ts (
      p_office_id         IN VARCHAR2,
      p_cwms_ts_id        IN VARCHAR2,
      p_units             IN VARCHAR2,
      p_timeseries_data   IN tsv_array,
      p_store_rule        IN VARCHAR2,
      p_override_prot     IN NUMBER DEFAULT cwms_util.false_num,
      p_versiondate       IN DATE DEFAULT cwms_util.non_versioned);

   /**
    * Stores time series data to the database
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.replace_all
    * @see constant cwms_util.do_not_replace
    * @see constant cwms_util.replace_missing_values_only
    * @see constant cwms_util.replace_with_non_missing
    * @see constant cwms_util.delete_insert
    *
    * @param p_cwms_ts_id       The time series identifier
    * @param p_units            The unit of the data values
    * @param p_timeseries_data  The time series data
    * @param p_store_rule       The store rule to use
    * @param p_override_prot    A flag ('T' or 'F') specifying whether to override the protection flag on any existing data value
    * @param p_version_date     The version date of the data
    * @param p_office_id        The office owning the time series. If not specified or NULL, the session user's default office is used
    */
   PROCEDURE store_ts (
      p_cwms_ts_id        IN VARCHAR2,
      p_units             IN VARCHAR2,
      p_timeseries_data   IN tsv_array,
      p_store_rule        IN VARCHAR2,
      p_override_prot     IN VARCHAR2 DEFAULT 'F',
      p_version_date      IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id         IN VARCHAR2 DEFAULT NULL);

   /**
    * Stores time series data to the database using parameter types compatible with cx_Oracle Pyton package
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.replace_all
    * @see constant cwms_util.do_not_replace
    * @see constant cwms_util.replace_missing_values_only
    * @see constant cwms_util.replace_with_non_missing
    * @see constant cwms_util.delete_insert
    * @see cwms_ts.number_array
    * @see cwms_ts.double_array
    *
    * @param p_cwms_ts_id       The time series identifier
    * @param p_units            The unit of the data values
    * @param p_times            The UTC times of the data values
    * @param p_values           The data values
    * @param p_qualities        The data quality codes for the data values
    * @param p_store_rule       The store rule to use
    * @param p_override_prot    A flag ('T' or 'F') specifying whether to override the protection flag on any existing data value
    * @param p_version_date     The version date of the data
    * @param p_office_id        The office owning the time series. If not specified or NULL, the session user's default office is used
    */
   PROCEDURE store_ts (
      p_cwms_ts_id      IN VARCHAR2,
      p_units           IN VARCHAR2,
      p_times           IN number_array,
      p_values          IN double_array,
      p_qualities       IN number_array,
      p_store_rule      IN VARCHAR2,
      p_override_prot   IN VARCHAR2 DEFAULT 'F',
      p_version_date    IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id       IN VARCHAR2 DEFAULT NULL);

   /**
    * Stores time series data to the database using simple parameter types
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.replace_all
    * @see constant cwms_util.do_not_replace
    * @see constant cwms_util.replace_missing_values_only
    * @see constant cwms_util.replace_with_non_missing
    * @see constant cwms_util.delete_insert
    *
    * @param p_cwms_ts_id       The time series identifier
    * @param p_units            The unit of the data values
    * @param p_times            The UTC times of the data values in Java milliseconds
    * @param p_values           The data values
    * @param p_qualities        The data quality codes for the data values
    * @param p_store_rule       The store rule to use
    * @param p_override_prot    A flag ('T' or 'F') specifying whether to override the protection flag on any existing data value
    * @param p_version_date     The version date of the data
    * @param p_office_id        The office owning the time series. If not specified or NULL, the session user's default office is used
    */
   PROCEDURE store_ts (
      p_cwms_ts_id      IN VARCHAR2,
      p_units           IN VARCHAR2,
      p_times           IN number_tab_t,
      p_values          IN number_tab_t,
      p_qualities       IN number_tab_t,
      p_store_rule      IN VARCHAR2,
      p_override_prot   IN VARCHAR2 DEFAULT 'F',
      p_version_date    IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id       IN VARCHAR2 DEFAULT NULL);

   /**
    * Stores time series data for multiple time series to the database, allowing multiple version dates
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.replace_all
    * @see constant cwms_util.do_not_replace
    * @see constant cwms_util.replace_missing_values_only
    * @see constant cwms_util.replace_with_non_missing
    * @see constant cwms_util.delete_insert
    *
    * @param p_timeseries_array The time series data to store
    * @param p_store_rule       The store rule to use
    * @param p_override_prot    A flag ('T' or 'F') specifying whether to override the protection flag on any existing data value
    * @param p_version_dates    The version dateS of the data in UTC, one for each time seires. If this parameter is NULL, all time series
    *                           will be stored as non-versioned. If any element is NULL, its corresponding time series will be stored as
    *                           non-versioned.
    * @param p_office_id        The office owning the time series. If not specified or NULL, the session user's default office is used
    */
   PROCEDURE store_ts_multi (
      p_timeseries_array   IN timeseries_array,
      p_store_rule         IN VARCHAR2,
      p_override_prot      IN VARCHAR2 DEFAULT 'F',
      p_version_dates      IN DATE_TABLE_TYPE DEFAULT NULL,
      p_office_id          IN VARCHAR2 DEFAULT NULL);

   /**
    * Stores time series data for multiple time series to the database
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.replace_all
    * @see constant cwms_util.do_not_replace
    * @see constant cwms_util.replace_missing_values_only
    * @see constant cwms_util.replace_with_non_missing
    * @see constant cwms_util.delete_insert
    *
    * @param p_timeseries_array The time series data to store
    * @param p_store_rule       The store rule to use
    * @param p_override_prot    A flag ('T' or 'F') specifying whether to override the protection flag on any existing data value
    * @param p_version_date     The version date of the data in UTC
    * @param p_office_id        The office owning the time series. If not specified or NULL, the session user's default office is used
    */
   PROCEDURE store_ts_multi (
      p_timeseries_array   IN timeseries_array,
      p_store_rule         IN VARCHAR2,
      p_override_prot      IN VARCHAR2 DEFAULT 'F',
      p_version_date       IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id          IN VARCHAR2 DEFAULT NULL);

   /**
    * Changes processing information for a time series
    *
    * @param p_ts_code                 The unique numeric code identifying the time series
    * @param p_interval_utc_offset     The new interval_utc_offset in minutes. Can only be changed if the time series has no data.
    * @param p_snap_forward_minutes    The new snap forward tolerance in minutes. This specifies how many minutes before the expected data time that data will be considered to be on time.
    * @param p_snap_backward_minutes   The new snap backward tolerance in minutes. This specifies how many minutes after the expected data time that data will be considered to be on time.
    * @param p_local_reg_time_zone_id  Not used.
    * @param p_ts_active_flag          A flag ('T' or 'F') specifying whether the time series is active
    */
   PROCEDURE update_ts_id (
      p_ts_code                  IN NUMBER,
      p_interval_utc_offset      IN NUMBER DEFAULT NULL,        -- in minutes.
      p_snap_forward_minutes     IN NUMBER DEFAULT NULL,
      p_snap_backward_minutes    IN NUMBER DEFAULT NULL,
      p_local_reg_time_zone_id   IN VARCHAR2 DEFAULT NULL,
      p_ts_active_flag           IN VARCHAR2 DEFAULT NULL);

   /**
    * Changes processing information for a time series
    *
    * @see constant cwms_util.utc_offset_irregular
    * @see constant cwms_util.utc_offset_undefined
    *
    * @param p_ts_id                   The time series identifier
    * @param p_interval_utc_offset     The new offset into the utc data interval in minutes.
    * Restrictions on changing include:
    * <ul>
    *   <li>Cannot change if time series is irregular interval. Use rename_ts</li>
    *   <li>Cannot change if time series is regular interval and has time series data</li>
    *   <li>Cannot change to <a href="cwms_util.utc_offset_irregular">cwms_util.utc_offset_irregular</a>. Use rename_ts</li>
    * </ul>
    * @param p_snap_forward_minutes    The new snap forward tolerance in minutes. This specifies how many minutes before the expected data time that data will be considered to be on time.
    * @param p_snap_backward_minutes   The new snap backward tolerance in minutes. This specifies how many minutes after the expected data time that data will be considered to be on time.
    * @param p_local_reg_time_zone_id  Not used.
    * @param p_ts_active_flag          A flag ('T' or 'F') specifying whether the time series is active
    * @param p_db_office_id            The office that owns the time series. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE update_ts_id (
      p_cwms_ts_id               IN VARCHAR2,
      p_interval_utc_offset      IN NUMBER DEFAULT NULL,        -- in minutes.
      p_snap_forward_minutes     IN NUMBER DEFAULT NULL,
      p_snap_backward_minutes    IN NUMBER DEFAULT NULL,
      p_local_reg_time_zone_id   IN VARCHAR2 DEFAULT NULL,
      p_ts_active_flag           IN VARCHAR2 DEFAULT NULL,
      p_db_office_id             IN VARCHAR2 DEFAULT NULL);

   /**
    * Renames a time series in the database
    *
    * @param p_office_id           The office that owns the time series. If not specified or NULL, the session user's default office is used.
    * @param p_timeseries_desc_old The existing time series identifier
    * @param p_timeseries_desc_new The new time series identifier
    */
   PROCEDURE rename_ts (p_office_id             IN VARCHAR2,
                        p_timeseries_desc_old   IN VARCHAR2,
                        p_timeseries_desc_new   IN VARCHAR2);

   /**
    * Renames a time series in the database, optionally setting a new regular interval offset.<p>
    * Restrictions on changing include:
    * <ul>
    *   <li>New time series identifier must agree with new/existing data interval and offset (regular/irregular)</li>
    *   <li>Cannot change time utc offset if from one regular offset to another if time series data exists</li>
    * </ul>
    *
    * @see constant cwms_util.utc_offset_irregular
    * @see constant cwms_util.utc_offset_undefined
    *
    * @param p_cwms_ts_id_old The existing time series identifier
    * @param p_cwms_ts_id_new The new time series identifier
    * @param p_utc_offset_new The new offset into the utc data interval in minutes.
    * @param p_office_id      The office that owns the time series. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE rename_ts (p_cwms_ts_id_old   IN VARCHAR2,
                        p_cwms_ts_id_new   IN VARCHAR2,
                        p_utc_offset_new   IN NUMBER DEFAULT NULL,
                        p_office_id        IN VARCHAR2 DEFAULT NULL);

   /**
    * Parses a time series identifier into its component parts
    *
    * @param p_cwms_ts_id         The time series identifier
    * @param p_base_location_id   The base location identifier
    * @param p_sub_location_id    The sub-location identifier, if any
    * @param p_base_parameter_id  The base parameter identifier
    * @param p_sub_parameter_id   The sub-parameter identifier, if any
    * @param p_parameter_type_id  The parameter type identifier
    * @param p_interval_id        The interval identifier
    * @param p_duration_id        The duration identifier
    * @param p_version_id         The version
    */
   PROCEDURE parse_ts (p_cwms_ts_id          IN     VARCHAR2,
                       p_base_location_id       OUT VARCHAR2,
                       p_sub_location_id        OUT VARCHAR2,
                       p_base_parameter_id      OUT VARCHAR2,
                       p_sub_parameter_id       OUT VARCHAR2,
                       p_parameter_type_id      OUT VARCHAR2,
                       p_interval_id            OUT VARCHAR2,
                       p_duration_id            OUT VARCHAR2,
                       p_version_id             OUT VARCHAR2);

   -- not documented
   PROCEDURE zretrieve_ts (p_at_tsv_rc      IN OUT SYS_REFCURSOR,
                           p_units          IN     VARCHAR2,
                           p_cwms_ts_id     IN     VARCHAR2,
                           p_start_time     IN     DATE,
                           p_end_time       IN     DATE,
                           p_trim           IN     VARCHAR2 DEFAULT 'F',
                           p_inclusive      IN     NUMBER DEFAULT NULL,
                           p_version_date   IN     DATE DEFAULT NULL,
                           p_max_version    IN     VARCHAR2 DEFAULT 'T',
                           p_db_office_id   IN     VARCHAR2 DEFAULT NULL);

   /**
    * Stores time series data to the database
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.replace_all
    * @see constant cwms_util.do_not_replace
    * @see constant cwms_util.replace_missing_values_only
    * @see constant cwms_util.replace_with_non_missing
    * @see constant cwms_util.delete_insert
    *
    * @param p_cwms_ts_id       The time series identifier
    * @param p_units            The unit of the data values
    * @param p_timeseries_data  The time series data. The date_time fields of each element must be in UTC.
    * @param p_store_rule       The store rule to use
    * @param p_override_prot    A flag ('T' or 'F') specifying whether to override the protection flag on any existing data value
    * @param p_version_date     The version date of the data
    * @param p_office_id        The office owning the time series. If not specified or NULL, the session user's default office is used
    */
   PROCEDURE zstore_ts (
      p_cwms_ts_id        IN VARCHAR2,
      p_units             IN VARCHAR2,
      p_timeseries_data   IN ztsv_array,
      p_store_rule        IN VARCHAR2,
      p_override_prot     IN VARCHAR2 DEFAULT 'F',
      p_version_date      IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id         IN VARCHAR2 DEFAULT NULL);

   /**
    * Stores time series data for multiple time series to the database
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.replace_all
    * @see constant cwms_util.do_not_replace
    * @see constant cwms_util.replace_missing_values_only
    * @see constant cwms_util.replace_with_non_missing
    * @see constant cwms_util.delete_insert
    *
    * @param p_timeseries_array The time series data to store
    * @param p_store_rule       The store rule to use
    * @param p_override_prot    A flag ('T' or 'F') specifying whether to override the protection flag on any existing data value
    * @param p_version_date     The version date of the data
    * @param p_office_id        The office owning the time series. If not specified or NULL, the session user's default office is used
    */
   PROCEDURE zstore_ts_multi (
      p_timeseries_array   IN ztimeseries_array,
      p_store_rule         IN VARCHAR2,
      p_override_prot      IN VARCHAR2 DEFAULT 'F',
      p_version_date       IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id          IN VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves time series data for a specified time series and time window
    *
    * @param p_transaction_time The UTC timestamp of when the routine was called.
    * @param p_at_tsv_rc       A cursor containing the time series data.  The cursor
    * contains the following columns, sorted by date_time:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The date/time of the value, in UTC</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">value</td>
    *     <td class="descr">binary_double</td>
    *     <td class="descr">The data value</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">3</td>
    *     <td class="descr">quality_code</td>
    *     <td class="descr">number</td>
    *     <td class="descr">The quality code for the data value</td>
    *   </tr>
    * </table>
    * @param p_units_out       The unit of the retrieved data values
    * @param p_cwms_ts_id_out  The case-corrected version of the time series identifier
    * @param p_units_in        The unit to retrieve the data values in
    * @param p_cwms_ts_id_in   The time series identifier to retrieve data for
    * @param p_start_time      The start time of the time window
    * @param p_end_time        The end time of the time window
    * @param p_trim            A flag ('T' or 'F') that specifies whether to trim missing values from the beginning and end of the retrieved values
    * @param p_inclusive       A flag ('T' or 'F') that specifies whether the time window includes the start and end times
    * @param p_version_date    The version date of the data to retrieve. If not specified or NULL, the version date is determined by p_max_version
    * @param p_max_version     A flag ('T' or 'F') that specifies whether to retrieve the maximum ('T') or minimum ('F') version date if p_version_date is NULL
    * @param p_office_id       The office that owns the time series
    */
   PROCEDURE zretrieve_ts_java (
      p_transaction_time      OUT DATE,
      p_at_tsv_rc             OUT SYS_REFCURSOR,
      p_units_out             OUT VARCHAR2,
      p_cwms_ts_id_out        OUT VARCHAR2,
      p_units_in           IN     VARCHAR2,
      p_cwms_ts_id_in      IN     VARCHAR2,
      p_start_time         IN     DATE,
      p_end_time           IN     DATE,
      p_trim               IN     VARCHAR2 DEFAULT 'F',
      p_inclusive          IN     NUMBER DEFAULT NULL,
      p_version_date       IN     DATE DEFAULT NULL,
      p_max_version        IN     VARCHAR2 DEFAULT 'T',
      p_db_office_id       IN     VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves existing date_times and version_dates for a time series for specified time series and item types.
    *
    * @param p_cursor  A cursor containing the date_times and version_dates that match the input parameters.
    * The cursor contains the following columns and will be sorted ascending by date_time and then by version_date:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The date_time of an existing value (in UTC)</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">version_date</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The version date (in UTC) associated with the date_time</td>
    *   </tr>
    * </table>
    * @param p_ts_code          the unique numeric code identifying the time series
    * @param p_start_time_utc   the earliest date_time to retrieve. If not specified or null no earliest bound will be applied.
    * @param p_end_time_utc     the latest date_time to retrieve.  If not specified or null no latest bound will be applied.
    * @param p_date_times_utc   a table of date_times to use instead of p_start_time_utc and p_end_time_utc. If not specified or null, p_start_time_utc and p_end_time_utc will be used.
    * @param p_version_date_utc the version_date to retrieve times for. If not specified, or null, p_max_vesion will determine whether the earliest or latest version date is retrieved.
    * @param p_max_version      flag specifying whether to retrieve the latest (true) or earliest (false) version_date if p_version_date_utc is not specified or null.
    * @param p_item_mask        value specifying which time series items to retrieve times for (values, standard/non-standard text, binary)
    *
    * @since CWMS 2.1
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.all_version_dates
    * @see constant cwms_util.ts_values
    * @see constant cwms_util.ts_std_text
    * @see constant cwms_util.ts_text
    * @see constant cwms_util.ts_all_text
    * @see constant cwms_util.ts_binary
    * @see constant cwms_util.ts_all_non_values
    * @see constant cwms_util.ts_all
    */
   PROCEDURE retrieve_existing_times(
      p_cursor           OUT sys_refcursor,
      p_ts_code          IN  NUMBER,
      p_start_time_utc   IN  DATE            DEFAULT NULL,
      p_end_time_utc     IN  DATE            DEFAULT NULL,
      p_date_times_utc   in  date_table_type DEFAULT NULL,
      p_version_date_utc IN  DATE            DEFAULT NULL,
      p_max_version      IN  BOOLEAN         DEFAULT TRUE,
      p_item_mask        IN  BINARY_INTEGER  DEFAULT cwms_util.ts_all);

   /**
    * Retrieves existing date_times and version_dates for a time series for specified time series and item types.
    *
    * @param p_ts_code          the unique numeric code identifying the time series
    * @param p_start_time_utc   the earliest date_time to retrieve. If not specified or null no earliest bound will be applied.
    * @param p_end_time_utc     the latest date_time to retrieve.  If not specified or null no latest bound will be applied.
    * @param p_date_times_utc   a table of date_times to use instead of p_start_time_utc and p_end_time_utc. If not specified or null, p_start_time_utc and p_end_time_utc will be used.
    * @param p_version_date_utc the version_date to retrieve times for. If not specified, or null, p_max_vesion will determine whether the earliest or latest version date is retrieved.
    * @param p_max_version      flag specifying whether to retrieve the latest (true) or earliest (false) version_date if p_version_date_utc is not specified or null.
    * @param p_item_mask        value specifying which time series items to retrieve times for (values, standard/non-standard text, binary)
    *
    * @return  A cursor containing the date_times and version_dates that match the input parameters.
    * The cursor contains the following columns and will be sorted ascending by date_time and then by version_date:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The date_time of an existing value (in UTC)</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">version_date</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The version date (in UTC) associated with the date_time</td>
    *   </tr>
    * </table>
    *
    * @since CWMS 2.1
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.all_version_dates
    * @see constant cwms_util.ts_values
    * @see constant cwms_util.ts_std_text
    * @see constant cwms_util.ts_text
    * @see constant cwms_util.ts_all_text
    * @see constant cwms_util.ts_binary
    * @see constant cwms_util.ts_all_non_values
    * @see constant cwms_util.ts_all
    */
   FUNCTION retrieve_existing_times_f(
      p_ts_code          IN  NUMBER,
      p_start_time_utc   IN  DATE            DEFAULT NULL,
      p_end_time_utc     IN  DATE            DEFAULT NULL,
      p_date_times_utc   in  date_table_type DEFAULT NULL,
      p_version_date_utc IN  DATE            DEFAULT NULL,
      p_max_version      IN  BOOLEAN         DEFAULT TRUE,
      p_item_mask        IN  BINARY_INTEGER  DEFAULT cwms_util.ts_all)
      RETURN sys_refcursor;

   /**
    * Retrieves existing date_times, version_dates, and counts of time series item types for a specified time series.
    *
    * @param p_cursor  A cursor containing the date_times, version_datesm and item counts that match the input parameters.
    * The cursor contains the following columns and will be sorted ascending by date_time and then by version_date:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The date_time of an existing value (in UTC)</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">version_date</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The version date (in UTC) associated with the date_time</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">3</td>
    *     <td class="descr">value_count</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The number of values (0/1) for the date_time and vesion_date</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">4</td>
    *     <td class="descr">std_text_count</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The number of standard text items (>=0) for the date_time and vesion_date</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">5</td>
    *     <td class="descr">text_count</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The number of non-standard text items (>=0) for the date_time and vesion_date</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">6</td>
    *     <td class="descr">binary_count</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The number of binary items (>=0) for the date_time and vesion_date</td>
    *   </tr>
    * </table>
   * @param p_ts_code          the unique numeric code identifying the time series
    * @param p_start_time_utc   the earliest date_time to retrieve. If not specified or null no earliest bound will be applied.
    * @param p_end_time_utc     the latest date_time to retrieve.  If not specified or null no latest bound will be applied.
    * @param p_date_times_utc   a table of date_times to use instead of p_start_time_utc and p_end_time_utc. If not specified or null, p_start_time_utc and p_end_time_utc will be used.
    * @param p_version_date_utc the version_date to retrieve times for. If not specified, or null, p_max_vesion will determine whether the earliest or latest version date is retrieved.
    * @param p_max_version      flag specifying whether to retrieve the latest (true) or earliest (false) version_date if p_version_date_utc is not specified or null.
    *
    * @since CWMS 2.1
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.all_version_dates
    */
   PROCEDURE retrieve_existing_item_counts(
      p_cursor           OUT sys_refcursor,
      p_ts_code          IN  NUMBER,
      p_start_time_utc   IN  DATE            DEFAULT NULL,
      p_end_time_utc     IN  DATE            DEFAULT NULL,
      p_date_times_utc   in  date_table_type DEFAULT NULL,
      p_version_date_utc IN  DATE            DEFAULT NULL,
      p_max_version      IN  BOOLEAN         DEFAULT TRUE);

   /**
    * Retrieves existing date_times, version_dates, and counts of time series item types for a specified time series.
    *
    * @param p_ts_code          the unique numeric code identifying the time series
    * @param p_start_time_utc   the earliest date_time to retrieve. If not specified or null no earliest bound will be applied.
    * @param p_end_time_utc     the latest date_time to retrieve.  If not specified or null no latest bound will be applied.
    * @param p_date_times_utc   a table of date_times to use instead of p_start_time_utc and p_end_time_utc. If not specified or null, p_start_time_utc and p_end_time_utc will be used.
    * @param p_version_date_utc the version_date to retrieve times for. If not specified, or null, p_max_vesion will determine whether the earliest or latest version date is retrieved.
    * @param p_max_version      flag specifying whether to retrieve the latest (true) or earliest (false) version_date if p_version_date_utc is not specified or null.
    *
    * @return  A cursor containing the date_times, version_datesm and item counts that match the input parameters.
    * The cursor contains the following columns and will be sorted ascending by date_time and then by version_date:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">Column No.</th>
    *     <th class="descr">Column Name</th>
    *     <th class="descr">Data Type</th>
    *     <th class="descr">Contents</th>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">1</td>
    *     <td class="descr">date_time</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The date_time of an existing value (in UTC)</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">2</td>
    *     <td class="descr">version_date</td>
    *     <td class="descr">date</td>
    *     <td class="descr">The version date (in UTC) associated with the date_time</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">3</td>
    *     <td class="descr">value_count</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The number of values (0/1) for the date_time and vesion_date</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">4</td>
    *     <td class="descr">std_text_count</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The number of standard text items (>=0) for the date_time and vesion_date</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">5</td>
    *     <td class="descr">text_count</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The number of non-standard text items (>=0) for the date_time and vesion_date</td>
    *   </tr>
    *   <tr>
    *     <td class="descr-center">6</td>
    *     <td class="descr">binary_count</td>
    *     <td class="descr">integer</td>
    *     <td class="descr">The number of binary items (>=0) for the date_time and vesion_date</td>
    *   </tr>
    * </table>
    *
    * @since CWMS 2.1
    *
    * @see constant cwms_util.non_versioned
    * @see constant cwms_util.all_version_dates
    */
   FUNCTION retrieve_existing_item_counts(
      p_ts_code          IN  NUMBER,
      p_start_time_utc   IN  DATE            DEFAULT NULL,
      p_end_time_utc     IN  DATE            DEFAULT NULL,
      p_date_times_utc   in  date_table_type DEFAULT NULL,
      p_version_date_utc IN  DATE            DEFAULT NULL,
      p_max_version      IN  BOOLEAN         DEFAULT TRUE)
      RETURN sys_refcursor;

   -- not documented
   PROCEDURE collect_deleted_times (p_deleted_time   IN TIMESTAMP,
                                    p_ts_code        IN NUMBER,
                                    p_version_date   IN DATE,
                                    p_start_time     IN DATE,
                                    p_end_time       IN DATE);

   -- not documented
   PROCEDURE retrieve_deleted_times (
      p_deleted_times      OUT date_table_type,
      p_deleted_time    IN     NUMBER,
      p_ts_code         IN     NUMBER,
      p_version_date    IN     NUMBER);

   -- not documented
   FUNCTION retrieve_deleted_times_f (p_deleted_time   IN NUMBER,
                                      p_ts_code        IN NUMBER,
                                      p_version_date   IN NUMBER)
      RETURN date_table_type;

   -- not documented
   PROCEDURE create_parameter_id (p_parameter_id   IN VARCHAR2,
                                  p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   -- not documented
   PROCEDURE delete_parameter_id (p_parameter_id   IN VARCHAR2,
                                  p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   -- not documented
   PROCEDURE rename_parameter_id (
      p_parameter_id_old   IN VARCHAR2,
      p_parameter_id_new   IN VARCHAR2,
      p_db_office_id       IN VARCHAR2 DEFAULT NULL);

   /**
    * Registers a callback procedure to be notified of enqueued messages
    *
    * @see cwms_msg.register_msg_callback
    *
    * @param p_procedure_name   The name of the procedure to register.  This can be a free standing or package procedure and must have exactly the following signature:<p>
    * <big><pre>
    * procedure procedure_name (
    *      context  in raw,
    *      reginfo  in sys.aq$_reg_info,
    *      descr    in sys.aq$_descriptor,
    *      payload  in raw,
    *      payloadl in number);
    * </pre></big>
    * @param p_subscriber_name  The subscriber name, unique per queue. If not specified or NULL, a unique subscriber name will be generated.
    * @param p_queue_name       The queue name to subscibe to. If not specified or NULL, the TS_DATA_STORED queue for the session user's default office is used
    *
    * @return The subscriber name (specified or generated) used to register the callback procedure
    */
   FUNCTION register_ts_callback (
      p_procedure_name    IN VARCHAR2,
      p_subscriber_name   IN VARCHAR2 DEFAULT NULL,
      p_queue_name        IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2;

   /**
    * Unregisters a callback procedure from a queue
    *
    * @see cwms_msg.unregister_msg_callback
    *
    * @param p_procedure_name   The name of the procedure to unregister
    * @param p_subscriber_name  The subscriber name. This must be the same value returned from register_ts_callback
    * @param p_queue_name       The queue name to unsubscibe from. If not specified or NULL, the TS_DATA_STORED queue for the session user's default office is used
    */
   PROCEDURE unregister_ts_callback (
      p_procedure_name    IN VARCHAR2,
      p_subscriber_name   IN VARCHAR2,
      p_queue_name        IN VARCHAR2 DEFAULT NULL);

   -- not documented
   PROCEDURE refresh_ts_catalog;

   /**
    * Stores a time series category
    *
    * @param p_ts_category_id   The time series category identifier
    * @param p_ts_category_desc A description of the time series category
    * @param p_fail_if_exists   A flag ('T' or 'F') that specifies whether the routine should fail if the time series category already exists
    * @param p_ignore_null      A flag ('T' or 'F') that specifies whether to ignore a NULL description when updating a category
    * @param p_db_office_id     The office that owns the time series category. If not specified or NULL, the session user's default office is used.
    *
    * @exception ITEM_ALREADY_EXISTS if p_fail_if_exists is 'T' and the time series category already exists
    */
   PROCEDURE store_ts_category (
      p_ts_category_id     IN VARCHAR2,
      p_ts_category_desc   IN VARCHAR2 DEFAULT NULL,
      p_fail_if_exists     IN VARCHAR2 DEFAULT 'F',
      p_ignore_null        IN VARCHAR2 DEFAULT 'T',
      p_db_office_id       IN VARCHAR2 DEFAULT NULL);

   /**
    * Stores a time series category, returning its unique numeric code
    *
    * @param p_ts_category_id   The time series category identifier
    * @param p_ts_category_desc A description of the time series category
    * @param p_fail_if_exists   A flag ('T' or 'F') that specifies whether the routine should fail if the time series category already exists
    * @param p_ignore_null      A flag ('T' or 'F') that specifies whether to ignore a NULL description when updating a category
    * @param p_db_office_id     The office that owns the time series category. If not specified or NULL, the session user's default office is used.
    *
    * @return The unique numeric code that identifies the time series category
    *
    * @exception ITEM_ALREADY_EXISTS if p_fail_if_exists is 'T' and the time series category already exists
    */
   FUNCTION store_ts_category_f (
      p_ts_category_id     IN VARCHAR2,
      p_ts_category_desc   IN VARCHAR2 DEFAULT NULL,
      p_fail_if_exists     IN VARCHAR2 DEFAULT 'F',
      p_ignore_null        IN VARCHAR2 DEFAULT 'T',
      p_db_office_id       IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER;

   /**
    * Renames a time series category in the database
    *
    * @param p_ts_category_id_old The existing identifier of the time series category
    * @param p_ts_category_id_new The new identifier of the time series category
    * @param p_db_office_id       The office that owns the time series category. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE rename_ts_category (
      p_ts_category_id_old   IN VARCHAR2,
      p_ts_category_id_new   IN VARCHAR2,
      p_db_office_id         IN VARCHAR2 DEFAULT NULL);

   /**
    * Deletes a time series category from the database
    *
    * @param p_ts_category_id The time series category identifier
    * @param p_cascade        A flag ('T' or 'F') that specifies whether to delete any time series groups in the category
    * @param p_db_office_id   The office that owns the time series category. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE delete_ts_category (p_ts_category_id   IN VARCHAR2,
                                 p_cascade          IN VARCHAR2 DEFAULT 'F',
                                 p_db_office_id     IN VARCHAR2 DEFAULT NULL);

   /**
    * Stores a time series group
    *
    * @param p_ts_category_id   The time series category that owns the time series group
    * @param p_ts_group_id      The time series group identifier
    * @param p_ts_group_desc    A description of the time series group
    * @param p_fail_if_exists   A flag ('T' or 'F') that specifies whether the routine should fail if the time series group already exists
    * @param p_ignore_nulls     A flag ('T' or 'F') that specifies whether to ignore a NULL parameters when updating. If 'T' no data will be overwritten with NULL
    * @param p_shared_alias_id  An alias, if any, that applies to all members of the time series group
    * @param p_shared_ts_ref_id A reference to a time series, if any, that applies to all members of the time series group
    * @param p_db_office_id     The office that owns the time series group. If not specified or NULL, the session user's default office is used.
    *
    * @exception ITEM_ALREADY_EXISTS if p_fail_if_exists is 'T' and the time series group already exists
    */
   PROCEDURE store_ts_group (p_ts_category_id     IN VARCHAR2,
                             p_ts_group_id        IN VARCHAR2,
                             p_ts_group_desc      IN VARCHAR2 DEFAULT NULL,
                             p_fail_if_exists     IN VARCHAR2 DEFAULT 'F',
                             p_ignore_nulls       IN VARCHAR2 DEFAULT 'T',
                             p_shared_alias_id    IN VARCHAR2 DEFAULT NULL,
                             p_shared_ts_ref_id   IN VARCHAR2 DEFAULT NULL,
                             p_db_office_id       IN VARCHAR2 DEFAULT NULL);

   /**
    * Stores a time series group, returning its unique numeric code
    *
    * @param p_ts_category_id   The time series category that owns the time series group
    * @param p_ts_group_id      The time series group identifier
    * @param p_ts_group_desc    A description of the time series group
    * @param p_fail_if_exists   A flag ('T' or 'F') that specifies whether the routine should fail if the time series group already exists
    * @param p_ignore_nulls     A flag ('T' or 'F') that specifies whether to ignore a NULL parameters when updating. If 'T' no data will be overwritten with NULL
    * @param p_shared_alias_id  An alias, if any, that applies to all members of the time series group
    * @param p_shared_ts_ref_id A reference to a time series, if any, that applies to all members of the time series group
    * @param p_db_office_id     The office that owns the time series group. If not specified or NULL, the session user's default office is used.
    *
    * @return The unique numeric code that identifies the time series group
    *
    * @exception ITEM_ALREADY_EXISTS if p_fail_if_exists is 'T' and the time series group already exists
    */
   FUNCTION store_ts_group_f (p_ts_category_id     IN VARCHAR2,
                              p_ts_group_id        IN VARCHAR2,
                              p_ts_group_desc      IN VARCHAR2 DEFAULT NULL,
                              p_fail_if_exists     IN VARCHAR2 DEFAULT 'F',
                              p_ignore_nulls       IN VARCHAR2 DEFAULT 'T',
                              p_shared_alias_id    IN VARCHAR2 DEFAULT NULL,
                              p_shared_ts_ref_id   IN VARCHAR2 DEFAULT NULL,
                              p_db_office_id       IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER;

   /**
    * Renames a time series group in the database
    *
    * @param p_ts_category_id   The time series category that owns the time series group
    * @param p_ts_group_id_old  The existing identifier of the time series group
    * @param p_ts_group_id_new  The new identifier of the time series group
    * @param p_db_office_id     The office that owns the time series group. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE rename_ts_group (p_ts_category_id    IN VARCHAR2,
                              p_ts_group_id_old   IN VARCHAR2,
                              p_ts_group_id_new   IN VARCHAR2,
                              p_db_office_id      IN VARCHAR2 DEFAULT NULL);

   /**
    * Deletes a time series group from the database
    *
    * @param p_ts_category_id The time series category that owns the time series group
    * @param p_ts_group_id    The time series group identifier
    * @param p_db_office_id   The office that owns the time series group. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE delete_ts_group (p_ts_category_id   IN VARCHAR2,
                              p_ts_group_id      IN VARCHAR2,
                              p_db_office_id     IN VARCHAR2 DEFAULT NULL);

   /**
    * Assigns a time series to a time series group
    *
    * @param p_ts_category_id The time series category that owns the time series group
    * @param p_ts_group_id    The time series group identifier
    * @param p_ts_id          The time series identifier to assign to the group
    * @param p_ts_attribute   A numeric attribute value, if any, that is associated with the time series within the group. Can be used for sorting, etc.
    * @param p_ts_alias_id    An alias, if any, that applies to the timeseries within the group
    * @param p_ref_ts_id      A time series identifier, if any, that is referred to by the time series within the group
    * @param p_db_office_id   The office that owns the time series category, time series group and time series. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE assign_ts_group (p_ts_category_id   IN VARCHAR2,
                              p_ts_group_id      IN VARCHAR2,
                              p_ts_id            IN VARCHAR2,
                              p_ts_attribute     IN NUMBER DEFAULT NULL,
                              p_ts_alias_id      IN VARCHAR2 DEFAULT NULL,
                              p_ref_ts_id        IN VARCHAR2 DEFAULT NULL,
                              p_db_office_id     IN VARCHAR2 DEFAULT NULL);

   /**
    * Unassigns a time series, or all time series from time series group
    *
    * @param p_ts_category_id The time series category that owns the time series group
    * @param p_ts_group_id    The time series group identifier
    * @param p_ts_id          The time series identifier to assign to the group. Can be NULL if p_unassign_all is 'T'
    * @param p_unassign_all   A flag ('T' or 'F') that specifies whether to un-assign all time series from the group.
    * @param p_db_office_id   The office that owns the time series category, time series group and time series. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE unassign_ts_group (p_ts_category_id   IN VARCHAR2,
                                p_ts_group_id      IN VARCHAR2,
                                p_ts_id            IN VARCHAR2,
                                p_unassign_all     IN VARCHAR2 DEFAULT 'F',
                                p_db_office_id     IN VARCHAR2 DEFAULT NULL);

   /**
    * Assigns a collection of time series to a time series group
    *
    * @param p_ts_category_id The time series category that owns the time series group
    * @param p_ts_group_id    The time series group identifier
    * @param p_ts_alias_array The time series identifiers and associated information to assign to the group
    * @param p_db_office_id   The office that owns the time series category, time series group and time series. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE assign_ts_groups (p_ts_category_id   IN VARCHAR2,
                               p_ts_group_id      IN VARCHAR2,
                               p_ts_alias_array   IN ts_alias_tab_t,
                               p_db_office_id     IN VARCHAR2 DEFAULT NULL);

   /**
    * Un-assigns a collection of time series from a time series group
    *
    * @param p_ts_category_id The time series category that owns the time series group
    * @param p_ts_group_id    The time series group identifier
    * @param p_ts_alias_array The time series identifiers to un-assign. Can be NULL if p_unassign_all is 'T'
    * @param p_unassign_all   A flag ('T' or 'F') that specifies whether to un-assign all time series from the group.
    * @param p_db_office_id   The office that owns the time series category, time series group and time series. If not specified or NULL, the session user's default office is used.
    */
   PROCEDURE unassign_ts_groups (p_ts_category_id   IN VARCHAR2,
                                 p_ts_group_id      IN VARCHAR2,
                                 p_ts_array         IN str_tab_t,
                                 p_unassign_all     IN VARCHAR2 DEFAULT 'F',
                                 p_db_office_id     IN VARCHAR2 DEFAULT NULL);

   /**
    * Retrieve a time series identifier from a time series group alias
    *
    * @param p_alias_id     The time series alias within the time series group
    * @param p_group_id     The time series group identifier
    * @param p_category_id  The time series category that owns the time series group
    * @param p_db_office_id The office that owns the time series category, time series group and time series. If not specified or NULL, the session user's default office is used.
    *
    * @return The time series identifier
    */
   FUNCTION get_ts_id_from_alias (p_alias_id      IN VARCHAR2,
                                  p_group_id      IN VARCHAR2 DEFAULT NULL,
                                  p_category_id   IN VARCHAR2 DEFAULT NULL,
                                  p_office_id     IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2;

   /**
    * Retrieve the unique numeric code identifying a time series from a time series group alias
    *
    * @param p_alias_id     The time series alias within the time series group
    * @param p_group_id     The time series group identifier
    * @param p_category_id  The time series category that owns the time series group
    * @param p_db_office_id The office that owns the time series category, time series group and time series. If not specified or NULL, the session user's default office is used.
    *
    * @return The unique numeric code that identifies the time series
    */
   FUNCTION get_ts_code_from_alias (p_alias_id      IN VARCHAR2,
                                    p_group_id      IN VARCHAR2 DEFAULT NULL,
                                    p_category_id   IN VARCHAR2 DEFAULT NULL,
                                    p_office_id     IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER;

   /**
    * Retrieves a time series identifier from an identifier that may be a time series or alias identifier
    *
    * @param p_ts_id_or_alias The identifier that may be a time series or alias identifier
    * @param p_office_id      The office that owns the time series
    *
    * @return The time series identifier
    */
   FUNCTION get_ts_id (p_ts_id_or_alias IN VARCHAR2, p_office_id IN VARCHAR2)
      RETURN VARCHAR2;

   /**
    * Retrieves the unique numeric code identifying a time series from an identifier that may be a time series or alias identifier
    *
    * @param p_ts_id_or_alias The identifier that may be a time series or alias identifier
    * @param p_office_id      The office that owns the time series
    *
    * @return The unique numeric code identifying the time series
    */
   FUNCTION get_ts_id (p_ts_id_or_alias IN VARCHAR2, p_office_code IN NUMBER)
      RETURN VARCHAR2;

   /**
    * Retrieves a text description of the validity portion of a quality code
    *
    * @param p_quality_code The quality code
    *
    * @return The text description of the validity portion of the quality code
    */
   FUNCTION get_quality_validity (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      RESULT_CACHE;

   /**
    * Retrieves a text description of the validity portion of the quality code of a time series value
    *
    * @param p_value The time series value
    *
    * @return The text description of the validity portion of the quality code
    */
   FUNCTION get_quality_validity (p_value IN tsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves a text description of the validity portion of the quality code of a time series value
    *
    * @param p_value The time series value
    *
    * @return The text description of the validity portion of the quality code
    */
   FUNCTION get_quality_validity (p_value IN ztsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves whether a quality code is marked as okay
    *
    * @param p_quality_code The quality code
    *
    * @return Whether the quality code is marked as okay
    */
   FUNCTION quality_is_okay (p_quality_code IN NUMBER)
      RETURN BOOLEAN
      RESULT_CACHE;

   /**
    * Retrieves whether the quality code of a time series value is marked as okay
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as okay
    */
   FUNCTION quality_is_okay (p_value IN tsv_type)
      RETURN BOOLEAN;

   /**
    * Retrieves whether the quality code of a time series value is marked as okay
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as okay
    */
   FUNCTION quality_is_okay (p_value IN ztsv_type)
      RETURN BOOLEAN;

   /**
    * Retrieves whether a quality code is marked as okay
    *
    * @param p_quality_code The quality code
    *
    * @return Whether the quality code is marked as okay as text ('T'/'F')
    */
   FUNCTION quality_is_okay_text (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      RESULT_CACHE;

   /**
    * Retrieves whether the quality code of a time series value is marked as okay
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as okay as text ('T'/'F')
    */
   FUNCTION quality_is_okay_text (p_value IN tsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves whether the quality code of a time series value is marked as okay
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as okay as text ('T'/'F')
    */
   FUNCTION quality_is_okay_text (p_value IN ztsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves whether a quality code is marked as missing
    *
    * @param p_quality_code The quality code
    *
    * @return Whether the quality code is marked as missing
    */
   FUNCTION quality_is_missing (p_quality_code IN NUMBER)
      RETURN BOOLEAN
      RESULT_CACHE;

   /**
    * Retrieves whether the quality code of a time series value is marked as missing
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as missing
    */
   FUNCTION quality_is_missing (p_value IN tsv_type)
      RETURN BOOLEAN;

   /**
    * Retrieves whether the quality code of a time series value is marked as missing
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as missing
    */
   FUNCTION quality_is_missing (p_value IN ztsv_type)
      RETURN BOOLEAN;

   /**
    * Retrieves whether a quality code is marked as missing
    *
    * @param p_quality_code The quality code
    *
    * @return Whether the quality code is marked as missing as text ('T'/'F')
    */
   FUNCTION quality_is_missing_text (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      RESULT_CACHE;

   /**
    * Retrieves whether the quality code of a time series value is marked as missing
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as missing as text ('T'/'F')
    */
   FUNCTION quality_is_missing_text (p_value IN tsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves whether the quality code of a time series value is marked as missing
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as missing as text ('T'/'F')
    */
   FUNCTION quality_is_missing_text (p_value IN ztsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves whether a quality code is marked as questionable
    *
    * @param p_quality_code The quality code
    *
    * @return Whether the quality code is marked as questionable
    */
   FUNCTION quality_is_questionable (p_quality_code IN NUMBER)
      RETURN BOOLEAN
      RESULT_CACHE;

   /**
    * Retrieves whether the quality code of a time series value is marked as questionable
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as questionable
    */
   FUNCTION quality_is_questionable (p_value IN tsv_type)
      RETURN BOOLEAN;

   /**
    * Retrieves whether the quality code of a time series value is marked as questionable
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as questionable
    */
   FUNCTION quality_is_questionable (p_value IN ztsv_type)
      RETURN BOOLEAN;

   /**
    * Retrieves whether a quality code is marked as questionable
    *
    * @param p_quality_code The quality code
    *
    * @return Whether the quality code is marked as questionable as text ('T'/'F')
    */
   FUNCTION quality_is_questionable_text (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      RESULT_CACHE;

   /**
    * Retrieves whether the quality code of a time series value is marked as questionable
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as questionable as text ('T'/'F')
    */
   FUNCTION quality_is_questionable_text (p_value IN tsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves whether the quality code of a time series value is marked as questionable
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as questionable as text ('T'/'F')
    */
   FUNCTION quality_is_questionable_text (p_value IN ztsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves whether a quality code is marked as rejected
    *
    * @param p_quality_code The quality code
    *
    * @return Whether the quality code is marked as rejected
    */
   FUNCTION quality_is_rejected (p_quality_code IN NUMBER)
      RETURN BOOLEAN
      RESULT_CACHE;

   /**
    * Retrieves whether the quality code of a time series value is marked as rejected
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as rejected
    */
   FUNCTION quality_is_rejected (p_value IN tsv_type)
      RETURN BOOLEAN;

   /**
    * Retrieves whether the quality code of a time series value is marked as rejected
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as rejected
    */
   FUNCTION quality_is_rejected (p_value IN ztsv_type)
      RETURN BOOLEAN;

   /**
    * Retrieves whether a quality code is marked as rejected
    *
    * @param p_quality_code The quality code
    *
    * @return Whether the quality code is marked as rejected  as text ('T'/'F')
    */
   FUNCTION quality_is_rejected_text (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      RESULT_CACHE;

   /**
    * Retrieves whether the quality code of a time series value is marked as rejected
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as rejected as text ('T'/'F')
    */
   FUNCTION quality_is_rejected_text (p_value IN tsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves whether the quality code of a time series value is marked as rejected
    *
    * @param p_value The time series value
    *
    * @return Whether the quality code is marked as rejected  as text ('T'/'F')
    */
   FUNCTION quality_is_rejected_text (p_value IN ztsv_type)
      RETURN VARCHAR2;

   /**
    * Retrieves a text description for a quality code
    *
    * @param p_quality_code The quality code
    *
    * @return A text description for the quality code
    */
   FUNCTION get_quality_description (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      RESULT_CACHE;

   /**
    * Retrieves the interval minutes of a time series
    *
    * @param p_ts_code the unique numeric value identifying the time series
    *
    * @return the interval minutes of the time series identifier
    */
   FUNCTION get_ts_interval (p_ts_code IN NUMBER)
      RETURN NUMBER RESULT_CACHE;

   /**
    * Retrieves the interval minutes of a time series identifier
    *
    * @param p_cwms_ts_id the time series identifier
    *
    * @return the interval minutes of the time series identifier
    */
   FUNCTION get_ts_interval (p_cwms_ts_id IN VARCHAR2)
      RETURN NUMBER RESULT_CACHE;

   /**
    * Retrieves the interval portion string of a time series identifier
    *
    * @param p_cwms_ts_id the time series identifier
    *
    * @return the interval portion string of the time series identifier
    */
   FUNCTION get_ts_interval_string (p_cwms_ts_id IN VARCHAR2)
      RETURN VARCHAR2 RESULT_CACHE;

   /**
    * Retrieves the interval minutes of a specified interval string
    *
    * @param p_interval_id the time series identifier
    *
    * @return the interval minutes of the specified interval string
    */
   FUNCTION get_interval (p_interval_id IN VARCHAR2)
      RETURN NUMBER RESULT_CACHE;

   /**
    * Returns the UTC interval offset for a specified time and interval
    *
    * @param p_date_time_utc    the date/time
    * @param p_interval_minutes the interval in minutes
    *
    * @return the UTC interval offset in minuts
    */
   FUNCTION get_utc_interval_offset (
      p_date_time_utc    IN DATE,
      p_interval_minutes IN NUMBER)
      RETURN NUMBER RESULT_CACHE;
   /**
    * Returns a table of valid date/times in a specified time window for a regular time series
    *
    * @param p_start_time the start time of the time window
    * @param p_end_time   the end time of the time window
    * @param p_interval_minutes the interval for the time series, specified in minutes
    * @param p_utc_interval_offset_minutes The valid offset in minutes into the UTC interval for the time series
    * @param p_time_zone the time zone of the input and output values. If null or not specified, the time zone 'UTC' is used.
    *
    * @return the table of valid date/times for the specified parameters
    */
   FUNCTION get_times_for_time_window (
      p_start_time                  IN DATE,
      p_end_time                    IN DATE,
      p_interval_minutes            IN INTEGER,
      p_utc_interval_offset_minutes IN INTEGER,
      p_time_zone                   IN VARCHAR2 DEFAULT 'UTC')
      RETURN date_table_type;
   /**
    * Returns a table of valid date/times in a specified time window for a regular time series
    *
    * @param p_start_time the start time of the time window
    * @param p_end_time   the end time of the time window
    * @param p_ts_code    the unique numeric code identifying the time series
    * @param p_time_zone the time zone of the input and output values. If null or not specified, the time zone 'UTC' is used.
    *
    * @return the table of valid date/times for the time series
    */
   FUNCTION get_times_for_time_window (
      p_start_time IN DATE,
      p_end_time   IN DATE,
      p_ts_code    IN INTEGER,
      p_time_zone  IN VARCHAR2 DEFAULT 'UTC')
      RETURN date_table_type;
   /**
    * Returns a table of valid date/times in a specified time window for a regular time series
    *
    * @param p_start_time the start time of the time window
    * @param p_end_time   the end time of the time window
    * @param p_ts_id      the time series identifier
    * @param p_time_zone  the time zone of the input and output values. If null or not specified, the time zone 'UTC' is used.
    * @param p_office_id  the identifier of the office that owns the time series. If not specified or NULL, the session user's default office is used.
    *
    * @return the table of valid date/times for the time series
    */
   FUNCTION get_times_for_time_window (
      p_start_time IN DATE,
      p_end_time   IN DATE,
      p_ts_id      IN VARCHAR2,
      p_time_zone  IN VARCHAR2 DEFAULT 'UTC',
      p_office_id  IN VARCHAR2 DEFAULT NULL)
      RETURN date_table_type;
   /**
    * Retrieves the earliest time series data date in the database for a time series
    *
    * @see constant cwms_util.non_versioned
    *
    * @param p_ts_code          The unique numeric code identifying the time series
    * @param p_version_date_utc The version date of the time series in UTC
    *
    * @return The earliest time series data date in the database for the time series, in UTC
    */
   FUNCTION get_ts_min_date_utc (
      p_ts_code            IN NUMBER,
      p_version_date_utc   IN DATE DEFAULT cwms_util.non_versioned)
      RETURN DATE;

   /**
    * Retrieves the earliest time series data date in the database for a time series
    *
    * @see constant cwms_util.non_versioned
    *
    * @param p_cwms_ts_id   The time series identifier
    * @param p_time_zone    The time zone in which to retrieve the earliest time
    * @param p_version_date The version date of the time series in the specified time zone
    * @param p_office_id    The office that owns the time series. If not specified or NULL, the session user's default office is used
    *
    * @return The earliest time series data date in the database for the time series, in the specified time zone
    */
   FUNCTION get_ts_min_date (
      p_cwms_ts_id     IN VARCHAR2,
      p_time_zone      IN VARCHAR2 DEFAULT 'UTC',
      p_version_date   IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id      IN VARCHAR2 DEFAULT NULL)
      RETURN DATE;

   /**
    * Retrieves the latest time series data date in the database for a time series
    *
    * @see constant cwms_util.non_versioned
    *
    * @param p_ts_code          The unique numeric code identifying the time series
    * @param p_version_date_utc The version date of the time series in UTC
    *
    * @return The latest time series data date in the database for the time series, in UTC
    */
   FUNCTION get_ts_max_date_utc (
      p_ts_code            IN NUMBER,
      p_version_date_utc   IN DATE DEFAULT cwms_util.non_versioned)
      RETURN DATE;

/**
    * Retrieves the latest time series data date in the database for a time series but returns NULL if no records exist in the at_tsv_xxxx table
    *
    * @see constant cwms_util.non_versioned
    *
    * @param p_ts_code          The unique numeric code identifying the time series
    * @param p_version_date_utc The version date of the time series in UTC
    * @param p_year             The optional year to search in; entering this year will speed the query by searching additional tsv tables
    *
    * PL/SQL usage to obtain the max date in the current year
    * CWMS_TS.GET_TS_MAX_DATE_UTC_2(p_ts_code
    *                               , TO_DATE('1111-11-11','YYYY-MM-DD')
    *                               , TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'))
    *                                ) ts_max_date
    *
    * @return The latest time series data date in the database for the time series, in UTC
    */

   FUNCTION get_ts_max_date_utc_2 (
      p_ts_code            IN NUMBER,
      p_version_date_utc   IN DATE DEFAULT cwms_util.non_versioned,
      p_year               IN NUMBER DEFAULT NULL)
      RETURN DATE;      

   /**
    * Retrieves the latest time series data date in the database for a time series
    *
    * @see constant cwms_util.non_versioned
    *
    * @param p_cwms_ts_id   The time series identifier
    * @param p_time_zone    The time zone in which to retrieve the latest time
    * @param p_version_date The version date of the time series in the specified time zone
    * @param p_office_id    The office that owns the time series. If not specified or NULL, the session user's default office is used
    *
    * @return The latest time series data date in the database for the time series, in the specified time zone
    */


   FUNCTION get_ts_max_date (
      p_cwms_ts_id     IN VARCHAR2,
      p_time_zone      IN VARCHAR2 DEFAULT 'UTC',
      p_version_date   IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id      IN VARCHAR2 DEFAULT NULL)
      RETURN DATE;

   /**
    * Retrieves the earliest and latest time series data date in the database for a time series
    *
    * @see constant cwms_util.non_versioned
    *
    * @param p_ts_code          The unique numeric code identifying the time series
    * @param p_min_date_utc     The earliest time series data date in the database for the time series, in UTC
    * @param p_max_date_utc     The latest time series data date in the database for the time series, in UTC
    * @param p_version_date_utc The version date of the time series in UTC
    */
   PROCEDURE get_ts_extents_utc (
      p_min_date_utc          OUT DATE,
      p_max_date_utc          OUT DATE,
      p_ts_code            IN     NUMBER,
      p_version_date_utc   IN     DATE DEFAULT cwms_util.non_versioned);

   /**
    * Retrieves the earliest and latest time series data date in the database for a time series
    *
    * @see constant cwms_util.non_versioned
    *
    * @param p_min_date     The earliest time series data date in the database for the time series, in the specified time zone
    * @param p_max_date     The latest time series data date in the database for the time series, in the specified time zone
    * @param p_cwms_ts_id   The time series identifier
    * @param p_time_zone    The time zone to use
    * @param p_version_date The version date of the time series, in the specified time zone
    * @param p_office_id    The office that owns the time series. If not specified or NULL, the session user's default office is used
    */
   PROCEDURE get_ts_extents (
      p_min_date          OUT DATE,
      p_max_date          OUT DATE,
      p_cwms_ts_id     IN     VARCHAR2,
      p_time_zone      IN     VARCHAR2 DEFAULT 'UTC',
      p_version_date   IN     DATE DEFAULT cwms_util.non_versioned,
      p_office_id      IN     VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves the minimum and maximum values for a time series and a time window
    *
    * @param p_min_value The minium value in the time window, in the specified unit
    * @param p_max_value The maxium value in the time window, in the specified unit
    * @param p_ts_id     The time series identifier
    * @param p_unit      The unit to retrieve the min and max values is
    * @param p_min_date  The start of the time window, in the specified time zone. If not specified or NULL, the time window has no start date, and all data before the end date is considered
    * @param p_max_date  The start of the time window, in the specified time zone. If not specified or NULL, the time window has no end date, and all data after the start date is considered
    * @param p_time_zone The time zone to use. If not specified or NULL, the local time zone of the time series' location is used
    * @param p_office_id The office that owns the time series
    */
   PROCEDURE get_value_extents (p_min_value      OUT BINARY_DOUBLE,
                                p_max_value      OUT BINARY_DOUBLE,
                                p_ts_id       IN     VARCHAR2,
                                p_unit        IN     VARCHAR2,
                                p_min_date    IN     DATE DEFAULT NULL,
                                p_max_date    IN     DATE DEFAULT NULL,
                                p_time_zone   IN     VARCHAR2 DEFAULT NULL,
                                p_office_id   IN     VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves the minimum and maximum values and the times of those values for a time series and a time window
    *
    * @param p_min_value      The minium value in the time window, in the specified unit
    * @param p_max_value      The maxium value in the time window, in the specified unit
    * @param p_min_value_date The date/time of the minimum value
    * @param p_max_value_date The date/time of the maximum value
    * @param p_ts_id          The time series identifier
    * @param p_unit           The unit to retrieve the min and max values is
    * @param p_min_date       The start of the time window, in the specified time zone. If not specified or NULL, the time window has no start date, and all data before the end date is considered
    * @param p_max_date       The start of the time window, in the specified time zone. If not specified or NULL, the time window has no end date, and all data after the start date is considered
    * @param p_time_zone      The time zone to use. If not specified or NULL, the local time zone of the time series' location is used
    * @param p_office_id      The office that owns the time series
    */
   PROCEDURE get_value_extents (
      p_min_value           OUT BINARY_DOUBLE,
      p_max_value           OUT BINARY_DOUBLE,
      p_min_value_date      OUT DATE,
      p_max_value_date      OUT DATE,
      p_ts_id            IN     VARCHAR2,
      p_unit             IN     VARCHAR2,
      p_min_date         IN     DATE DEFAULT NULL,
      p_max_date         IN     DATE DEFAULT NULL,
      p_time_zone        IN     VARCHAR2 DEFAULT NULL,
      p_office_id        IN     VARCHAR2 DEFAULT NULL);

   /**
    * Retrieves a time series of all values for a specified time series that are within
    * a specified value range and time window
    *
    * @param p_ts_id     The time series to retrieve values for
    * @param p_min_value The minimum value of the range. Only values greater than or equal to this value will be retrieved
    * @param p_max_value The maximum value of the range. Only values less than or equal to this value will be retrieved
    * @param p_unit      The unit for the value range and the retrieved values
    * @param p_min_date  The start of the time window. Only values with times greater than or equal to this time will be retrieved
    * @param p_max_date  The end of the time window. Only values with times less than or equal to this time will be retrieved
    * @param p_time_zone The time zone to use for the time window and retrieved value times
    * @param p_office_id The office that owns the time series
    *
    * @return A time series of values that meet the specified criteria. This time series may be irregular interval
    * even if the specified time series is regular interval do to the fact that only time series values meeting the
    * specified criteria are included. May be NULL if no values match criteria.
    */
   FUNCTION get_values_in_range (p_ts_id       IN VARCHAR2,
                                 p_min_value   IN BINARY_DOUBLE,
                                 p_max_value   IN BINARY_DOUBLE,
                                 p_unit        IN VARCHAR2,
                                 p_min_date    IN DATE DEFAULT NULL,
                                 p_max_date    IN DATE DEFAULT NULL,
                                 p_time_zone   IN VARCHAR2 DEFAULT NULL,
                                 p_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN ztsv_array;

   /**
    * Retrieves a time series of all values for a specified time series that are within
    * a specified value range and time window
    *
    * @param p_criteria The time series identifier and criteria to match
    *
    * @return A time series of values that meet the specified criteria. This time series may be irregular interval
    * even if the specified time series is regular interval do to the fact that only time series values meeting the
    * specified criteria are included. May be NULL if no values match criteria.
    */
   FUNCTION get_values_in_range (p_criteria IN time_series_range_t)
      RETURN ztsv_array;

   /**
    * Retrieves a collection of time series that match specified criteria
    *
    * @param p_criteria The time series identifiers and criteria to match
    *
    * @return A collections of time series of values that meet the specified criteria. This time series may be irregular interval
    * even if the specified time series is regular interval do to the fact that only time series values meeting the
    * specified criteria are included. Will be empty, but not NULL, if no values match criteria.
    */
   FUNCTION get_values_in_range (p_criteria IN time_series_range_tab_t)
      RETURN ztsv_array_tab;

   -- not documented
   PROCEDURE trim_ts_deleted_times;

   -- not documented
   PROCEDURE start_trim_ts_deleted_job;

   /**
    * Retrieve the time series associated with the specified parameters.
    *
    * @param p_location_id       The location for the association
    * @param p_association_type  The association type for the assocation
    * @param p_usage_category_id The usage category for the association
    * @param p_usage_id          The usage identifier for the association
    * @param p_office_id         The office owning the association. If NULL or not specified, the office identifier of the session user is used.
    *
    * @return The time series identifier matching the association parameters
    *
    * @since CWMS 2.1
    */
   function get_associated_timeseries(
      p_location_id       in varchar2,
      p_association_type  in varchar2,
      p_usage_category_id in varchar2,
      p_usage_id          in varchar2,
      p_office_id         in varchar2 default null)
      return varchar2;

   /**
    * Sets the current session to retrieve quality codes as unsigned quantities. Quality codes
    * are 32-bit masks, with specific bits representing specific portions of the overall quality.
    * As such, they are neither inherently signed nor unsigned.  They are represented in the
    * database as unsigned values. Since Java has no unsigned 32-bit data type the default
    * representation of quality codes as returned by RETRIEVE_TS is signed.
    */
   procedure set_retrieve_unsigned_quality;

   /**
    * Sets the current session to retrieve quality codes as signed quantities. Quality codes
    * are 32-bit masks, with specific bits representing specific portions of the overall quality.
    * As such, they are neither inherently signed nor unsigned.  They are represented in the
    * database as unsigned values. Since Java has no unsigned 32-bit data type the default
    * representation of quality codes as returned by RETRIEVE_TS is signed.
    */
   procedure set_retrieve_signed_quality;

   /**
    * Normalizes the specified quality code to as igned or unsigned quantity depending on
    * current session settings. Quality codes are 32-bit masks, with specific bits representing
    * specific portions of the overall quality.  As such, they are neither inherently signed nor
    * unsigned.  They are represented in the database as unsigned values. Since Java has no
    * unsigned 32-bit data type the default representation of quality codes as returned by RETRIEVE_TS
    * is signed.
    *
    * @param p_quality the quality code to normalize
    *
    * @return the normalized quality code
    *
    * @since CWMS2.1
    * @see set_retrieve_unsigned_quality
    * @see set_retrieve_signed_quality
    */
   function normalize_quality(
      p_quality in number)
      return number
      result_cache;  
      
   /**
    * Sets the default storage policy for an office for time series data that contains null values with non-missing quality codes.
    *
    * @param p_storage_policy The storage policy. Must be NULL or one of filter_out_null_values, set_null_values_to_missing, or reject_ts_with_null_values. If NULL, any office storage policy is removed and the database default is in effect.
    * @param p_office_id      The text identifier of the office to set the policy for.  If unspecified or NULL, the current session user's default office is used.
    *
    * @since CWMS 2.1
    * @see constant filter_out_null_values
    * @see constant set_null_values_to_missing
    * @see constant reject_ts_with_null_values
    */
   procedure set_nulls_storage_policy_ofc(
      p_storage_policy in integer,
      p_office_id      in varchar2 default null);
      
   /**
    * Sets the storage policy for specified time series for time series data that contains null values with non-missing quality codes.
    *
    * @param p_storage_policy The storage policy. Must be NULL or one of filter_out_null_values, set_null_values_to_missing, or reject_ts_with_null_values. If NULL, any time series policy is removed and the office default is in effect.
    * @param p_ts_id          The time series identifier to set the policy for.
    * @param p_office_id      The text identifier of the office that owns the time series.  If unspecified or NULL, the current session user's default office is used.
    *
    * @since CWMS 2.1
    * @see constant filter_out_null_values
    * @see constant set_null_values_to_missing
    * @see constant reject_ts_with_null_values
    */
   procedure set_nulls_storage_policy_ts(
      p_storage_policy in integer,
      p_ts_id          in varchar2,
      p_office_id      in varchar2 default null);
      
   /**
    * Retrieves the default storage policy for an office for time series data that contains null values with non-missing quality codes.
    *
    * @param p_office_id  The text identifier of the office to retrieve the policy for.  If unspecified or NULL, the current session user's default office is used.
    *
    * @return The default storage policy for the specified office.  If NULL, the database default is in effect.
    *
    * @since CWMS 2.1
    * @see constant filter_out_null_values
    * @see constant set_null_values_to_missing
    * @see constant reject_ts_with_null_values
    */
   function get_nulls_storage_policy_ofc(
      p_office_id in varchar2 default null)
      return integer;                  
      
   /**
    * Retrieves the storage policy for specified time series for time series data that contains null values with non-missing quality codes.
    *
    * @param p_ts_id     The time series identifier to retrieve the policy for.
    * @param p_office_id The text identifier of the office that owns the time series.  If unspecified or NULL, the current session user's default office is used.
    *
    * @return The default storage policy for the specified time series.  If NULL, the office default is in effect.
    *
    * @since CWMS 2.1
    * @see constant filter_out_null_values
    * @see constant set_null_values_to_missing
    * @see constant reject_ts_with_null_values
    */
   function get_nulls_storage_policy_ts(
      p_ts_id     in varchar2,
      p_office_id in varchar2 default null)
      return integer;
      
   /**
    * Retrieves the effective storage policy for specified time series for time series data that contains null values with non-missing quality codes.
    *
    * @param p_ts_code The numeric code identifying the time series to retrieve the effective policy for.
    *
    * @return The effective storage policy for the specified time series.  If the time series has a policy, it is returned.  If not, the office default policy is returned. If that is not set, the database defatul is returned.
    *
    * @since CWMS 2.1
    * @see constant filter_out_null_values
    * @see constant set_null_values_to_missing
    * @see constant reject_ts_with_null_values
    */
   function get_nulls_storage_policy(
      p_ts_code in integer)
      return integer;
                           
END;
/

SHOW ERRORS;
COMMIT;
set define on
define cwms_schema = CWMS_20
prompt update for package body cwms_ts
/* Formatted on 1/18/2012 2:59:32 PM (QP5 v5.185.11230.41888) */

create or replace package BODY cwms_ts
AS
   FUNCTION get_max_open_cursors
      RETURN INTEGER
   IS
      l_max_open_cursors   INTEGER;
   BEGIN
      SELECT VALUE
        INTO l_max_open_cursors
        FROM v$parameter
       WHERE name = 'open_cursors';

      RETURN l_max_open_cursors;
   END get_max_open_cursors;

   --********************************************************************** -
   --
   -- get_ts_code returns ts_code...
   --
   FUNCTION get_ts_code (p_cwms_ts_id     IN VARCHAR2,
                         p_db_office_id   IN VARCHAR2)
      RETURN NUMBER
   IS
      l_ts_code   NUMBER := NULL;
   BEGIN
      RETURN get_ts_code (
                p_cwms_ts_id       => p_cwms_ts_id,
                p_db_office_code   => cwms_util.get_db_office_code (
                                        p_db_office_id));
   END get_ts_code;

   function get_ts_code (
      p_cwms_ts_id     in varchar2,
      p_db_office_code in number)
      return number
   is
      l_office_id    varchar2(16) := cwms_util.get_db_office_id_from_code(p_db_office_code);
      l_cwms_ts_code number;
   begin
      begin
         select ts_code
           into l_cwms_ts_code
           from at_cwms_ts_id
          where upper(cwms_ts_id) = upper(get_cwms_ts_id(trim(p_cwms_ts_id), l_office_id))
            and db_office_code = p_db_office_code;
      exception
         when no_data_found then
            cwms_err.raise (
               'TS_ID_NOT_FOUND', 
               trim (p_cwms_ts_id),
               l_office_id); 
      end;
      return l_cwms_ts_code;
   end get_ts_code;

   ---------------------------------------------------------------------------

   FUNCTION get_ts_id (p_ts_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_cwms_ts_id   VARCHAR2 (183);
   BEGIN
      BEGIN
         SELECT cwms_ts_id
           INTO l_cwms_ts_id
           FROM at_cwms_ts_id
          WHERE ts_code = p_ts_code;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            SELECT cwms_ts_id
              INTO l_cwms_ts_id
              FROM at_cwms_ts_id
             WHERE ts_code = p_ts_code;
      END;

      RETURN l_cwms_ts_id;
   END;

   function clean_ts_id(
      p_ts_id in varchar2)
      return varchar2
   is
      l_parts str_tab_t;
      l_ts_id varchar2(183);
   begin
      l_parts := cwms_util.split_text(p_ts_id, '.');
      for i in 1..l_parts.count loop
         l_parts(i) := cwms_util.strip(l_parts(i));
      end loop;                                    
      l_ts_id := cwms_util.join_text(l_parts, '.');
      if length(l_ts_id) != length(p_ts_id) then
         cwms_msg.log_db_message(
            'CWMS_TS.CLEAN_TS_ID', 
            cwms_msg.msg_level_normal, 
            'Cleaned invalid TSID: '||p_ts_id); 
      end if;
      return l_ts_id;
   end clean_ts_id;
   
   --******************************************************************************/
   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_CWMS_TS_ID -
   --
   function get_cwms_ts_id (
      p_cwms_ts_id   in varchar2,
      p_office_id    in varchar2)
      return varchar2
   is
      l_cwms_ts_id varchar2(183);
      l_parts      str_tab_t;
   begin
      -----------
      -- as is --
      -----------
      begin
         select cwms_ts_id
           into l_cwms_ts_id
           from at_cwms_ts_id
          where upper(cwms_ts_id) = upper(p_cwms_ts_id)
            and upper(db_office_id) = upper(p_office_id);
      exception
         when no_data_found then
            ----------------------------
            -- try time series alias  --
            -- (will try loc aliases) --
            ----------------------------
            l_cwms_ts_id := cwms_ts.get_ts_id_from_alias(p_cwms_ts_id, null, null, p_office_id);
      end;
      if l_cwms_ts_id is null then
         l_cwms_ts_id := p_cwms_ts_id;
      end if;
      return l_cwms_ts_id;
   end;

   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_DB_UNIT_ID -
   --
   FUNCTION get_db_unit_id (p_cwms_ts_id IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_base_location_id    at_base_location.base_location_id%TYPE;
      l_sub_location_id     at_physical_location.sub_location_id%TYPE;
      l_base_parameter_id   cwms_base_parameter.base_parameter_id%TYPE;
      l_sub_parameter_id    at_parameter.sub_parameter_id%TYPE;
      l_parameter_type_id   cwms_parameter_type.parameter_type_id%TYPE;
      l_interval_id         cwms_interval.interval_id%TYPE;
      l_duration_id         cwms_duration.duration_id%TYPE;
      l_version_id          at_cwms_ts_spec.VERSION%TYPE;
      l_db_unit_id          cwms_unit.unit_id%TYPE;
   BEGIN
      parse_ts (p_cwms_ts_id,
                l_base_location_id,
                l_sub_location_id,
                l_base_parameter_id,
                l_sub_parameter_id,
                l_parameter_type_id,
                l_interval_id,
                l_duration_id,
                l_version_id);

      --
      SELECT unit_id
        INTO l_db_unit_id
        FROM cwms_unit cu, cwms_base_parameter cbp
       WHERE     cu.unit_code = cbp.unit_code
             AND cbp.base_parameter_id = l_base_parameter_id;

      --
      RETURN l_db_unit_id;
   END;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_TIME_ON_AFTER_INTERVAL - if p_datetime is on the interval, than
   --      p_datetime is returned, if p_datetime is off of the interval, than
   --      the first datetime after p_datetime is returned.
   --
   --      Function is usable down to 1 minute.
   --
   --      All offsets stored in the database are in minutes. --
   --      p_ts_offset and p_ts_interval are passed in as minutes --
   --      p_datetime is assumed to be in UTC --
   --
   --      Weekly intervals - the weekly interval starts with Sunday.
   --
   ----------------------------------------------------------------------------
   --

   FUNCTION get_time_on_after_interval (p_datetime      IN DATE,
                                        p_ts_offset     IN NUMBER, -- in minutes.
                                        p_ts_interval   IN NUMBER -- in minutes.
                                                                 )
      RETURN DATE
   IS
      l_datetime_tmp          DATE;
      l_normalized_datetime   DATE;
      l_tmp                   NUMBER;
      l_delta                 BINARY_INTEGER;
      l_multiplier            BINARY_INTEGER;
      l_mod                   BINARY_INTEGER;
      l_ts_interval           BINARY_INTEGER := TRUNC (p_ts_interval, 0);
   BEGIN
      DBMS_APPLICATION_INFO.set_module (
         'create_ts',
         'Function get_Time_On_After_Interval');

      -- Basic checks - interval cannot be zero - irregular...
      IF l_ts_interval <= 0
      THEN
         cwms_err.RAISE ('ERROR', 'Interval must be > zero.');
      END IF;

      -- Basic checks - offset cannot ve >= to interval...
      IF p_ts_offset >= l_ts_interval
      THEN
         cwms_err.RAISE ('ERROR', 'Offset cannot be >= to the Interval');
      END IF;

      --
      l_normalized_datetime :=
         TRUNC (p_datetime, 'MI') - (p_ts_offset / min_in_dy);

      IF p_ts_interval = 1
      THEN
         NULL;                                             -- nothing to do...
      ELSIF l_ts_interval < min_in_wk             -- intervals less than a week...
      THEN
         l_delta := (l_normalized_datetime - cwms_util.l_epoch) * min_in_dy;
         l_mod := MOD (l_delta, l_ts_interval);

         IF l_mod <= 0
         THEN
            l_normalized_datetime :=
               l_normalized_datetime - (l_mod / min_in_dy);
         ELSE
            l_normalized_datetime :=
               l_normalized_datetime + (l_ts_interval - l_mod) / min_in_dy;
         END IF;
      ELSIF l_ts_interval = min_in_wk                        -- weekly interval...
      THEN
         l_delta :=
            (l_normalized_datetime - cwms_util.l_epoch_wk_dy_1) * min_in_dy;
         l_mod := MOD (l_delta, l_ts_interval);

         IF l_mod <= 0
         THEN
            l_normalized_datetime :=
               l_normalized_datetime - (l_mod / min_in_dy);
         ELSE
            l_normalized_datetime :=
               l_normalized_datetime + (l_ts_interval - l_mod) / min_in_dy;
         END IF;
      ELSIF l_ts_interval = min_in_mo                       -- monthly interval...
      THEN
         l_datetime_tmp := TRUNC (l_normalized_datetime, 'Month');

         IF l_datetime_tmp != l_normalized_datetime
         THEN
            l_normalized_datetime := ADD_MONTHS (l_datetime_tmp, 1);
         END IF;
      ELSIF l_ts_interval = min_in_yr                       -- yearly interval...
      THEN
         l_datetime_tmp := TRUNC (l_normalized_datetime, 'YEAR');

         IF l_datetime_tmp != l_normalized_datetime
         THEN
            l_normalized_datetime := ADD_MONTHS (l_datetime_tmp, 12);
         END IF;
      ELSIF l_ts_interval = min_in_dc                     -- decadal interval...
      THEN
         l_mod :=
            MOD (TO_NUMBER (TO_CHAR (l_normalized_datetime, 'YYYY')), 10);
         l_datetime_tmp :=
            ADD_MONTHS (TRUNC (l_normalized_datetime, 'YEAR'),
                        - (l_mod * 12));

         IF l_datetime_tmp != l_normalized_datetime
         THEN
            l_normalized_datetime := ADD_MONTHS (l_datetime_tmp, 120);
         END IF;
      ELSE
         cwms_err.RAISE (
            'ERROR',
               l_ts_interval
            || ' minutes is not a valid/supported CWMS interval');
      END IF;

      RETURN l_normalized_datetime + (p_ts_offset / min_in_dy);
      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   END get_time_on_after_interval;

   --
   --  See get_time_on_after_interval for description/comments/etc...
   --
   FUNCTION get_time_on_before_interval (p_datetime      IN DATE,
                                         p_ts_offset     IN NUMBER,
                                         p_ts_interval   IN NUMBER)
      RETURN DATE
   IS
      l_datetime_tmp          DATE;
      l_normalized_datetime   DATE;
      l_tmp                   NUMBER;
      l_delta                 BINARY_INTEGER;
      l_multiplier            BINARY_INTEGER;
      l_mod                   BINARY_INTEGER;
      l_ts_interval           BINARY_INTEGER := TRUNC (p_ts_interval, 0);
   BEGIN
      DBMS_APPLICATION_INFO.set_module (
         'create_ts',
         'Function get_Time_On_Before_Interval');

      -- Basic checks - interval cannot be zero - irregular...
      IF l_ts_interval <= 0
      THEN
         cwms_err.RAISE ('ERROR', 'Interval must be > zero.');
      END IF;

      -- Basic checks - offset cannot ve >= to interval...
      IF p_ts_offset >= l_ts_interval
      THEN
         cwms_err.RAISE ('ERROR', 'Offset cannot be >= to the Interval');
      END IF;

      --
      l_normalized_datetime :=
         TRUNC (p_datetime, 'MI') - (p_ts_offset / min_in_dy);

      IF p_ts_interval = 1
      THEN
         NULL;                                             -- nothing to do...
      ELSIF l_ts_interval < min_in_wk             -- intervals less than a week...
      THEN
         l_delta := (l_normalized_datetime - cwms_util.l_epoch) * min_in_dy;
         l_mod := MOD (l_delta, l_ts_interval);

         IF l_mod < 0
         THEN
            l_normalized_datetime :=
               l_normalized_datetime - (l_ts_interval + l_mod) / min_in_dy;
         ELSE
            l_normalized_datetime :=
               l_normalized_datetime - (l_mod / min_in_dy);
         END IF;
      ELSIF l_ts_interval = min_in_wk                        -- weekly interval...
      THEN
         l_delta :=
            (l_normalized_datetime - cwms_util.l_epoch_wk_dy_1) * min_in_dy;
         l_mod := MOD (l_delta, l_ts_interval);

         IF l_mod < 0
         THEN
            l_normalized_datetime :=
               l_normalized_datetime - (l_ts_interval + l_mod) / min_in_dy;
         ELSE
            l_normalized_datetime :=
               l_normalized_datetime - (l_mod / min_in_dy);
         END IF;
      ELSIF l_ts_interval = min_in_mo                       -- monthly interval...
      THEN
         l_normalized_datetime := TRUNC (l_normalized_datetime, 'Month');
      ELSIF l_ts_interval = min_in_yr                       -- yearly interval...
      THEN
         l_normalized_datetime := TRUNC (l_normalized_datetime, 'YEAR');
      ELSIF l_ts_interval = min_in_dc                     -- decadal interval...
      THEN
         l_mod :=
            MOD (TO_NUMBER (TO_CHAR (l_normalized_datetime, 'YYYY')), 10);
         l_normalized_datetime :=
            ADD_MONTHS (TRUNC (l_normalized_datetime, 'YEAR'),
                        - (l_mod * 12));
      ELSE
         cwms_err.RAISE (
            'ERROR',
               l_ts_interval
            || ' minutes is not a valid/supported CWMS interval');
      END IF;

      RETURN l_normalized_datetime + (p_ts_offset / min_in_dy);
      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   END get_time_on_before_interval;



   FUNCTION get_location_id (p_cwms_ts_id     IN VARCHAR2,
                             p_db_office_id   IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN get_location_id (
                p_cwms_ts_code => get_ts_code (
                                    p_cwms_ts_id       => p_cwms_ts_id,
                                    p_db_office_code   => cwms_util.get_db_office_code (
                                                            p_office_id => p_db_office_id)));
   END;


   FUNCTION get_location_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_location_id   VARCHAR2 (49);
   BEGIN
      BEGIN
         SELECT location_id
           INTO l_location_id
           FROM at_cwms_ts_id
          WHERE ts_code = p_cwms_ts_code;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            SELECT location_id
              INTO l_location_id
              FROM at_cwms_ts_id
             WHERE ts_code = p_cwms_ts_code;
      END;
      
      RETURN l_location_id;
   END;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_PARAMETER_CODE -
   --
   FUNCTION get_parameter_code (
      p_base_parameter_id   IN VARCHAR2,
      p_sub_parameter_id    IN VARCHAR2,
      p_office_id           IN VARCHAR2 DEFAULT NULL,
      p_create              IN VARCHAR2 DEFAULT 'T')
      RETURN NUMBER
   IS
      l_base_parameter_code   NUMBER;
   BEGIN
      SELECT base_parameter_code
        INTO l_base_parameter_code
        FROM cwms_base_parameter
       WHERE UPPER (base_parameter_id) = UPPER (p_base_parameter_id);

      --dbms_output.put_line(l_base_parameter_code);
      --
      RETURN get_parameter_code (l_base_parameter_code,
                                 p_sub_parameter_id,
                                 cwms_util.get_db_office_code (p_office_id),
                                 cwms_util.return_true_or_false (p_create));
   END;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_DISPLAY_PARAMETER_CODE -
   --
   FUNCTION get_display_parameter_code (
      p_base_parameter_id   IN VARCHAR2,
      p_sub_parameter_id    IN VARCHAR2,
      p_office_id           IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER
   IS
      l_display_parameter_code   NUMBER := NULL;
      l_parameter_code           NUMBER := NULL;
      l_count                    INTEGER;
   BEGIN
      l_parameter_code :=
         get_parameter_code (p_base_parameter_id,
                             p_sub_parameter_id,
                             p_office_id,
                             'F');

      SELECT COUNT (*)
        INTO l_count
        FROM at_display_units
       WHERE parameter_code = l_parameter_code;

      IF l_count = 0
      THEN
         l_parameter_code :=
            get_parameter_code (p_base_parameter_id, NULL, p_office_id);

         SELECT COUNT (*)
           INTO l_count
           FROM at_display_units
          WHERE parameter_code = l_parameter_code;

         IF l_count > 0
         THEN
            l_display_parameter_code := l_parameter_code;
         END IF;
      ELSE
         l_display_parameter_code := l_parameter_code;
      END IF;

      RETURN l_display_parameter_code;
   END;

   FUNCTION get_display_parameter_code2 (
      p_base_parameter_id   IN VARCHAR2,
      p_sub_parameter_id    IN VARCHAR2,
      p_office_id           IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER
   IS
      invalid_param_id           EXCEPTION;
      PRAGMA EXCEPTION_INIT (invalid_param_id, -20006);
      l_display_parameter_code   NUMBER;
   BEGIN
      BEGIN
         l_display_parameter_code :=
            get_display_parameter_code (p_base_parameter_id,
                                        p_sub_parameter_id,
                                        p_office_id);
      EXCEPTION
         WHEN invalid_param_id
         THEN
            NULL;
      END;

      RETURN l_display_parameter_code;
   END get_display_parameter_code2;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_PARAMETER_CODE -
   --
   FUNCTION get_parameter_code (
      p_base_parameter_code   IN NUMBER,
      p_sub_parameter_id      IN VARCHAR2,
      p_office_code           IN NUMBER,
      p_create                IN BOOLEAN DEFAULT TRUE)
      RETURN NUMBER
   IS
      l_parameter_code      NUMBER;
      l_base_parameter_id   cwms_base_parameter.base_parameter_id%TYPE;
      l_office_code         NUMBER
         := NVL (p_office_code, cwms_util.user_office_code);
      l_office_id           VARCHAR2 (16);
   BEGIN
      BEGIN
         IF p_sub_parameter_id IS NOT NULL
         THEN
            SELECT parameter_code
              INTO l_parameter_code
              FROM at_parameter ap
             WHERE     base_parameter_code = p_base_parameter_code
                   AND db_office_code IN
                          (p_office_code, cwms_util.db_office_code_all)
                   AND UPPER (sub_parameter_id) = UPPER (p_sub_parameter_id);
         ELSE
            SELECT parameter_code
              INTO l_parameter_code
              FROM at_parameter ap
             WHERE     base_parameter_code = p_base_parameter_code
                   AND ap.sub_parameter_id IS NULL
                   AND db_office_code IN (cwms_util.db_office_code_all);
         END IF;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN                                   -- Insert new sub_parameter...
            IF p_create OR p_create IS NULL
            THEN
               INSERT INTO at_parameter (parameter_code,
                                         db_office_code,
                                         base_parameter_code,
                                         sub_parameter_id)
                    VALUES (cwms_seq.NEXTVAL,
                            p_office_code,
                            p_base_parameter_code,
                            p_sub_parameter_id)
                 RETURNING parameter_code
                      INTO l_parameter_code;
            ELSE
               SELECT office_id
                 INTO l_office_id
                 FROM cwms_office
                WHERE office_code = l_office_code;

               SELECT base_parameter_id
                 INTO l_base_parameter_id
                 FROM cwms_base_parameter
                WHERE base_parameter_code = p_base_parameter_code;

               cwms_err.RAISE (
                  'INVALID_PARAM_ID',
                     l_office_id
                  || '/'
                  || cwms_util.concat_base_sub_id (l_base_parameter_id,
                                                   p_sub_parameter_id));
            END IF;
      END;

      RETURN l_parameter_code;
   END get_parameter_code;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_PARAMETER_CODE -
   --
   FUNCTION get_parameter_code (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER
   IS
      l_parameter_code   NUMBER := NULL;
   BEGIN
      SELECT parameter_code
        INTO l_parameter_code
        FROM at_cwms_ts_spec
       WHERE ts_code = p_cwms_ts_code;

      RETURN l_parameter_code;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise ('INVALID_ITEM',
                         '' || NVL (p_cwms_ts_code, 'NULL'),
                         'CWMS time series code.');
   END get_parameter_code;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_PARAMETER_ID -
   --
   FUNCTION get_parameter_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_parameter_row   at_parameter%ROWTYPE;
      l_parameter_id    VARCHAR2 (49) := NULL;
   BEGIN
      SELECT *
        INTO l_parameter_row
        FROM at_parameter
       WHERE parameter_code = get_parameter_code (p_cwms_ts_code);

      SELECT base_parameter_id
        INTO l_parameter_id
        FROM cwms_base_parameter
       WHERE base_parameter_code = l_parameter_row.base_parameter_code;

      IF l_parameter_row.sub_parameter_id IS NOT NULL
      THEN
         l_parameter_id :=
            l_parameter_id || '-' || l_parameter_row.sub_parameter_id;
      END IF;

      RETURN l_parameter_id;
   END get_parameter_id;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_BASE_PARAMETER_CODE -
   --
   FUNCTION get_base_parameter_code (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER
   IS
      l_base_parameter_code   NUMBER (10) := NULL;
   BEGIN
      SELECT base_parameter_code
        INTO l_base_parameter_code
        FROM at_parameter
       WHERE parameter_code = get_parameter_code (p_cwms_ts_code);

      RETURN l_base_parameter_code;
   END get_base_parameter_code;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_BASE_PARAMETER_ID -
   --
   FUNCTION get_base_parameter_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_base_parameter_id   VARCHAR2 (16) := NULL;
   BEGIN
      SELECT base_parameter_id
        INTO l_base_parameter_id
        FROM cwms_base_parameter
       WHERE base_parameter_code = get_base_parameter_code (p_cwms_ts_code);

      RETURN l_base_parameter_id;
   END get_base_parameter_id;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_PARAMETER_TYPE_CODE -
   --
   FUNCTION get_parameter_type_code (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER
   IS
      l_parameter_type_code   NUMBER := NULL;
   BEGIN
      SELECT parameter_type_code
        INTO l_parameter_type_code
        FROM at_cwms_ts_spec
       WHERE ts_code = p_cwms_ts_code;

      RETURN l_parameter_type_code;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise ('INVALID_ITEM',
                         '' || NVL (p_cwms_ts_code, 'NULL'),
                         'CWMS time series code.');
   END get_parameter_type_code;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_PARAMETER_TYPE_ID -
   --
   FUNCTION get_parameter_type_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_parameter_type_id   VARCHAR2 (16) := NULL;
   BEGIN
      SELECT parameter_type_id
        INTO l_parameter_type_id
        FROM cwms_parameter_type
       WHERE parameter_type_code = get_parameter_type_code (p_cwms_ts_code);

      RETURN l_parameter_type_id;
   END get_parameter_type_id;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_DB_OFFICE_CODE -
   --
   FUNCTION get_db_office_code (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER
   IS
      l_db_office_code   at_base_location.db_office_code%TYPE := NULL;
   BEGIN
      SELECT db_office_code
        INTO l_db_office_code
        FROM at_base_location bl, at_physical_location pl, at_cwms_ts_spec ts
       WHERE     ts.ts_code = p_cwms_ts_code
             AND pl.location_code = ts.location_code
             AND bl.base_location_code = pl.base_location_code;

      RETURN l_db_office_code;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise ('INVALID_ITEM',
                         '' || NVL (p_cwms_ts_code, 'NULL'),
                         'CWMS time series code.');
   END get_db_office_code;

   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_DB_OFFICE_ID -
   --
   FUNCTION get_db_office_id (p_cwms_ts_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_db_office_id   cwms_office.office_id%TYPE := NULL;
   BEGIN
      SELECT office_id
        INTO l_db_office_id
        FROM cwms_office
       WHERE office_code = get_db_office_code (p_cwms_ts_code);

      RETURN l_db_office_id;
   END get_db_office_id;


   PROCEDURE update_ts_id (
      p_ts_code                  IN NUMBER,
      p_interval_utc_offset      IN NUMBER DEFAULT NULL,        -- in minutes.
      p_snap_forward_minutes     IN NUMBER DEFAULT NULL,
      p_snap_backward_minutes    IN NUMBER DEFAULT NULL,
      p_local_reg_time_zone_id   IN VARCHAR2 DEFAULT NULL,
      p_ts_active_flag           IN VARCHAR2 DEFAULT NULL)
   IS
      l_ts_interval                 NUMBER;
      l_interval_utc_offset_old     NUMBER;
      l_interval_utc_offset_new     NUMBER;
      l_snap_forward_minutes_new    NUMBER;
      l_snap_forward_minutes_old    NUMBER;
      l_snap_backward_minutes_new   NUMBER;
      l_snap_backward_minutes_old   NUMBER;
      l_time_zone_code_old          NUMBER;
      l_time_zone_code_new          NUMBER;
      l_ts_active_new               VARCHAR2 (1) := UPPER (p_ts_active_flag);
      l_ts_active_old               VARCHAR2 (1);
      l_tmp                         NUMBER := NULL;
   BEGIN
      --
      --
      BEGIN
         SELECT a.interval_utc_offset,
                a.interval_backward,
                a.interval_forward,
                a.active_flag,
                a.time_zone_code,
                b.INTERVAL
           INTO l_interval_utc_offset_old,
                l_snap_backward_minutes_old,
                l_snap_forward_minutes_old,
                l_ts_active_old,
                l_time_zone_code_old,
                l_ts_interval
           FROM at_cwms_ts_spec a, cwms_interval b
          WHERE a.interval_code = b.interval_code AND a.ts_code = p_ts_code;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
      END;

      --
      IF l_ts_active_new IS NULL
      THEN
         l_ts_active_new := l_ts_active_old;
      ELSE
         IF l_ts_active_new NOT IN ('T', 'F')
         THEN
            cwms_err.RAISE ('INVALID_T_F_FLAG', 'p_ts_active_flag');
         END IF;
      END IF;

      --
      IF p_interval_utc_offset IS NULL
      THEN
         l_interval_utc_offset_new := l_interval_utc_offset_old;
      ELSE
         --
         -- Are interval utc offset set and if so is it a valid offset?.
         --
         IF l_ts_interval = 0
         THEN
            IF    p_interval_utc_offset IS NOT NULL
               OR p_interval_utc_offset != cwms_util.utc_offset_irregular
            THEN
               cwms_err.RAISE ('INVALID_UTC_OFFSET',
                               p_interval_utc_offset,
                               'Irregular');
            ELSE
               l_interval_utc_offset_new := cwms_util.utc_offset_irregular;
            END IF;
         ELSE
            IF p_interval_utc_offset = cwms_util.utc_offset_undefined
            THEN
               l_interval_utc_offset_new := cwms_util.utc_offset_undefined;
            ELSE
               IF     p_interval_utc_offset >= 0
                  AND p_interval_utc_offset < l_ts_interval
               THEN
                  l_interval_utc_offset_new := p_interval_utc_offset;
               ELSE
                  cwms_err.RAISE ('INVALID_UTC_OFFSET',
                                  p_interval_utc_offset,
                                  l_ts_interval);
               END IF;
            END IF;

            --
            -- check if the utc offset is being changed and can it be changed.
            --
            IF     l_interval_utc_offset_old !=
                      cwms_util.utc_offset_undefined
               AND l_interval_utc_offset_old != l_interval_utc_offset_new
            THEN -- need to check if this ts_code already holds data, if it does
               -- then can't change interval_utc_offset.
               SELECT COUNT (*)
                 INTO l_tmp
                 FROM av_tsv
                WHERE ts_code = p_ts_code;

               IF l_tmp > 0
               THEN
                  cwms_err.RAISE ('CANNOT_CHANGE_OFFSET',
                                  get_ts_id (p_ts_code));
               END IF;
            END IF;
         END IF;
      END IF;

      --
      -- Set snap back/forward..
      ----
      ---- Confirm that snap back/forward times are valid....
      ----
      IF    l_interval_utc_offset_new != cwms_util.utc_offset_undefined
         OR l_interval_utc_offset_new != cwms_util.utc_offset_irregular
      THEN
         IF    p_snap_forward_minutes IS NOT NULL
            OR p_snap_backward_minutes IS NOT NULL
         THEN
            l_snap_forward_minutes_new := NVL (p_snap_forward_minutes, 0);
            l_snap_backward_minutes_new := NVL (p_snap_backward_minutes, 0);

            IF l_snap_forward_minutes_new + l_snap_backward_minutes_new >=
                  l_ts_interval
            THEN
               cwms_err.RAISE ('INVALID_SNAP_WINDOW');
            END IF;
         ELSE
            l_snap_forward_minutes_new := l_snap_forward_minutes_old;
            l_snap_backward_minutes_new := l_snap_backward_minutes_old;
         END IF;
      ELSE
         l_snap_forward_minutes_new := NULL;
         l_snap_backward_minutes_new := NULL;
      END IF;

      --
      IF p_local_reg_time_zone_id IS NULL
      THEN
         l_time_zone_code_new := l_time_zone_code_old;
      ELSE
         l_time_zone_code_new :=
            cwms_util.get_time_zone_code (p_local_reg_time_zone_id);
      END IF;

      --
      UPDATE at_cwms_ts_spec a
         SET a.interval_utc_offset = l_interval_utc_offset_new,
             a.interval_forward = l_snap_forward_minutes_new,
             a.interval_backward = l_snap_backward_minutes_new,
             a.time_zone_code = l_time_zone_code_new,
             a.active_flag = l_ts_active_new
       WHERE a.ts_code = p_ts_code;
   --
   --
   END;



   PROCEDURE update_ts_id (
      p_cwms_ts_id               IN VARCHAR2,
      p_interval_utc_offset      IN NUMBER DEFAULT NULL,        -- in minutes.
      p_snap_forward_minutes     IN NUMBER DEFAULT NULL,
      p_snap_backward_minutes    IN NUMBER DEFAULT NULL,
      p_local_reg_time_zone_id   IN VARCHAR2 DEFAULT NULL,
      p_ts_active_flag           IN VARCHAR2 DEFAULT NULL,
      p_db_office_id             IN VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      update_ts_id (
         p_ts_code                  => get_ts_code (
                                         p_cwms_ts_id       => p_cwms_ts_id,
                                         p_db_office_code   => cwms_util.get_db_office_code (
                                                                 p_db_office_id)),
         p_interval_utc_offset      => p_interval_utc_offset,
         -- in minutes.
         p_snap_forward_minutes     => p_snap_forward_minutes,
         p_snap_backward_minutes    => p_snap_backward_minutes,
         p_local_reg_time_zone_id   => p_local_reg_time_zone_id,
         p_ts_active_flag           => p_ts_active_flag);
   END;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- SET_TS_TIME_ZONE -
   --
   PROCEDURE set_ts_time_zone (p_ts_code          IN NUMBER,
                               p_time_zone_name   IN VARCHAR2)
   IS
      l_time_zone_name   VARCHAR2 (28) := NVL (p_time_zone_name, 'UTC');
      l_time_zone_code   NUMBER;
      l_interval_val     NUMBER;
      l_tz_offset        NUMBER;
      l_office_id        VARCHAR2 (16);
      l_tsid             VARCHAR2 (193);
      l_query            VARCHAR2 (32767);
   BEGIN
      IF p_time_zone_name IS NULL
      THEN
         l_time_zone_code := NULL;
      ELSE
         BEGIN
            SELECT time_zone_code
              INTO l_time_zone_code
              FROM mv_time_zone
             WHERE UPPER (time_zone_name) = UPPER (p_time_zone_name);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               cwms_err.raise ('INVALID_ITEM',
                               p_time_zone_name,
                               'time zone name');
         END;
      END IF;

      SELECT interval
        INTO l_interval_val
        FROM at_cwms_ts_spec ts, cwms_interval i
       WHERE ts.ts_code = p_ts_code AND i.interval_code = ts.interval_code;

      IF l_interval_val > 60
      THEN
         BEGIN   
            l_query := REPLACE (
               'select distinct mod(round((cast((cast(date_time as timestamp) at time zone ''$tz'') as date)
                                   - trunc(cast((cast(date_time as timestamp) at time zone ''$tz'') as date)))
                                   * 1440, 0), :a)
                  from (select distinct date_time
                          from av_tsv_dqu
                         where ts_code = :b
                       )',
                       '$tz',
                       l_time_zone_name);
                       
            cwms_util.check_dynamic_sql(l_query);
                                    
            EXECUTE IMMEDIATE l_query               
               INTO l_tz_offset
               USING l_interval_val, p_ts_code;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
            WHEN TOO_MANY_ROWS
            THEN
               SELECT cwms_ts_id, db_office_id
                 INTO l_tsid, l_office_id
                 FROM at_cwms_ts_id
                WHERE ts_code = p_ts_code;

               cwms_err.raise (
                  'ERROR',
                     'Cannot set '
                  || l_office_id
                  || '.'
                  || l_tsid
                  || ' to time zone '
                  || NVL (p_time_zone_name, 'NULL')
                  || '.  Existing data does not conform to time zone.');
         END;
      END IF;

      UPDATE at_cwms_ts_spec
         SET time_zone_code = l_time_zone_code
       WHERE ts_code = p_ts_code;
   END set_ts_time_zone;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- set_tsid_time_zone -
   --
   PROCEDURE set_tsid_time_zone (p_ts_id            IN VARCHAR2,
                                 p_time_zone_name   IN VARCHAR2,
                                 p_office_id        IN VARCHAR2 DEFAULT NULL)
   IS
      l_ts_code     NUMBER;
      l_office_id   VARCHAR2 (16)
                       := NVL (p_office_id, cwms_util.user_office_id);
   BEGIN
      BEGIN
         SELECT ts_code
           INTO l_ts_code
           FROM at_cwms_ts_id
          WHERE     UPPER (cwms_ts_id) = UPPER (p_ts_id)
                AND UPPER (db_office_id) = UPPER (l_office_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise ('INVALID_ITEM',
                            p_ts_id,
                            'CWMS Timeseries Identifier');
      END;

      set_ts_time_zone (l_ts_code, p_time_zone_name);
   END set_tsid_time_zone;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- get_ts_time_zone -
   --
   FUNCTION get_ts_time_zone (p_ts_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_time_zone_code   NUMBER;
      l_time_zone_id     VARCHAR2 (28);
   BEGIN
      SELECT time_zone_code
        INTO l_time_zone_code
        FROM at_cwms_ts_spec
       WHERE ts_code = p_ts_code;

      IF l_time_zone_code IS NULL
      THEN
         l_time_zone_id := NULL;
      ELSE
         SELECT time_zone_name
           INTO l_time_zone_id
           FROM cwms_time_zone
          WHERE time_zone_code = l_time_zone_code;
      END IF;

      RETURN l_time_zone_id;
   END get_ts_time_zone;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- GET_TSID_TIME_ZONE -
   --
   FUNCTION get_tsid_time_zone (p_ts_id       IN VARCHAR2,
                                p_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_ts_code     NUMBER;
      l_office_id   VARCHAR2 (16)
                       := NVL (p_office_id, cwms_util.user_office_id);
   BEGIN
      BEGIN
         SELECT ts_code
           INTO l_ts_code
           FROM at_cwms_ts_id
          WHERE     UPPER (cwms_ts_id) = UPPER (p_ts_id)
                AND UPPER (db_office_id) = UPPER (l_office_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            BEGIN
               SELECT ts_code
                 INTO l_ts_code
                 FROM at_cwms_ts_id
                WHERE     UPPER (cwms_ts_id) = UPPER (p_ts_id)
                      AND UPPER (db_office_id) = UPPER (l_office_id);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  cwms_err.raise ('INVALID_ITEM',
                                  p_ts_id,
                                  'CWMS Timeseries Identifier');
            END;
      END;

      RETURN get_ts_time_zone (l_ts_code);
   END get_tsid_time_zone;


   PROCEDURE set_ts_versioned (p_cwms_ts_code   IN NUMBER,
                               p_versioned      IN VARCHAR2 DEFAULT 'T')
   IS
      l_version_flag         VARCHAR2 (1);
      l_is_versioned         BOOLEAN;
      l_version_date_count   INTEGER;
   BEGIN
      IF p_versioned NOT IN ('T', 'F', 't', 'f')
      THEN
         cwms_err.raise ('ERROR', 'Version flag must be ''T'' or ''F''');
      END IF;

      SELECT version_flag
        INTO l_version_flag
        FROM at_cwms_ts_spec
       WHERE ts_code = p_cwms_ts_code;

      l_is_versioned := nvl(l_version_flag, 'F') = 'T';

      IF p_versioned IN ('T', 't') AND NOT l_is_versioned
      THEN
         ------------------------
         -- turn on versioning --
         ------------------------
         UPDATE at_cwms_ts_spec
            SET version_flag = 'T'
          WHERE ts_code = p_cwms_ts_code;
      ELSIF p_versioned IN ('F', 'f') AND l_is_versioned
      THEN
         -------------------------
         -- turn off versioning --
         -------------------------
         SELECT COUNT (version_date)
           INTO l_version_date_count
           FROM av_tsv
          WHERE     ts_code = p_cwms_ts_code
                AND version_date != DATE '1111-11-11';

         IF l_version_date_count = 0
         THEN
            UPDATE at_cwms_ts_spec
               SET version_flag = 'F'
             WHERE ts_code = p_cwms_ts_code;
         ELSE
            cwms_err.raise (
               'ERROR',
               'Cannot turn off versioning for a time series that has versioned data');
         END IF;
      END IF;
   END set_ts_versioned;

   PROCEDURE set_tsid_versioned (p_cwms_ts_id     IN VARCHAR2,
                                 p_versioned      IN VARCHAR2 DEFAULT 'T',
                                 p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      set_ts_versioned (get_ts_code (p_cwms_ts_id, p_db_office_id),
                        p_versioned);
   END set_tsid_versioned;

   PROCEDURE is_ts_versioned (p_is_versioned      OUT VARCHAR2,
                              p_cwms_ts_code   IN     NUMBER)
   IS
      l_version_flag   VARCHAR2 (1);
   BEGIN
      SELECT version_flag
        INTO l_version_flag
        FROM at_cwms_ts_spec
       WHERE ts_code = p_cwms_ts_code;

      p_is_versioned :=
         case nvl(l_version_flag , 'F')
            when 'T' then 'T'
            else 'F'
         end;
   END is_ts_versioned;

   PROCEDURE is_tsid_versioned (
      p_is_versioned      OUT VARCHAR2,
      p_cwms_ts_id     IN     VARCHAR2,
      p_db_office_id   IN     VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      is_ts_versioned (p_is_versioned,
                       get_ts_code (p_cwms_ts_id, p_db_office_id));
   END is_tsid_versioned;

   FUNCTION is_tsid_versioned_f (p_cwms_ts_id     IN VARCHAR2,
                                 p_db_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_is_versioned   VARCHAR2 (1);
   BEGIN
      is_tsid_versioned (l_is_versioned, p_cwms_ts_id, p_db_office_id);

      RETURN l_is_versioned;
   END is_tsid_versioned_f;

   PROCEDURE get_ts_version_dates (
      p_date_cat       OUT SYS_REFCURSOR,
      p_cwms_ts_code   IN  NUMBER,
      p_start_time     IN  DATE,
      p_end_time       IN  DATE,
      p_time_zone      IN  VARCHAR2 DEFAULT 'UTC')
   IS
      l_start_time DATE;
      l_end_time   DATE;
   BEGIN
      l_start_time := cwms_util.change_timezone(p_start_time, p_time_zone, 'UTC');
      l_end_time   := cwms_util.change_timezone(p_end_time,   p_time_zone, 'UTC');
      OPEN p_date_cat FOR
           SELECT DISTINCT
                  case
                     when version_date = cwms_util.non_versioned then version_date
                     else cwms_util.change_timezone(version_date, 'UTC', p_time_zone)
                  end as version_date
             FROM av_tsv
            WHERE ts_code = p_cwms_ts_code
              AND date_time BETWEEN l_start_time AND l_end_time
         ORDER BY version_date;
   END get_ts_version_dates;

   PROCEDURE get_tsid_version_dates (
      p_date_cat          OUT SYS_REFCURSOR,
      p_cwms_ts_id     IN     VARCHAR2,
      p_start_time     IN     DATE,
      p_end_time       IN     DATE,
      p_time_zone      IN     VARCHAR2 DEFAULT 'UTC',
      p_db_office_id   IN     VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      get_ts_version_dates (p_date_cat,
                            get_ts_code (p_cwms_ts_id, p_db_office_id),
                            p_start_time,
                            p_end_time,
                            p_time_zone);
   END get_tsid_version_dates;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- CREATE_TS -
   --
   --v 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvvvv -
   PROCEDURE create_ts (p_office_id    IN VARCHAR2,
                        p_cwms_ts_id   IN VARCHAR2,
                        p_utc_offset   IN NUMBER DEFAULT NULL)
   IS
      l_ts_code   NUMBER;
   BEGIN
      create_ts_code (p_ts_code      => l_ts_code,
                      p_cwms_ts_id   => p_cwms_ts_id,
                      p_utc_offset   => p_utc_offset,
                      p_office_id    => p_office_id);
   END create_ts;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- CREATE_TS -
   --
   PROCEDURE create_ts (p_cwms_ts_id          IN VARCHAR2,
                        p_utc_offset          IN NUMBER DEFAULT NULL,
                        p_interval_forward    IN NUMBER DEFAULT NULL,
                        p_interval_backward   IN NUMBER DEFAULT NULL,
                        p_versioned           IN VARCHAR2 DEFAULT 'F',
                        p_active_flag         IN VARCHAR2 DEFAULT 'T',
                        p_office_id           IN VARCHAR2 DEFAULT NULL)
   IS
      l_ts_code   NUMBER;
   BEGIN
      create_ts_code (p_ts_code             => l_ts_code,
                      p_cwms_ts_id          => p_cwms_ts_id,
                      p_utc_offset          => p_utc_offset,
                      p_interval_forward    => p_interval_forward,
                      p_interval_backward   => p_interval_backward,
                      p_versioned           => p_versioned,
                      p_active_flag         => p_active_flag,
                      p_office_id           => p_office_id);
   END create_ts;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- CREATE_TS_TZ -
   --
   PROCEDURE create_ts_tz (p_cwms_ts_id          IN VARCHAR2,
                           p_utc_offset          IN NUMBER DEFAULT NULL,
                           p_interval_forward    IN NUMBER DEFAULT NULL,
                           p_interval_backward   IN NUMBER DEFAULT NULL,
                           p_versioned           IN VARCHAR2 DEFAULT 'F',
                           p_active_flag         IN VARCHAR2 DEFAULT 'T',
                           p_time_zone_name      IN VARCHAR2 DEFAULT 'UTC',
                           p_office_id           IN VARCHAR2 DEFAULT NULL)
   IS
      l_ts_code   NUMBER;
   BEGIN
      create_ts_code (l_ts_code,
                      p_cwms_ts_id,
                      p_utc_offset,
                      p_interval_forward,
                      p_interval_backward,
                      p_versioned,
                      p_active_flag,
                      'F',
                      p_office_id);

      set_ts_time_zone (l_ts_code, p_time_zone_name);
   END create_ts_tz;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- CREATE_TS_CODE - v2.0 -
   --

   PROCEDURE create_ts_code (
      p_ts_code                OUT NUMBER,
      p_cwms_ts_id          IN     VARCHAR2,
      p_utc_offset          IN     NUMBER DEFAULT NULL,
      p_interval_forward    IN     NUMBER DEFAULT NULL,
      p_interval_backward   IN     NUMBER DEFAULT NULL,
      p_versioned           IN     VARCHAR2 DEFAULT 'F',
      p_active_flag         IN     VARCHAR2 DEFAULT 'T',
      p_fail_if_exists      IN     VARCHAR2 DEFAULT 'T',
      p_office_id           IN     VARCHAR2 DEFAULT NULL)
   IS
      l_office_id             VARCHAR2 (16);
      l_base_location_id      VARCHAR2 (50);
      l_base_location_code    NUMBER;
      l_sub_location_id       VARCHAR2 (50);
      l_base_parameter_id     VARCHAR2 (50);
      l_base_parameter_code   NUMBER;
      l_sub_parameter_id      VARCHAR2 (50);
      l_parameter_code        NUMBER;
      l_parameter_type_id     VARCHAR2 (50);
      l_parameter_type_code   NUMBER;
      l_interval              NUMBER;
      l_interval_id           VARCHAR2 (50);
      l_interval_code         NUMBER;
      l_duration_id           VARCHAR2 (50);
      l_duration              NUMBER;
      l_duration_code         NUMBER;
      l_version               VARCHAR2 (50);
      l_office_code           NUMBER;
      l_location_code         NUMBER;
      l_ret                   NUMBER;
      l_hashcode              NUMBER;
      l_str_error             VARCHAR2 (256);
      l_utc_offset            NUMBER;
      l_all_office_code       NUMBER := cwms_util.db_office_code_all;
      l_ts_id_exists          BOOLEAN := FALSE;
      l_can_create            BOOLEAN := TRUE;
      l_cwms_ts_id            varchar2(183);
      l_parts                 str_tab_t;
   BEGIN
      IF p_office_id IS NULL
      THEN
         l_office_id := cwms_util.user_office_id;
      ELSE
         l_office_id := UPPER (p_office_id);
      END IF;


      DBMS_APPLICATION_INFO.set_module ('create_ts_code',
                                        'parse timeseries_desc using regexp');
      ----------------------------------------------                                        
      -- remove any aliases from location portion --
      ----------------------------------------------
      l_parts := cwms_util.split_text(p_cwms_ts_id, '.', 1);
      l_parts(1) := cwms_loc.get_location_id(l_parts(1), p_office_id);
      if l_parts(1) is null then
         l_cwms_ts_id := p_cwms_ts_id;
      else
         l_cwms_ts_id := cwms_util.join_text(l_parts, '.');
      end if;
      --parse values from timeseries_desc using regular expressions
      parse_ts (l_cwms_ts_id,
                l_base_location_id,
                l_sub_location_id,
                l_base_parameter_id,
                l_sub_parameter_id,
                l_parameter_type_id,
                l_interval_id,
                l_duration_id,
                l_version);
      --office codes must exist, if not fail and return error  (prebuilt table, dynamic office addition not allowed)
      DBMS_APPLICATION_INFO.set_action ('check for office_code');

      BEGIN
         SELECT office_code
           INTO l_office_code
           FROM cwms_office o
          WHERE o.office_id = l_office_id;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.RAISE ('INVALID_OFFICE_ID', l_office_id);
      END;

      IF l_office_code = 0
      THEN
         cwms_err.RAISE ('INVALID_OFFICE_ID', l_office_id);
      END IF;

      DBMS_APPLICATION_INFO.set_action (
         'check for location_code, create if necessary');
      -- check for valid base_location_code based on id passed in, if not there then create, -
      -- if create error then fail and return -

      cwms_loc.create_location_raw (l_base_location_code,
                                    l_location_code,
                                    l_base_location_id,
                                    l_sub_location_id,
                                    l_office_code);

      IF l_location_code IS NULL
      THEN
         raise_application_error (-20203,
                                  'Unable to generate location_code',
                                  TRUE);
      END IF;

      -- check for valid cwms_code based on id passed in, if not there then create, if create error then fail and return
      DBMS_APPLICATION_INFO.set_action (
         'check for cwms_code, create if necessary');

      --generate hash and lock table for that hash value to serialize ts_create as timeseries_desc is not pkeyed.
      SELECT ORA_HASH (UPPER (l_office_id) || UPPER (p_cwms_ts_id),
                       1073741823)
        INTO l_hashcode
        FROM DUAL;

      l_ret :=
         DBMS_LOCK.request (id                  => l_hashcode,
                            timeout             => 0,
                            lockmode            => DBMS_LOCK.x_mode,
                            release_on_commit   => TRUE);

      IF l_ret > 0
      THEN
         l_can_create := FALSE; -- don't create a ts_code, just retrieve the one we're blocking against.
         DBMS_LOCK.sleep (2);
      END IF;

      -- BEGIN...

      -- determine rest of lookup codes based on passed in values, use scalar subquery to minimize context switches, return error if lookups not found
      DBMS_APPLICATION_INFO.set_action (
         'check code lookups, scalar subquery');

      SELECT (SELECT base_parameter_code
                FROM cwms_base_parameter p
               WHERE UPPER (p.base_parameter_id) =
                        UPPER (l_base_parameter_id))
                p,
             (SELECT duration_code
                FROM cwms_duration d
               WHERE UPPER (d.duration_id) = UPPER (l_duration_id))
                d,
             (SELECT duration
                FROM cwms_duration d
               WHERE UPPER (d.duration_id) = UPPER (l_duration_id))
                dd,
             (SELECT parameter_type_code
                FROM cwms_parameter_type p
               WHERE UPPER (p.parameter_type_id) =
                        UPPER (l_parameter_type_id))
                pt,
             (SELECT interval_code
                FROM cwms_interval i
               WHERE UPPER (i.interval_id) = UPPER (l_interval_id))
                i,
             (SELECT INTERVAL
                FROM cwms_interval ii
               WHERE UPPER (ii.interval_id) = UPPER (l_interval_id))
                ii
        INTO l_base_parameter_code,
             l_duration_code,
	     l_duration,
             l_parameter_type_code,
             l_interval_code,
             l_interval
        FROM DUAL;

      IF    l_base_parameter_code IS NULL
         OR l_duration_code IS NULL
         OR l_parameter_type_code IS NULL
         OR l_interval_code IS NULL
         OR (UPPER (l_parameter_type_id) = 'INST' AND l_duration <> 0)
      THEN
         l_str_error :=
            'ERROR: Invalid Time Series Description: ' || p_cwms_ts_id;

         IF l_base_parameter_code IS NULL
         THEN
            l_str_error :=
                  l_str_error
               || CHR (10)
               || l_base_parameter_id
               || ' is not a valid base parameter';
         END IF;

         IF l_duration_code IS NULL
         THEN
            l_str_error :=
                  l_str_error
               || CHR (10)
               || l_duration_id
               || ' is not a valid duration';
         END IF;

         IF l_interval_code IS NULL
         THEN
            l_str_error :=
                  l_str_error
               || CHR (10)
               || l_interval_id
               || ' is not a valid interval';
         END IF;

         IF (UPPER (l_parameter_type_id) = 'INST' AND l_duration <> 0) 
         THEN
            l_str_error :=
                  l_str_error
               || CHR (10)
               || ' Inst parameter type can not have non-zero duration';
         END IF;

         IF l_can_create
         THEN
            l_ret := DBMS_LOCK.release (l_hashcode);
         END IF;

         raise_application_error (-20205, l_str_error, TRUE);
      END IF;

      BEGIN
         IF l_sub_parameter_id IS NULL
         THEN
            SELECT parameter_code
              INTO l_parameter_code
              FROM at_parameter ap
             WHERE     base_parameter_code = l_base_parameter_code
                   AND sub_parameter_id IS NULL
                   AND db_office_code IN (l_office_code, l_all_office_code);
         ELSE
            SELECT parameter_code
              INTO l_parameter_code
              FROM at_parameter ap
             WHERE     base_parameter_code = l_base_parameter_code
                   AND UPPER (sub_parameter_id) = UPPER (l_sub_parameter_id)
                   AND db_office_code IN (l_office_code, l_all_office_code);
         END IF;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            IF l_sub_parameter_id IS NULL
            THEN
               IF l_can_create
               THEN
                  l_ret := DBMS_LOCK.release (l_hashcode);
               END IF;

               cwms_err.RAISE (
                  'GENERIC_ERROR',
                     l_base_parameter_id
                  || ' is not a valid Base Parameter. Cannot Create a new CWMS_TS_ID');
            ELSE                                -- Insert new sub_parameter...
               INSERT INTO at_parameter (parameter_code,
                                         db_office_code,
                                         base_parameter_code,
                                         sub_parameter_id)
                    VALUES (cwms_seq.NEXTVAL,
                            l_office_code,
                            l_base_parameter_code,
                            l_sub_parameter_id)
                 RETURNING parameter_code
                      INTO l_parameter_code;
            END IF;
      END;

      --after all lookups, check for existing ts_code, insert it if not found, and verify that it was inserted with the returning, error if no valid ts_code is returned
      DBMS_APPLICATION_INFO.set_action (
         'check for ts_code, create if necessary');

      BEGIN
         SELECT ts_code
           INTO p_ts_code
           FROM at_cwms_ts_spec acts
          WHERE              /*office_code = l_office_code
                         AND */
               acts .location_code = l_location_code
                AND acts.parameter_code = l_parameter_code
                AND acts.parameter_type_code = l_parameter_type_code
                AND acts.interval_code = l_interval_code
                AND acts.duration_code = l_duration_code
                AND UPPER (NVL (acts.VERSION, 1)) =
                       UPPER (NVL (l_version, 1))
                AND acts.delete_date IS NULL;

         --
         l_ts_id_exists := TRUE;

         IF l_can_create
         THEN
            l_ret := DBMS_LOCK.release (l_hashcode);
         END IF;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            IF l_can_create
            THEN
               IF l_interval = 0
               THEN
                  l_utc_offset := cwms_util.utc_offset_irregular;
               ELSE
                  l_utc_offset := cwms_util.utc_offset_undefined;

                  IF p_utc_offset IS NOT NULL
                  THEN
                     IF p_utc_offset = cwms_util.utc_offset_undefined
                     THEN
                        NULL;
                     ELSIF p_utc_offset >= 0 AND p_utc_offset < l_interval
                     THEN
                        l_utc_offset := p_utc_offset;
                     ELSE
                        COMMIT;
                        cwms_err.RAISE ('INVALID_UTC_OFFSET',
                                        p_utc_offset,
                                        l_interval_id);
                     END IF;
                  END IF;
               END IF;

               IF p_interval_forward < 0 OR p_interval_forward >= l_interval
               THEN
                  COMMIT;
                  cwms_err.raise (
                     'ERROR',
                        'Interval forward ('
                     || p_interval_forward
                     || ') must be >= 0 and < interval ('
                     || l_interval
                     || ')');
               END IF;

               IF    p_interval_backward < 0
                  OR p_interval_backward >= l_interval
               THEN
                  COMMIT;
                  cwms_err.raise (
                     'ERROR',
                        'Interval backward ('
                     || p_interval_backward
                     || ') must be >= 0 and < interval ('
                     || l_interval
                     || ')');
               END IF;

               IF p_interval_forward + p_interval_backward >= l_interval
               THEN
                  COMMIT;
                  cwms_err.raise (
                     'ERROR',
                        'Interval backward ('
                     || p_interval_backward
                     || ') plus interval forward ('
                     || p_interval_forward
                     || ') must be < interval ('
                     || l_interval
                     || ')');
               END IF;

               IF UPPER (p_active_flag) NOT IN ('T', 'F')
               THEN
                  COMMIT;
                  cwms_err.raise ('ERROR',
                                  'Active flag must be ''T'' or ''F''');
               END IF;

               IF UPPER (p_versioned) NOT IN ('T', 'F')
               THEN
                  COMMIT;
                  cwms_err.raise ('ERROR',
                                  'Versioned flag must be ''T'' or ''F''');
               END IF;

               INSERT INTO at_cwms_ts_spec t (ts_code,
                                              location_code,
                                              parameter_code,
                                              parameter_type_code,
                                              interval_code,
                                              duration_code,
                                              VERSION,
                                              interval_utc_offset,
                                              interval_forward,
                                              interval_backward,
                                              version_flag,
                                              active_flag)
                    VALUES (
                              cwms_seq.NEXTVAL,
                              l_location_code,
                              l_parameter_code,
                              l_parameter_type_code,
                              l_interval_code,
                              l_duration_code,
                              l_version,
                              l_utc_offset,
                              p_interval_forward,
                              p_interval_backward,
                              CASE UPPER (p_versioned)
                                 WHEN 'T' THEN 'Y'
                                 WHEN 'F' THEN NULL
                              END,
                              UPPER (p_active_flag))
                 RETURNING ts_code
                      INTO p_ts_code;

               ---------------------------------
               -- Publish a TSCreated message --
               ---------------------------------
               DECLARE
                  l_msg     SYS.aq$_jms_map_message;
                  l_msgid   PLS_INTEGER;
                  i         INTEGER;
               BEGIN
                  cwms_msg.new_message (l_msg, l_msgid, 'TSCreated');
                  l_msg.set_string (l_msgid, 'ts_id', p_cwms_ts_id);
                  l_msg.set_string (l_msgid, 'office_id', l_office_id);
                  l_msg.set_long (l_msgid, 'ts_code', p_ts_code);
                  i :=
                     cwms_msg.publish_message (l_msg,
                                               l_msgid,
                                               l_office_id || '_ts_stored');
               END;

               COMMIT;
            END IF;
      END;

      IF p_ts_code IS NULL
      THEN
         raise_application_error (-20204,
                                  'Unable to generate timeseries_code',
                                  TRUE);
      ELSIF l_ts_id_exists
      THEN
         IF UPPER (p_fail_if_exists) != 'F'
         THEN
            cwms_err.RAISE ('TS_ALREADY_EXISTS', p_cwms_ts_id);
         END IF;
      END IF;

      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   END create_ts_code;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- CREATE_TS_CODE_TZ - v2.0 -
   --
   PROCEDURE create_ts_code_tz (
      p_ts_code                OUT NUMBER,
      p_cwms_ts_id          IN     VARCHAR2,
      p_utc_offset          IN     NUMBER DEFAULT NULL,
      p_interval_forward    IN     NUMBER DEFAULT NULL,
      p_interval_backward   IN     NUMBER DEFAULT NULL,
      p_versioned           IN     VARCHAR2 DEFAULT 'F',
      p_active_flag         IN     VARCHAR2 DEFAULT 'T',
      p_fail_if_exists      IN     VARCHAR2 DEFAULT 'T',
      p_time_zone_name      IN     VARCHAR2 DEFAULT 'UTC',
      p_office_id           IN     VARCHAR2 DEFAULT NULL)
   IS
      l_ts_code   NUMBER;
   BEGIN
      create_ts_code (l_ts_code,
                      p_cwms_ts_id,
                      p_utc_offset,
                      p_interval_forward,
                      p_interval_backward,
                      p_versioned,
                      p_active_flag,
                      p_fail_if_exists,
                      p_office_id);

      set_ts_time_zone (l_ts_code, p_time_zone_name);
      p_ts_code := l_ts_code;
   END create_ts_code_tz;

   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- tz_offset_at_gmt
   --
   FUNCTION tz_offset_at_gmt (p_date_time IN DATE, p_tz_name IN VARCHAR2)
      RETURN INTEGER
   IS
      l_offset          INTEGER := 0;
      l_tz_offset_str   VARCHAR2 (8)
                           := RTRIM (TZ_OFFSET (p_tz_name), CHR (0));
      l_ts_utc          TIMESTAMP;
      l_ts_loc          TIMESTAMP;
      l_hours           INTEGER;
      l_minutes         INTEGER;
      l_parts           str_tab_t;
   BEGIN
      IF l_tz_offset_str != '+00:00' AND l_tz_offset_str != '-00:00'
      THEN
         l_parts := cwms_util.split_text (l_tz_offset_str, ':');
         l_hours := TO_NUMBER (l_parts (1));
         l_minutes := TO_NUMBER (l_parts (2));

         IF l_hours < 0
         THEN
            l_minutes := l_hours * 60 - l_minutes;
         ELSE
            l_minutes := l_hours * 60 + l_minutes;
         END IF;

         l_ts_utc := CAST (p_date_time AS TIMESTAMP);
         l_ts_loc := FROM_TZ (l_ts_utc, 'UTC') AT TIME ZONE p_tz_name;
         l_offset :=
              l_minutes
            - ROUND (
                   (  cwms_util.to_millis (l_ts_loc)
                    - cwms_util.to_millis (l_ts_utc))
                 / 60000);
      END IF;

      RETURN l_offset;
   END;

   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- shift_for_localtime
   --
   FUNCTION shift_for_localtime (p_date_time IN DATE, p_tz_name IN VARCHAR2)
      RETURN DATE
   IS
   BEGIN
      RETURN p_date_time + tz_offset_at_gmt (p_date_time, p_tz_name) / 1440;
   END shift_for_localtime;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- setup_retrieve
   --
   PROCEDURE setup_retrieve (p_start_time        IN OUT DATE,
                             p_end_time          IN OUT DATE,
                             p_reg_start_time       OUT DATE,
                             p_reg_end_time         OUT DATE,
                             p_ts_code           IN     NUMBER,
                             p_interval          IN     NUMBER,
                             p_offset            IN     NUMBER,
                             p_start_inclusive   IN     BOOLEAN,
                             p_end_inclusive     IN     BOOLEAN,
                             p_previous          IN     BOOLEAN,
                             p_next              IN     BOOLEAN,
                             p_trim              IN     BOOLEAN)
   IS
      l_start_time   DATE := p_start_time;
      l_end_time     DATE := p_end_time;
      l_temp_time    DATE;
   BEGIN
      --
      -- handle inclusive/exclusive by adjusting start/end times inward
      --
      IF NOT p_start_inclusive
      THEN
         l_start_time := l_start_time + 1 / 86400;
      END IF;

      IF NOT p_end_inclusive
      THEN
         l_end_time := l_end_time - 1 / 86400;
      END IF;

      --
      -- handle previous/next by adjusting start/end times outward
      --
      IF p_previous
      THEN
         IF p_interval = 0
         THEN
            SELECT MAX (date_time)
              INTO l_temp_time
              FROM av_tsv
             WHERE     ts_code = p_ts_code
                   AND date_time < l_start_time
                   AND start_date <= l_end_time;

            IF l_temp_time IS NOT NULL
            THEN
               l_start_time := l_temp_time;
            END IF;
         ELSE
            l_start_time := l_start_time - p_interval / 1440;
         END IF;
      END IF;

      IF p_next
      THEN
         IF p_interval = 0
         THEN
            SELECT MIN (date_time)
              INTO l_temp_time
              FROM av_tsv
             WHERE     ts_code = p_ts_code
                   AND date_time > l_end_time
                   AND end_date > l_start_time;

            IF l_temp_time IS NOT NULL
            THEN
               l_end_time := l_temp_time;
            END IF;
         ELSE
            l_end_time := l_end_time + p_interval / 1440;
         END IF;
      END IF;

      --
      -- handle trim by adjusting start/end times inward to first/last
      -- non-missing values
      --
      IF p_trim
      THEN
         SELECT MIN (date_time), MAX (date_time)
           INTO l_start_time, l_end_time
           FROM (SELECT date_time
                   FROM av_tsv v, cwms_data_quality q
                  WHERE     v.ts_code = p_ts_code
                        AND v.date_time BETWEEN l_start_time AND l_end_time
                        AND v.start_date <= l_end_time
                        AND v.end_date > l_start_time
                        AND v.quality_code = q.quality_code
                        AND q.validity_id != 'MISSING'
                        AND v.VALUE IS NOT NULL);
      END IF;

      --
      -- set the out parameters
      --
      p_start_time := l_start_time;
      p_end_time := l_end_time;

      IF p_interval = 0
      THEN
         --
         -- These parameters are used to generate a regular time series from which
         -- to fill in the times of missing values.  In the case of irregular time
         -- series, set them so that they will not generate a time series at all.
         --
         p_reg_start_time := NULL;
         p_reg_end_time := NULL;
      ELSE
         IF p_offset = cwms_util.utc_offset_undefined
         THEN
            p_reg_start_time :=
               get_time_on_after_interval (l_start_time, NULL, p_interval);
            p_reg_end_time :=
               get_time_on_before_interval (l_end_time, NULL, p_interval);
         ELSE
            p_reg_start_time :=
               get_time_on_after_interval (l_start_time,
                                           p_offset,
                                           p_interval);
            p_reg_end_time :=
               get_time_on_before_interval (l_end_time, p_offset, p_interval);
         END IF;
      END IF;
   END setup_retrieve;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- BUILD_RETRIEVE_TS_QUERY - v2.0 -
   --
   FUNCTION build_retrieve_ts_query (
      p_cwms_ts_id_out       OUT VARCHAR2,
      p_units_out            OUT VARCHAR2,
      p_cwms_ts_id        IN     VARCHAR2,
      p_units             IN     VARCHAR2,
      p_start_time        IN     DATE,
      p_end_time          IN     DATE,
      p_date_time_type    IN     VARCHAR2,
      p_time_zone         IN     VARCHAR2 DEFAULT 'UTC',
      p_trim              IN     VARCHAR2 DEFAULT 'F',
      p_start_inclusive   IN     VARCHAR2 DEFAULT 'T',
      p_end_inclusive     IN     VARCHAR2 DEFAULT 'T',
      p_previous          IN     VARCHAR2 DEFAULT 'F',
      p_next              IN     VARCHAR2 DEFAULT 'F',
      p_version_date      IN     DATE DEFAULT NULL,
      p_max_version       IN     VARCHAR2 DEFAULT 'T',
      p_office_id         IN     VARCHAR2 DEFAULT NULL)
      RETURN SYS_REFCURSOR
   IS
      l_ts_code           NUMBER;      
      l_location_code     NUMBER;
      l_interval          NUMBER;
      l_interval2         NUMBER := 60 / 1440;
      l_utc_offset        NUMBER;
      l_office_id         VARCHAR2 (16);
      l_cwms_ts_id        VARCHAR2 (183);
      l_units             VARCHAR2 (16);
      l_time_zone         VARCHAR2 (28); 
      l_base_parameter_id VARCHAR2(16);
      l_trim              BOOLEAN;
      l_start_inclusive   BOOLEAN;
      l_end_inclusive     BOOLEAN;
      l_previous          BOOLEAN;
      l_next              BOOLEAN;
      l_start_time        DATE;
      l_end_time          DATE;
      l_version_date      DATE;
      l_reg_start_time    DATE;
      l_reg_end_time      DATE;
      l_max_version       BOOLEAN;
      l_query_str         VARCHAR2 (32767);
      l_start_str         VARCHAR2 (32);
      l_end_str           VARCHAR2 (32);
      l_reg_start_str     VARCHAR2 (32);
      l_reg_end_str       VARCHAR2 (32);
      l_missing           NUMBER := 5;                 -- MISSING quality code
      l_date_format       VARCHAR2 (32) := 'yyyy/mm/dd-hh24.mi.ss';
      l_cursor            SYS_REFCURSOR;
      l_strict_times      BOOLEAN := FALSE;
      l_value_offset      binary_double := 0;  

      PROCEDURE set_action (text IN VARCHAR2)
      IS
      BEGIN
         DBMS_APPLICATION_INFO.set_action (text);
         --DBMS_OUTPUT.put_line (text);
      END;

      PROCEDURE replace_strings
      IS
      BEGIN
         l_query_str := REPLACE (l_query_str, ':tz', l_time_zone);
         l_query_str :=
            REPLACE (l_query_str, ':date_time_type', p_date_time_type);

         IF l_max_version
         THEN
            l_query_str := REPLACE (l_query_str, ':first_or_last', 'last');
         ELSE
            l_query_str := REPLACE (l_query_str, ':first_or_last', 'first');
         END IF;
      END;
   BEGIN
      --------------------
      -- initialization --
      --------------------
      l_office_id := NVL (p_office_id, cwms_util.user_office_id);
      l_cwms_ts_id := get_cwms_ts_id (p_cwms_ts_id, l_office_id);
      l_units := NVL (cwms_util.get_unit_id(p_units, l_Office_id), get_db_unit_id (l_cwms_ts_id));
      l_time_zone := NVL (p_time_zone, 'UTC');

      IF SUBSTR (l_time_zone, 1, 1) = '!'
      THEN
         l_strict_times := TRUE;
         l_time_zone := SUBSTR (l_time_zone, 2);
      END IF;

      l_time_zone := cwms_util.get_time_zone_name (l_time_zone);
      l_trim := cwms_util.return_true_or_false (NVL (p_trim, 'F'));
      l_start_inclusive :=
         cwms_util.return_true_or_false (NVL (p_start_inclusive, 'T'));
      l_end_inclusive :=
         cwms_util.return_true_or_false (NVL (p_end_inclusive, 'T'));
      l_previous := cwms_util.return_true_or_false (NVL (p_previous, 'F'));
      l_next := cwms_util.return_true_or_false (NVL (p_next, 'F'));
      l_start_time :=
         cwms_util.change_timezone (p_start_time, l_time_zone, 'UTC');
      l_end_time := cwms_util.change_timezone (p_end_time, l_time_zone, 'UTC');
      l_version_date :=
         cwms_util.change_timezone (p_version_date, l_time_zone, 'UTC');
      l_max_version :=
         cwms_util.return_true_or_false (NVL (p_max_version, 'F'));
      --
      -- set the out parameters
      --
      p_cwms_ts_id_out := l_cwms_ts_id;
      p_units_out      := l_units;

      --
      -- allow cwms_util.non_versioned to be used regarless of time zone
      --
      IF p_version_date = cwms_util.non_versioned
      THEN
         l_version_date := cwms_util.non_versioned;
      END IF;

      --
      -- get ts code
      --
      DBMS_APPLICATION_INFO.set_module ('cwms_ts.build_retrieve_ts_query',
                                        'Get TS Code');

      BEGIN
         select ts_code, 
                interval, 
                interval_utc_offset,
                base_parameter_id,
                location_code
           into l_ts_code, 
                l_interval, 
                l_utc_offset,
                l_base_parameter_id,
                l_location_code
           from at_cwms_ts_id
          where upper(db_office_id) = upper(l_office_id)
            and upper(cwms_ts_id) = upper(p_cwms_ts_id_out);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            BEGIN
               select ts_code, 
                      interval, 
                      interval_utc_offset,
                      base_parameter_id,
                      location_code
                 into l_ts_code, 
                      l_interval, 
                      l_utc_offset,
                      l_base_parameter_id,
                      l_location_code
                 from at_cwms_ts_id
                where upper(db_office_id) = upper(l_office_id)
                  and upper(cwms_ts_id) = upper(p_cwms_ts_id_out);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  cwms_err.raise('TS_ID_NOT_FOUND', l_cwms_ts_id, l_office_id);
            END;
      END;
                          
      if l_base_parameter_id = 'Elev' then
         l_value_offset := cwms_loc.get_vertical_datum_offset(l_location_code, p_units);
      end if;
      
      set_action ('Handle start and end times');
      setup_retrieve (l_start_time,
                      l_end_time,
                      l_reg_start_time,
                      l_reg_end_time,
                      l_ts_code,
                      l_interval,
                      l_utc_offset,
                      l_start_inclusive,
                      l_end_inclusive,
                      l_previous,
                      l_next,
                      l_trim);
      --
      -- change interval from minutes to days
      --
      l_interval := l_interval / 1440;

      IF l_interval > 0
      THEN
         l_reg_start_str := TO_CHAR (l_reg_start_time, l_date_format);
         l_reg_end_str := TO_CHAR (l_reg_end_time, l_date_format);
      END IF;

      l_start_str := TO_CHAR (l_start_time, l_date_format);
      l_end_str := TO_CHAR (l_end_time, l_date_format);

      --
      -- build the query string - for some reason the time zone must be a
      -- string literal and bind variables are problematic
      --
      IF l_version_date IS NULL
      THEN
         --
         -- min or max version date
         --
         IF l_interval > 0
         THEN
            --
            -- regular time series
            --
            IF MOD (l_interval, 30) = 0 OR MOD (l_interval, 365) = 0
            THEN
               --
               -- must use calendar math
               --
               -- change interval from days to months
               --
               IF MOD (l_interval, 30) = 0
               THEN
                  l_interval := l_interval / 30;
               ELSE
                  l_interval := l_interval / 365 * 12;
               END IF;

               l_query_str :=
                  'select cast(from_tz(cast(t.date_time as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) "DATE_TIME",
                      case
                         when value is nan then null
                         else value + :l_value_offset
                      end "VALUE",
                      cwms_ts.normalize_quality(nvl(quality_code, :missing)) "QUALITY_CODE"
                 from (
                      select date_time,
                             max(value) keep(dense_rank :first_or_last order by version_date) "VALUE",
                             max(quality_code) keep(dense_rank :first_or_last order by version_date) "QUALITY_CODE"
                        from av_tsv_dqu
                       where ts_code    =  :ts_code
                         and date_time  >= to_date(:l_start, :l_date_fmt)
                         and date_time  <= to_date(:l_end,   :l_date_fmt)
                         and unit_id    =  :units
                         and start_date <= to_date(:l_end,   :l_date_fmt)
                         and end_date   >  to_date(:l_start, :l_date_fmt)
                    group by date_time
                      ) v
                      right outer join
                      (
                      select cwms_ts.shift_for_localtime(add_months(to_date(:reg_start, :l_date_fmt), (level-1) * :interval), :l_time_zone) date_time
                        from dual
                       where to_date(:reg_start, :l_date_format) is not null
                  connect by level <= months_between(to_date(:reg_end,   :l_date_format),
                                                     to_date(:reg_start, :l_date_format)) / :interval + 1
                      ) t
                      on v.date_time = t.date_time
                      order by t.date_time asc';
               replace_strings;
               cwms_util.check_dynamic_sql(l_query_str);
               
               OPEN l_cursor FOR l_query_str
                  USING l_value_offset,
                        l_missing,
                        l_ts_code,
                        l_start_str,
                        l_date_format,
                        l_end_str,
                        l_date_format,
                        l_units,
                        l_end_str,
                        l_date_format,
                        l_start_str,
                        l_date_format,
                        l_reg_start_str,
                        l_date_format,
                        l_interval,
                        l_time_zone,
                        l_reg_start_str,
                        l_date_format,
                        l_reg_end_str,
                        l_date_format,
                        l_reg_start_str,
                        l_date_format,
                        l_interval;
            ELSE
               --
               -- can use date arithmetic
               --
               IF l_strict_times
               THEN
                  l_query_str :=
                     'select date_time,
                          case
                             when value is nan then null
                             else value + :l_value_offset
                          end "VALUE",
                          cwms_ts.normalize_quality(quality_code) as quality_code
                     from ((select cast(from_tz(cast(date_time as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) as date_time,
                                  value,
                                  quality_code
                             from (select t.date_time as date_time,
                                          case
                                             when value is nan then null
                                             else value
                                          end as value,
                                          nvl(quality_code, :missing) as quality_code
                                     from (
                                          select date_time,
                                                 max(value) keep(dense_rank :first_or_last order by version_date) as value,
                                                 max(quality_code) keep(dense_rank :first_or_last order by version_date) as quality_code
                                            from av_tsv_dqu
                                           where ts_code    =  :ts_code
                                             and date_time  >= to_date(:l_start, :l_date_fmt)
                                             and date_time  <= to_date(:l_end,   :l_date_fmt)
                                             and unit_id    =  :units
                                             and start_date <= to_date(:l_end,   :l_date_fmt)
                                             and end_date   >  to_date(:l_start, :l_date_fmt)
                                        group by date_time
                                          ) v
                                          right outer join
                                          (
                                          select max(date_time) date_time
                                            from (select date_time,
                                                         cwms_util.change_timezone(date_time, ''UTC'', :l_time_zone) local_time
                                                    from (select to_date(:reg_start, :l_date_fmt) + (level-1) * :interval date_time
                                                            from dual
                                                      connect by level <= round((to_date(:reg_end,   :l_date_fmt)
                                                                               - to_date(:reg_start, :l_date_fmt)) / :interval + 1)
                                                         )
                                                 )
                                         group by local_time
                                          ) t
                                          on v.date_time = t.date_time
                                  )
                           )
                           union all
                           (select date_time,
                                   null as value,
                                   :missing as quality_code
                              from (select prev_time + (level + :interval2 / :interval - 1) * :interval as date_time,
                                           level as level_count
                                      from (select date_time,
                                                   prev_time
                                              from (select date_time,
                                                           lag(date_time, 1, null) over (order by date_time) as prev_time,
                                                           date_time - lag(date_time, 1, null) over (order by date_time) as time_diff
                                                      from (select cwms_util.change_timezone(to_date(:reg_start, :l_date_fmt) + (level-1) * :interval2, ''UTC'', :l_timezone) as date_time
                                                              from dual
                                                   connect by level <= round((to_date(:reg_end,   :l_date_fmt)
                                                                            - to_date(:reg_start, :l_date_fmt)) / :interval2 + 1)
                                                           )
                                                   )
                                             where time_diff > greatest(:interval, :interval2)
                                          order by date_time
                                           )
                               connect by level < (date_time - prev_time) / :interval
                                   )
                             where level_count <= round(:interval2 / :interval)
                           ))
                 order by date_time';
                  replace_strings;
                  cwms_util.check_dynamic_sql(l_query_str);

                  OPEN l_cursor FOR l_query_str
                     USING l_value_offset,
                           l_missing,
                           l_ts_code,
                           l_start_str,
                           l_date_format,
                           l_end_str,
                           l_date_format,
                           l_units,
                           l_end_str,
                           l_date_format,
                           l_start_str,
                           l_date_format,
                           l_time_zone,
                           l_reg_start_str,
                           l_date_format,
                           l_interval,
                           l_reg_end_str,
                           l_date_format,
                           l_reg_start_str,
                           l_date_format,
                           l_interval,
                           l_missing,
                           l_interval2,
                           l_interval,
                           l_interval,
                           l_reg_start_str,
                           l_date_format,
                           l_interval2,
                           l_time_zone,
                           l_reg_end_str,
                           l_date_format,
                           l_reg_start_str,
                           l_date_format,
                           l_interval2,
                           l_interval,
                           l_interval2,
                           l_interval,
                           l_interval2,
                           l_interval;
               ELSE
                  l_query_str :=
                     'select cast(from_tz(cast(t.date_time as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) "DATE_TIME",
                             case
                                when value is nan then null
                                else value + :l_value_offset
                             end "VALUE",
                             cwms_ts.normalize_quality(nvl(quality_code, :missing)) "QUALITY_CODE"
                        from (
                             select date_time,
                                    max(value) keep(dense_rank :first_or_last order by version_date) "VALUE",
                                    max(quality_code) keep(dense_rank :first_or_last order by version_date) "QUALITY_CODE"
                               from av_tsv_dqu
                              where ts_code    =  :ts_code
                                and date_time  >= to_date(:l_start, :l_date_fmt)
                                and date_time  <= to_date(:l_end,   :l_date_fmt)
                                and unit_id    =  :units
                                and start_date <= to_date(:l_end,   :l_date_fmt)
                                and end_date   >  to_date(:l_start, :l_date_fmt)
                              group by date_time
                             ) v
                             right outer join
                            (select date_time,
                                    cwms_util.change_timezone(date_time, ''UTC'', :l_time_zone) local_time
                               from (select to_date(:reg_start, :l_date_fmt) + (level-1) * :interval date_time
                                       from dual
                                 connect by level <= round((to_date(:reg_end,   :l_date_fmt)
                                                          - to_date(:reg_start, :l_date_fmt)) / :interval + 1)
                                    )
                             ) t
                             on v.date_time = t.date_time
                       order by t.date_time asc';
                  replace_strings;
                  cwms_util.check_dynamic_sql(l_query_str);

                  OPEN l_cursor FOR l_query_str
                     USING l_value_offset,
                           l_missing,
                           l_ts_code,
                           l_start_str,
                           l_date_format,
                           l_end_str,
                           l_date_format,
                           l_units,
                           l_end_str,
                           l_date_format,
                           l_start_str,
                           l_date_format,
                           l_time_zone,
                           l_reg_start_str,
                           l_date_format,
                           l_interval,
                           l_reg_end_str,
                           l_date_format,
                           l_reg_start_str,
                           l_date_format,
                           l_interval;
               END IF;
            END IF;
         ELSE
            --
            -- irregular time series
            --
            IF l_strict_times
            THEN
               l_query_str :=
                  'select cast(from_tz(cast(max(date_time) as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) as date_time,
                       max(value) keep(dense_rank last order by date_time) + :l_value_offset as value,
                       cwms_ts.normalize_quality(max(quality_code) keep(dense_rank last order by date_time)) as quality_code
                  from (select date_time,
                               cwms_util.change_timezone(date_time, ''UTC'', :l_time_zone) as local_time,
                               case
                                  when max(value) keep(dense_rank :first_or_last order by version_date) is nan then null
                                  else max(value) keep(dense_rank :first_or_last order by version_date)
                               end as value,
                               max(quality_code) keep(dense_rank :first_or_last order by version_date) as quality_code
                          from av_tsv_dqu
                         where ts_code    =  :ts_code
                           and date_time  >= to_date(:l_start, :l_date_fmt)
                           and date_time  <= to_date(:l_end,   :l_date_fmt)
                           and unit_id    =  :units
                           and start_date <= to_date(:l_end,   :l_date_fmt)
                           and end_date   >  to_date(:l_start, :l_date_fmt)
                      group by date_time
                      )
                group by local_time
                order by local_time';
               replace_strings;
               cwms_util.check_dynamic_sql(l_query_str);

               OPEN l_cursor FOR l_query_str
                  USING l_value_offset,
                        l_time_zone,
                        l_ts_code,
                        l_start_str,
                        l_date_format,
                        l_end_str,
                        l_date_format,
                        l_units,
                        l_end_str,
                        l_date_format,
                        l_start_str,
                        l_date_format;
            ELSE
               l_query_str :=
               'select local_time as date_time,
                       case
                         when value is nan then null
                         else value + :l_value_offset
                       end "VALUE",
                       cwms_ts.normalize_quality(quality_code) as quality_code
                  from (select date_time,
                               cast(from_tz(cast(date_time as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) as local_time,
                               case
                                  when max(value) keep(dense_rank :first_or_last order by version_date) is nan then null
                                  else max(value) keep(dense_rank :first_or_last order by version_date)
                               end as value,
                               max(quality_code) keep(dense_rank :first_or_last order by version_date) as quality_code
                          from av_tsv_dqu
                         where ts_code    =  :ts_code
                           and date_time  >= to_date(:l_start, :l_date_fmt)
                           and date_time  <= to_date(:l_end,   :l_date_fmt)
                           and unit_id    =  :units
                           and start_date <= to_date(:l_end,   :l_date_fmt)
                           and end_date   >  to_date(:l_start, :l_date_fmt)
                         group by date_time
                       )
                 order by date_time';
               replace_strings;
               cwms_util.check_dynamic_sql(l_query_str);

               OPEN l_cursor FOR l_query_str
                  USING l_value_offset,
                        l_ts_code,
                        l_start_str,
                        l_date_format,
                        l_end_str,
                        l_date_format,
                        l_units,
                        l_end_str,
                        l_date_format,
                        l_start_str,
                        l_date_format;
            END IF;
         END IF;
      ELSE
         --
         -- specified version date
         --
         IF l_interval > 0
         THEN
            --
            -- regular time series
            --
            IF MOD (l_interval, 30) = 0 OR MOD (l_interval, 365) = 0
            THEN
               --
               -- must use calendar math
               --
               -- change interval from days to months
               --
               IF MOD (l_interval, 30) = 0
               THEN
                  l_interval := l_interval / 30;
               ELSE
                  l_interval := l_interval / 365 * 12;
               END IF;

               l_query_str :=
                  'select cast(from_tz(cast(t.date_time as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) "DATE_TIME",
                      case
                         when value is nan then null
                         else value + :l_value_offset
                      end "VALUE",
                      cwms_ts.normalize_quality(nvl(quality_code, :missing)) "QUALITY_CODE"
                 from (
                      select date_time,
                             value,
                             quality_code
                        from av_tsv_dqu
                       where ts_code      =  :ts_code
                         and date_time    >= to_date(:l_start,   :l_date_fmt)
                         and date_time    <= to_date(:l_end,     :l_date_fmt)
                         and unit_id      =  :units
                         and start_date   <= to_date(:l_end,     :l_date_fmt)
                         and end_date     >  to_date(:l_start,   :l_date_fmt)
                         and version_date =  :version
                      ) v
                      right outer join
                      (
                      select cwms_ts.shift_for_localtime(add_months(to_date(:reg_start, :l_date_format), (level-1) * :interval), :tz) date_time
                        from dual
                       where to_date(:reg_start, :l_date_format) is not null
                  connect by level <= months_between(to_date(:reg_start, :l_date_format),
                                                     to_date(:reg_end,   :l_date_format)) / :interval + 1)
                      ) t
                      on v.date_time = t.date_time
                      order by t.date_time asc';
               replace_strings;
               cwms_util.check_dynamic_sql(l_query_str);

               OPEN l_cursor FOR l_query_str
                  USING l_value_offset,
                        l_missing,
                        l_ts_code,
                        l_start_str,
                        l_date_format,
                        l_end_str,
                        l_date_format,
                        l_units,
                        l_end_str,
                        l_date_format,
                        l_start_str,
                        l_date_format,
                        l_version_date,
                        l_reg_start_str,
                        l_date_format,
                        l_interval,
                        l_time_zone,
                        l_reg_start_str,
                        l_date_format,
                        l_reg_start_str,
                        l_date_format,
                        l_reg_end_str,
                        l_date_format,
                        l_interval;
            ELSE
               --
               -- can use date arithmetic
               --
               IF l_strict_times
               THEN
                  l_query_str :=
                  'select date_time,
                          case
                             when value is nan then null
                             else value + :l_value_offset
                          end "VALUE",
                          cwms_ts.normalize_quality(quality_code) as quality_code
                     from ((select cast(from_tz(cast(date_time as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) as date_time,
                                  value,
                                  quality_code
                             from (select t.date_time as date_time,
                                          case
                                             when value is nan then null
                                             else value
                                          end as value,
                                          nvl(quality_code, :missing) as quality_code
                                     from (
                                          select date_time,
                                                 value,
                                                 quality_code
                                            from av_tsv_dqu
                                           where ts_code     =  :ts_code
                                             and date_time   >= to_date(:l_start, :l_date_fmt)
                                             and date_time   <= to_date(:l_end,   :l_date_fmt)
                                             and unit_id     =  :units
                                             and start_date  <= to_date(:l_end,   :l_date_fmt)
                                             and end_date    >  to_date(:l_start, :l_date_fmt)
                                             and version_date = :version
                                          ) v
                                          right outer join
                                          (
                                          select max(date_time) date_time
                                            from (select date_time,
                                                         cwms_util.change_timezone(date_time, ''UTC'', :l_time_zone) local_time
                                                    from (select to_date(:reg_start, :l_date_fmt) + (level-1) * :interval date_time
                                                            from dual
                                                      connect by level <= round((to_date(:reg_end,   :l_date_fmt)
                                                                               - to_date(:reg_start, :l_date_fmt)) / :interval + 1)
                                                         )
                                                 )
                                         group by local_time
                                          ) t
                                          on v.date_time = t.date_time
                                  )
                           )
                           union all
                           (select date_time,
                                   null as value,
                                   :missing as quality_code
                              from (select prev_time + (level + :interval2 / :interval - 1) * :interval as date_time,
                                           level as level_count
                                      from (select date_time,
                                                   prev_time
                                              from (select date_time,
                                                           lag(date_time, 1, null) over (order by date_time) as prev_time,
                                                           date_time - lag(date_time, 1, null) over (order by date_time) as time_diff
                                                      from (select cwms_util.change_timezone(to_date(:reg_start, :l_date_fmt) + (level-1) * :interval2, ''UTC'', :l_timezone) as date_time
                                                              from dual
                                                   connect by level <= round((to_date(:reg_end,   :l_date_fmt)
                                                                            - to_date(:reg_start, :l_date_fmt)) / :interval2 + 1)
                                                           )
                                                   )
                                             where time_diff > greatest(:interval, :interval2)
                                          order by date_time
                                           )
                               connect by level < (date_time - prev_time) / :interval
                                   )
                             where level_count <= round(:interval2 / :interval)
                           ))
                 order by date_time';
                  replace_strings;
                  cwms_util.check_dynamic_sql(l_query_str);

                  OPEN l_cursor FOR l_query_str
                     USING l_value_offset,
                           l_missing,
                           l_ts_code,
                           l_start_str,
                           l_date_format,
                           l_end_str,
                           l_date_format,
                           l_units,
                           l_end_str,
                           l_date_format,
                           l_start_str,
                           l_date_format,
                           l_version_date,
                           l_time_zone,
                           l_reg_start_str,
                           l_date_format,
                           l_interval,
                           l_reg_end_str,
                           l_date_format,
                           l_reg_start_str,
                           l_date_format,
                           l_interval,
                           l_missing,
                           l_interval2,
                           l_interval,
                           l_interval,
                           l_reg_start_str,
                           l_date_format,
                           l_interval2,
                           l_time_zone,
                           l_reg_end_str,
                           l_date_format,
                           l_reg_start_str,
                           l_date_format,
                           l_interval2,
                           l_interval,
                           l_interval2,
                           l_interval,
                           l_interval2,
                           l_interval;
               ELSE
                  l_query_str :=
                  'select cast(from_tz(cast(t.date_time as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) "DATE_TIME",
                          case
                             when value is nan then null
                             else value + :l_value_offset
                          end "VALUE",
                          cwms_ts.normalize_quality(nvl(quality_code, :missing)) "QUALITY_CODE"
                     from (
                          select date_time,
                                 max(value) keep(dense_rank :first_or_last order by version_date) "VALUE",
                                 max(quality_code) keep(dense_rank :first_or_last order by version_date) "QUALITY_CODE"
                            from av_tsv_dqu
                           where ts_code     =  :ts_code
                             and date_time   >= to_date(:l_start, :l_date_fmt)
                             and date_time   <= to_date(:l_end,   :l_date_fmt)
                             and unit_id     =  :units
                             and start_date  <= to_date(:l_end,   :l_date_fmt)
                             and end_date    >  to_date(:l_start, :l_date_fmt)
                             and version_date = :version
                           group by date_time
                          ) v
                          right outer join
                          (select date_time,
                                  cwms_util.change_timezone(date_time, ''UTC'', :l_time_zone) local_time
                             from (select to_date(:reg_start, :l_date_fmt) + (level-1) * :interval date_time
                                     from dual
                               connect by level <= round((to_date(:reg_end,   :l_date_fmt)
                                                        - to_date(:reg_start, :l_date_fmt)) / :interval + 1)
                                  )
                          ) t
                          on v.date_time = t.date_time
                    order by t.date_time asc';
                  replace_strings;
                  cwms_util.check_dynamic_sql(l_query_str);
                  OPEN l_cursor FOR l_query_str
                     USING l_value_offset,
                           l_missing,
                           l_ts_code,
                           l_start_str,
                           l_date_format,
                           l_end_str,
                           l_date_format,
                           l_units,
                           l_end_str,
                           l_date_format,
                           l_start_str,
                           l_date_format,
                           l_version_date,
                           l_time_zone,
                           l_reg_start_str,
                           l_date_format,
                           l_interval,
                           l_reg_end_str,
                           l_date_format,
                           l_reg_start_str,
                           l_date_format,
                           l_interval;
               END IF;
            END IF;
         ELSE
            --
            -- irregular time series
            --
            IF l_strict_times
            THEN
               l_query_str :=
                  'select cast(from_tz(cast(max(date_time) as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) as date_time,
                       max(value) keep(dense_rank last order by date_time) + :l_value_offset as value,
                       cwms_ts.normalize_quality(max(quality_code) keep(dense_rank last order by date_time)) as quality_code
                  from (select date_time,
                               cwms_util.change_timezone(date_time, ''UTC'', :l_time_zone) as local_time,
                               case
                                  when value is nan then null
                                  else value
                               end as value,
                               quality_code
                          from av_tsv_dqu
                         where ts_code     =  :ts_code
                           and date_time   >= to_date(:l_start, :l_date_fmt)
                           and date_time   <= to_date(:l_end,   :l_date_fmt)
                           and unit_id     =  :units
                           and start_date  <= to_date(:l_end,   :l_date_fmt)
                           and end_date    >  to_date(:l_start, :l_date_fmt)
                           and version_date = :version
                      )
             group by local_time
             order by local_time';
               replace_strings;
               cwms_util.check_dynamic_sql(l_query_str);

               OPEN l_cursor FOR l_query_str
                  USING l_value_offset,
                        l_time_zone,
                        l_ts_code,
                        l_start_str,
                        l_date_format,
                        l_end_str,
                        l_date_format,
                        l_units,
                        l_end_str,
                        l_date_format,
                        l_start_str,
                        l_date_format,
                        l_version_date;
            ELSE
               l_query_str :=
                'select local_time as date_time,
                        case
                          when value is nan then null
                          else value + :l_value_offset
                       end "VALUE",
                       cwms_ts.normalize_quality(quality_code) as quality_code
                  from (select date_time,
                               cast(from_tz(cast(date_time as timestamp), ''UTC'') at time zone '':tz'' as :date_time_type) as local_time,
                               case
                                  when max(value) keep(dense_rank :first_or_last order by version_date) is nan then null
                                  else max(value) keep(dense_rank :first_or_last order by version_date)
                               end as value,
                               max(quality_code) keep(dense_rank :first_or_last order by version_date) as quality_code
                          from av_tsv_dqu
                         where ts_code     =  :ts_code
                           and date_time   >= to_date(:l_start, :l_date_fmt)
                           and date_time   <= to_date(:l_end,   :l_date_fmt)
                           and unit_id     =  :units
                           and start_date  <= to_date(:l_end,   :l_date_fmt)
                           and end_date    >  to_date(:l_start, :l_date_fmt)
                           and version_date = :version
                         group by date_time
                       )
                 order by date_time';
               replace_strings;
               cwms_util.check_dynamic_sql(l_query_str);

               OPEN l_cursor FOR l_query_str
                  USING l_value_offset,
                        l_ts_code,
                        l_start_str,
                        l_date_format,
                        l_end_str,
                        l_date_format,
                        l_units,
                        l_end_str,
                        l_date_format,
                        l_start_str,
                        l_date_format,
                        l_version_date;
            END IF;
         END IF;
      END IF;

      RETURN l_cursor;
   END build_retrieve_ts_query;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- RETREIVE_TS_OUT - v2.0 -
   --
   PROCEDURE retrieve_ts_out (
      p_at_tsv_rc            OUT SYS_REFCURSOR,
      p_cwms_ts_id_out       OUT VARCHAR2,
      p_units_out            OUT VARCHAR2,
      p_cwms_ts_id        IN     VARCHAR2,
      p_units             IN     VARCHAR2,
      p_start_time        IN     DATE,
      p_end_time          IN     DATE,
      p_time_zone         IN     VARCHAR2 DEFAULT 'UTC',
      p_trim              IN     VARCHAR2 DEFAULT 'F',
      p_start_inclusive   IN     VARCHAR2 DEFAULT 'T',
      p_end_inclusive     IN     VARCHAR2 DEFAULT 'T',
      p_previous          IN     VARCHAR2 DEFAULT 'F',
      p_next              IN     VARCHAR2 DEFAULT 'F',
      p_version_date      IN     DATE DEFAULT NULL,
      p_max_version       IN     VARCHAR2 DEFAULT 'T',
      p_office_id         IN     VARCHAR2 DEFAULT NULL)
   IS
      l_query_str   VARCHAR2 (4000);

      PROCEDURE set_action (text IN VARCHAR2)
      IS
      BEGIN
         DBMS_APPLICATION_INFO.set_action (text);
         DBMS_OUTPUT.put_line (text);
      END;
   BEGIN
      --
      -- Get the query string
      --
      DBMS_APPLICATION_INFO.set_module ('cwms_ts.retrieve_ts',
                                        'Get query string');

      p_at_tsv_rc :=
         build_retrieve_ts_query (p_cwms_ts_id_out,
                                  p_units_out,
                                  p_cwms_ts_id,
                                  p_units,
                                  p_start_time,
                                  p_end_time,
                                  'date',
                                  p_time_zone,
                                  p_trim,
                                  p_start_inclusive,
                                  p_end_inclusive,
                                  p_previous,
                                  p_next,
                                  p_version_date,
                                  p_max_version,
                                  p_office_id);

      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   END retrieve_ts_out;

   --*******************************************************************   --

   FUNCTION retrieve_ts_out_tab (
      p_cwms_ts_id        IN VARCHAR2,
      p_units             IN VARCHAR2,
      p_start_time        IN DATE,
      p_end_time          IN DATE,
      p_time_zone         IN VARCHAR2 DEFAULT 'UTC',
      p_trim              IN VARCHAR2 DEFAULT 'F',
      p_start_inclusive   IN VARCHAR2 DEFAULT 'T',
      p_end_inclusive     IN VARCHAR2 DEFAULT 'T',
      p_previous          IN VARCHAR2 DEFAULT 'F',
      p_next              IN VARCHAR2 DEFAULT 'F',
      p_version_date      IN DATE DEFAULT NULL,
      p_max_version       IN VARCHAR2 DEFAULT 'T',
      p_office_id         IN VARCHAR2 DEFAULT NULL)
      RETURN zts_tab_t
      PIPELINED
   IS
      query_cursor       SYS_REFCURSOR;
      output_row         zts_rec_t;
      l_cwms_ts_id_out   VARCHAR2 (183);
      l_units_out        VARCHAR2 (16);
   BEGIN
      retrieve_ts_out (p_at_tsv_rc         => query_cursor,
                       p_cwms_ts_id_out    => l_cwms_ts_id_out,
                       p_units_out         => l_units_out,
                       p_cwms_ts_id        => p_cwms_ts_id,
                       p_units             => p_units,
                       p_start_time        => p_start_time,
                       p_end_time          => p_end_time,
                       p_time_zone         => p_time_zone,
                       p_trim              => p_trim,
                       p_start_inclusive   => p_start_inclusive,
                       p_end_inclusive     => p_end_inclusive,
                       p_previous          => p_previous,
                       p_next              => p_next,
                       p_version_date      => p_version_date,
                       p_max_version       => p_max_version,
                       p_office_id         => p_office_id);

      LOOP
         FETCH query_cursor INTO output_row;

         EXIT WHEN query_cursor%NOTFOUND;
         PIPE ROW (output_row);
      END LOOP;

      CLOSE query_cursor;

      RETURN;
   END retrieve_ts_out_tab;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- RETREIVE_TS - v1.4 -
   --
   PROCEDURE retrieve_ts (
      p_at_tsv_rc     IN OUT SYS_REFCURSOR,
      p_units         IN     VARCHAR2,
      p_officeid      IN     VARCHAR2,
      p_cwms_ts_id    IN     VARCHAR2,
      p_start_time    IN     DATE,
      p_end_time      IN     DATE,
      p_timezone      IN     VARCHAR2 DEFAULT 'GMT',
      p_trim          IN     NUMBER DEFAULT cwms_util.false_num,
      p_inclusive     IN     NUMBER DEFAULT NULL,
      p_versiondate   IN     DATE DEFAULT NULL,
      p_max_version   IN     NUMBER DEFAULT cwms_util.true_num)
   IS
      l_trim          VARCHAR2 (1);
      l_max_version   VARCHAR2 (1);
      l_query_str     VARCHAR2 (4000);
      l_tsid          VARCHAR2 (183);
      l_unit          VARCHAR2 (16);

      PROCEDURE set_action (text IN VARCHAR2)
      IS
      BEGIN
         DBMS_APPLICATION_INFO.set_action (text);
         DBMS_OUTPUT.put_line (text);
      END;
   BEGIN
      --
      -- handle input parameters
      --
      DBMS_APPLICATION_INFO.set_module ('cwms_ts.retrieve_ts',
                                        'Handle input parameters');

      IF p_trim IS NULL OR p_trim = cwms_util.false_num
      THEN
         l_trim := 'F';
      ELSIF p_trim = cwms_util.true_num
      THEN
         l_trim := 'T';
      ELSE
         cwms_err.raise ('INVALID_T_F_FLAG_OLD', p_trim);
      END IF;

      IF p_max_version IS NULL OR p_max_version = cwms_util.true_num
      THEN
         l_max_version := 'T';
      ELSIF p_max_version = cwms_util.false_num
      THEN
         l_max_version := 'F';
      ELSE
         cwms_err.raise ('INVALID_T_F_FLAG_OLD', p_max_version);
      END IF;

      --
      -- Get the query string
      --
      DBMS_APPLICATION_INFO.set_module ('cwms_ts.retrieve_ts',
                                        'Get query string');

      p_at_tsv_rc :=
         build_retrieve_ts_query (l_tsid,                  -- p_cwms_ts_id_out
                                  l_unit,                       -- p_units_out
                                  p_cwms_ts_id,                -- p_cwms_ts_id
                                  p_units,                          -- p_units
                                  p_start_time,                -- p_start_time
                                  p_end_time,                    -- p_end_time
                                  'timestamp with time zone', -- p_date_time_type
                                  p_timezone,                   -- p_time_zone
                                  l_trim,                            -- p_trim
                                  'T',                    -- p_start_inclusive
                                  'T',                      -- p_end_inclusive
                                  'F',                           -- p_previous
                                  'F',                               -- p_next
                                  p_versiondate,             -- p_version_date
                                  l_max_version,              -- p_max_version
                                  p_officeid);                  -- p_office_id

      --l_query_str := replace(l_query_str, ':date_time_type', 'timestamp with time zone');
      --
      -- open the cursor
      --
      --set_action('Open cursor');
      --open p_at_tsv_rc for l_query_str;

      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   END retrieve_ts;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- RETREIVE_TS_2 - v1.4 -
   --
   PROCEDURE retrieve_ts_2 (
      p_at_tsv_rc        OUT SYS_REFCURSOR,
      p_units         IN     VARCHAR2,
      p_officeid      IN     VARCHAR2,
      p_cwms_ts_id    IN     VARCHAR2,
      p_start_time    IN     DATE,
      p_end_time      IN     DATE,
      p_timezone      IN     VARCHAR2 DEFAULT 'GMT',
      p_trim          IN     NUMBER DEFAULT cwms_util.false_num,
      p_inclusive     IN     NUMBER DEFAULT NULL,
      p_versiondate   IN     DATE DEFAULT NULL,
      p_max_version   IN     NUMBER DEFAULT cwms_util.true_num)
   IS
      l_at_tsv_rc   SYS_REFCURSOR;
   BEGIN
      retrieve_ts (p_at_tsv_rc,
                   p_units,
                   p_officeid,
                   p_cwms_ts_id,
                   p_start_time,
                   p_end_time,
                   p_timezone,
                   p_trim,
                   p_inclusive,
                   p_versiondate,
                   p_max_version);
   END retrieve_ts_2;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- RETREIVE_TS - v2.0 -
   --
   PROCEDURE retrieve_ts (p_at_tsv_rc            OUT SYS_REFCURSOR,
                          p_cwms_ts_id        IN     VARCHAR2,
                          p_units             IN     VARCHAR2,
                          p_start_time        IN     DATE,
                          p_end_time          IN     DATE,
                          p_time_zone         IN     VARCHAR2 DEFAULT 'UTC',
                          p_trim              IN     VARCHAR2 DEFAULT 'F',
                          p_start_inclusive   IN     VARCHAR2 DEFAULT 'T',
                          p_end_inclusive     IN     VARCHAR2 DEFAULT 'T',
                          p_previous          IN     VARCHAR2 DEFAULT 'F',
                          p_next              IN     VARCHAR2 DEFAULT 'F',
                          p_version_date      IN     DATE DEFAULT NULL,
                          p_max_version       IN     VARCHAR2 DEFAULT 'T',
                          p_office_id         IN     VARCHAR2 DEFAULT NULL)
   IS
      l_cwms_ts_id_out   VARCHAR2 (183);
      l_units_out        VARCHAR2 (16);
      l_at_tsv_rc        SYS_REFCURSOR;
   BEGIN
      retrieve_ts_out (l_at_tsv_rc,
                       l_cwms_ts_id_out,
                       l_units_out,
                       p_cwms_ts_id,
                       p_units,
                       p_start_time,
                       p_end_time,
                       p_time_zone,
                       p_trim,
                       p_start_inclusive,
                       p_end_inclusive,
                       p_previous,
                       p_next,
                       p_version_date,
                       p_max_version,
                       p_office_id);
      p_at_tsv_rc := l_at_tsv_rc;
   END retrieve_ts;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- RETREIVE_TS_MULTI - v2.0 -
   --
   PROCEDURE retrieve_ts_multi (
      p_at_tsv_rc            OUT SYS_REFCURSOR,
      p_timeseries_info   IN     timeseries_req_array,
      p_time_zone         IN     VARCHAR2 DEFAULT 'UTC',
      p_trim              IN     VARCHAR2 DEFAULT 'F',
      p_start_inclusive   IN     VARCHAR2 DEFAULT 'T',
      p_end_inclusive     IN     VARCHAR2 DEFAULT 'T',
      p_previous          IN     VARCHAR2 DEFAULT 'F',
      p_next              IN     VARCHAR2 DEFAULT 'F',
      p_version_date      IN     DATE DEFAULT NULL,
      p_max_version       IN     VARCHAR2 DEFAULT 'T',
      p_office_id         IN     VARCHAR2 DEFAULT NULL)
   IS
      TYPE date_tab_t IS TABLE OF DATE;

      TYPE val_tab_t IS TABLE OF BINARY_DOUBLE;

      TYPE qual_tab_t IS TABLE OF NUMBER;

      TS_ID_NOT_FOUND   EXCEPTION;
      PRAGMA EXCEPTION_INIT (TS_ID_NOT_FOUND, -20001);
      date_tab          date_tab_t := date_tab_t ();
      val_tab           val_tab_t := val_tab_t ();
      qual_tab          qual_tab_t := qual_tab_t ();
      i                 INTEGER;
      j                 PLS_INTEGER;
      t                 nested_ts_table := nested_ts_table ();
      rec               SYS_REFCURSOR;
      l_time_zone       VARCHAR2 (28) := NVL (p_time_zone, 'UTC');
      must_exist        BOOLEAN;
      tsid              VARCHAR2 (183);
   BEGIN
      DBMS_APPLICATION_INFO.set_module ('cwms_ts.retrieve_ts_multi',
                                        'Preparation loop');

      --
      -- This routine actually iterates all the results in order to pack them into
      -- a collection that can be queried to generate the nested cursors.
      --
      -- I used this setup becuase I was not able to get the complex query used in
      --  retrieve_ts_out to work as a cursor expression.
      --
      -- MDP
      -- 01 May 2008
      --
      FOR i IN 1 .. p_timeseries_info.COUNT
      LOOP
         tsid := p_timeseries_info (i).tsid;

         IF SUBSTR (tsid, 1, 1) = '?'
         THEN
            tsid := SUBSTR (tsid, 2);
            must_exist := FALSE;
         ELSE
            must_exist := TRUE;
         END IF;

         t.EXTEND;
         t (i) :=
            nested_ts_type (i,
                            tsid,
                            p_timeseries_info (i).unit,
                            p_timeseries_info (i).start_time,
                            p_timeseries_info (i).end_time,
                            tsv_array ());

         BEGIN
            retrieve_ts_out (rec,
                             t (i).tsid,
                             t (i).units,
                             t (i).tsid,
                             p_timeseries_info (i).unit,
                             p_timeseries_info (i).start_time,
                             p_timeseries_info (i).end_time,
                             p_time_zone,
                             p_trim,
                             p_start_inclusive,
                             p_end_inclusive,
                             p_previous,
                             p_next,
                             p_version_date,
                             p_max_version,
                             p_office_id);

            date_tab.delete;
            val_tab.delete;
            qual_tab.delete;

            FETCH rec
            BULK COLLECT INTO date_tab, val_tab, qual_tab;

            t (i).data.EXTEND (rec%ROWCOUNT);

            FOR j IN 1 .. rec%ROWCOUNT
            LOOP
               t (i).data (j) :=
                  tsv_type (
                     FROM_TZ (CAST (date_tab (j) AS TIMESTAMP), 'UTC'),
                     val_tab (j),
                     qual_tab (j));
            END LOOP;
         EXCEPTION
            WHEN TS_ID_NOT_FOUND
            THEN
               IF NOT must_exist
               THEN
                  NULL;
               END IF;
         END;
      END LOOP;

      OPEN p_at_tsv_rc FOR
           SELECT sequence,
                  tsid,
                  units,
                  start_time,
                  end_time,
                  l_time_zone "TIME_ZONE",
                  CURSOR (  SELECT date_time, VALUE, quality_code
                              FROM TABLE (t1.data)
                          ORDER BY date_time ASC)
                     "DATA"
             FROM TABLE (t) t1
         ORDER BY sequence ASC;

      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   END retrieve_ts_multi;

   --
   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- CLEAN_QUALITY_CODE -
   --
   function clean_quality_code(
      p_quality_code in number)
      return number
      result_cache
   is
      /*
      Data Quality Rules :

          1. Unless the Screened bit is set, no other bits can be set.

          2. Unused bits(22, 24, 27-31, 32+) must be reset(zero).

          3. The Okay, Missing, Questioned and Rejected bits are mutually
             exclusive.

          4. No replacement cause or replacement method bits can be set unless
             the changed(different) bit is also set, and if the changed(different)
             bit is set, one of the cause bits and one of the replacement
             method bits must be set.

          5. Replacement Cause integer is in range 0..4.

          6. Replacement Method integer is in range 0..4

          7. The Test Failed bits are not mutually exclusive(multiple tests can be
             marked as failed).

      Bit Mappings :

               3                   2                   1
           2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1

           P - - - - - T T - T - T T T T T T M M M M C C C D R R V V V V S
           |           <---------+---------> <--+--> <-+-> | <+> <--+--> |
           |                     |              |      |   |  |     |    +------Screened T/F
           |                     |              |      |   |  |     +-----------Validity Flags
           |                     |              |      |   |  +--------------Value Range Integer
           |                     |              |      |   +-------------------Different T/F
           |                     |              |      +---------------Replacement Cause Integer
           |                     |              +---------------------Replacement Method Integer
           |                     +-------------------------------------------Test Failed Flags
           +-------------------------------------------------------------------Protected T/F
      */
      c_used_bits             constant integer := 2204106751; -- 1000 0011 0101 1111 1111 1111 1111 1111
      c_screened              constant integer := 1;          -- 0000 0000 0000 0000 0000 0000 0000 0001
      c_ok                    constant integer := 2;          -- 0000 0000 0000 0000 0000 0000 0000 0010
      c_ok_mask               constant integer := 4294967267; -- 1111 1111 1111 1111 1111 1111 1110 0011
      c_missing               constant integer := 4;          -- 0000 0000 0000 0000 0000 0000 0000 0100
      c_missing_mask          constant integer := 4294967269; -- 1111 1111 1111 1111 1111 1111 1110 0101
      c_questioned            constant integer := 8;          -- 0000 0000 0000 0000 0000 0000 0000 1000
      c_questioned_mask       constant integer := 4294967273; -- 1111 1111 1111 1111 1111 1111 1110 1001
      c_rejected              constant integer := 16;         -- 0000 0000 0000 0000 0000 0000 0001 0000
      c_rejected_mask         constant integer := 4294967281; -- 1111 1111 1111 1111 1111 1111 1111 0001
      c_different_mask        constant integer := 128;        -- 0000 0000 0000 0000 0000 0000 1000 0000
      c_not_different_mask    constant integer := -129;       -- 1111 1111 1111 1111 1111 1111 0111 1111
      c_repl_cause_mask       constant integer := 1792;       -- 0000 0000 0000 0000 0000 0111 0000 0000
      c_no_repl_cause_mask    constant integer := 4294965503; -- 1111 1111 1111 1111 1111 1000 1111 1111
      c_repl_method_mask      constant integer := 30720;      -- 0000 0000 0000 0000 0111 1000 0000 0000
      c_no_repl_method_mask   constant integer := 4294936575; -- 1111 1111 1111 1111 1000 0111 1111 1111
      c_repl_cause_factor     constant integer := 256;        -- 2 ** 8 for shifting 8 bits
      c_repl_method_factor    constant integer := 2048;       -- 2 ** 11 for shifting 11 bits
      l_quality_code                   integer;
      l_repl_cause                     integer;
      l_repl_method                    integer;
      l_different                      boolean;

      function bitor(
         num1 in integer, 
         num2 in integer)
         return integer
      is
      begin
         return num1 + num2 - bitand(num1, num2);
      end;
   begin
      if p_quality_code is null then
         l_quality_code := 0;
      else
         l_quality_code := p_quality_code;
         begin
            --------------------------------------------
            -- first see if the code is already clean --
            --------------------------------------------
            select quality_code
              into l_quality_code
              from cwms_data_quality
             where quality_code = l_quality_code;
         exception
            when no_data_found
            then
               -----------------------------------------------
               -- clear all bits if screened bit is not set --
               -----------------------------------------------
               if bitand(l_quality_code, c_screened) = 0 then
                  l_quality_code := 0;
               else
                  ---------------------------------------------------------------------
                  -- ensure only used bits are set(also counteracts sign-extension) --
                  ---------------------------------------------------------------------
                  l_quality_code := bitand(l_quality_code, c_used_bits);
   
                  -----------------------------------------
                  -- ensure only one validity bit is set --
                  -----------------------------------------
                  if bitand(l_quality_code, c_missing) != 0 then
                     l_quality_code := bitand(l_quality_code, c_missing_mask);
                  elsif bitand(l_quality_code, c_rejected) != 0 then
                     l_quality_code := bitand(l_quality_code, c_rejected_mask);
                  elsif bitand(l_quality_code, c_questioned) != 0 then
                     l_quality_code := bitand(l_quality_code, c_questioned_mask);
                  elsif bitand(l_quality_code, c_ok) != 0 then
                     l_quality_code := bitand(l_quality_code, c_ok_mask);
                  end if;
   
                  --------------------------------------------------------
                  -- ensure the replacement cause is not greater than 4 --
                  --------------------------------------------------------
                  l_repl_cause := trunc(bitand(l_quality_code, c_repl_cause_mask) / c_repl_cause_factor);
   
                  if l_repl_cause > 4 then
                     l_repl_cause := 4;
                     l_quality_code := bitor(bitand(l_quality_code, c_no_repl_cause_mask), l_repl_cause * c_repl_cause_factor);
                  end if;
   
                  ---------------------------------------------------------
                  -- ensure the replacement method is not greater than 4 --
                  ---------------------------------------------------------
                  l_repl_method := trunc(bitand(l_quality_code, c_repl_method_mask)/ c_repl_method_factor);
   
                  if l_repl_method > 4 then
                     l_repl_method := 4;
                     l_quality_code := bitor(bitand(l_quality_code, c_no_repl_method_mask), l_repl_method * c_repl_method_factor);
                  end if;
   
                  --------------------------------------------------------------------------------------------------------------
                  -- ensure that if 2 of replacement cause, replacement method, and different are 0, the remaining one is too --
                  --------------------------------------------------------------------------------------------------------------
                  l_different := bitand(l_quality_code, c_different_mask) != 0;
   
                  if l_repl_cause = 0 then
                     if l_repl_method = 0 and l_different then
                        l_quality_code := bitand(l_quality_code, c_not_different_mask);
                        l_different := false;
                     elsif(not l_different) and l_repl_method != 0 then
                        l_repl_method := 0;
                        l_quality_code := bitand(l_quality_code, c_no_repl_method_mask);
                     end if;
                  elsif l_repl_method = 0 and not l_different then
                     l_repl_cause := 0;
                     l_quality_code := bitand(l_quality_code, c_no_repl_cause_mask);
                  end if;
   
                  ------------------------------------------------------------------------------------------------------------------------------
                  -- ensure that if 2 of replacement cause, replacement method, and different are NOT 0, the remaining one is set accordingly --
                  ------------------------------------------------------------------------------------------------------------------------------
                  if l_repl_cause != 0 then
                     if l_repl_method != 0 and not l_different then
                        l_quality_code := bitor(l_quality_code, c_different_mask);
                        l_different := true;
                     elsif l_different and l_repl_method = 0 then
                        l_repl_method := 2;                           -- EXPLICIT
                        l_quality_code := bitor(l_quality_code, l_repl_method * c_repl_method_factor);
                     end if;
                  elsif l_repl_method != 0 and l_different then
                     l_repl_cause := 3;                                 -- MANUAL
                     l_quality_code := bitor(l_quality_code, l_repl_cause * c_repl_cause_factor);
                  end if;
               end if;
         end;
      end if;

      return l_quality_code;
   end clean_quality_code;

   -------------------------------------------------------------------------------
   -- BOOLEAN FUNCTION USE_FIRST_TABLE(TIMESTAMP)
   --
   FUNCTION use_first_table (p_timestamp IN TIMESTAMP DEFAULT NULL)
      RETURN BOOLEAN
   IS
      pragma autonomous_transaction;
      l_ts_month    integer;
      l_table_month integer;
      l_first_table boolean;
      l_table_ts    timestamp;
   BEGIN
      l_ts_month := to_number(to_char(nvl(p_timestamp, systimestamp), 'MM'));
      l_first_table := mod(l_ts_month, 2) = 1;
      if l_first_table then
         select min(message_time) into l_table_ts from at_ts_msg_archive_1;
      else
         select min(message_time) into l_table_ts from at_ts_msg_archive_2;
      end if;
      l_table_month := to_number(to_char(l_table_ts, 'MM'));
      if l_table_month != l_ts_month then
         execute immediate case l_first_table
                              when true  then 'truncate table at_ts_msg_archive_1'
                              when false then 'truncate table at_ts_msg_archive_2'
                           end;
         commit;
      end if;
      return l_first_table;
   END use_first_table;

   -------------------------------------------------------------------------------
   -- BOOLEAN FUNCTION USE_FIRST_TABLE(VARCHAR2)
   --
   FUNCTION use_first_table (p_timestamp IN INTEGER)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN use_first_table (cwms_util.TO_TIMESTAMP (p_timestamp));
   END use_first_table;
   
   -------------------------------------------------------------------------------
   -- PROCEDURE TIME_SERIES_UPDATED(...)
   --
   PROCEDURE time_series_updated (p_ts_code      IN INTEGER,
                                  p_ts_id        IN VARCHAR2,
                                  p_office_id    IN VARCHAR2,
                                  p_first_time   IN TIMESTAMP WITH TIME ZONE,
                                  p_last_time    IN TIMESTAMP WITH TIME ZONE,
                                  p_version_date IN TIMESTAMP WITH TIME ZONE,
                                  p_store_time   IN TIMESTAMP WITH TIME ZONE,
                                  p_store_rule   IN VARCHAR2)
   IS
      l_msg          SYS.aq$_jms_map_message;
      l_dx_msg       SYS.aq$_jms_map_message;
      l_msgid        PLS_INTEGER;
      l_dx_msgid     PLS_INTEGER;
      l_first_time   TIMESTAMP;
      l_last_time    TIMESTAMP;
      l_version_date TIMESTAMP;
      l_store_time   TIMESTAMP;
      i              INTEGER;
   BEGIN
      -------------------------------------------------------
      -- insert the time series update info into the table --
      -------------------------------------------------------
      l_first_time   := trunc(sys_extract_utc(cwms_util.fixup_timezone(p_first_time)),   'mi');
      l_last_time    := trunc(sys_extract_utc(cwms_util.fixup_timezone(p_last_time)),    'mi');
      l_version_date := trunc(sys_extract_utc(cwms_util.fixup_timezone(p_version_date)), 'mi');
      l_store_time   := sys_extract_utc(cwms_util.fixup_timezone(p_store_time));

      for i in 1..3 loop
         -- try a few times; give up if not successful
         begin
            IF use_first_table
            THEN
               ----------------
               -- odd months --
               ----------------
               INSERT INTO at_ts_msg_archive_1
                    VALUES (cwms_msg.get_msg_id,
                            p_ts_code,
                            SYSTIMESTAMP,
                            CAST (l_first_time AS DATE),
                            CAST (l_last_time AS DATE));
            ELSE
               -----------------
               -- even months --
               -----------------
               INSERT INTO at_ts_msg_archive_2
                    VALUES (cwms_msg.get_msg_id,
                            p_ts_code,
                            SYSTIMESTAMP,
                            CAST (l_first_time AS DATE),
                            CAST (l_last_time AS DATE));
            END IF;
         exception
            when others then
               if sqlcode = -1 then
                  if i < 3 then
                     continue;
                  else
                     cwms_err.raise('ERROR', 'Could not get unique message id in 3 attempts'); 
                  end if; 
               end if;
         end;
         exit; -- no exception
      end loop;

      -------------------------
      -- publish the message --
      -------------------------
      cwms_msg.new_message (l_msg, l_msgid, 'TSDataStored');
      l_msg.set_string (l_msgid, 'ts_id', p_ts_id);
      l_msg.set_string (l_msgid, 'office_id', p_office_id);
      l_msg.set_long (l_msgid, 'ts_code', p_ts_code);
      l_msg.set_long (l_msgid,
                      'start_time',
                      cwms_util.to_millis (l_first_time));
      l_msg.set_long (l_msgid, 'end_time', cwms_util.to_millis (l_last_time));
      l_msg.set_long (l_msgid, 'version_date', cwms_util.to_millis (l_version_date));
      l_msg.set_long (l_msgid, 'store_time', cwms_util.to_millis (l_store_time));
      l_msg.set_string (l_msgid, 'store_rule', p_store_rule);
      i :=
         cwms_msg.publish_message (l_msg,
                                   l_msgid,
                                   p_office_id || '_ts_stored');

      IF cwms_xchg.is_realtime_export (p_ts_code)
      THEN
         -----------------------------------------------
         -- notify the real-time Oracle->DSS exchange --
         -----------------------------------------------
         cwms_msg.new_message (l_dx_msg, l_dx_msgid, 'TSDataStored');
         l_dx_msg.set_string (l_dx_msgid, 'ts_id', p_ts_id);
         l_dx_msg.set_string (l_dx_msgid, 'office_id', p_office_id);
         l_dx_msg.set_long (l_dx_msgid, 'ts_code', p_ts_code);
         l_dx_msg.set_long (l_dx_msgid,
                        'start_time',
                        cwms_util.to_millis (l_first_time));
         l_dx_msg.set_long (l_dx_msgid, 'end_time', cwms_util.to_millis (l_last_time));
         i :=
            cwms_msg.publish_message (l_dx_msg,
                                      l_dx_msgid,
                                      p_office_id || '_realtime_ops');
      END IF;
   END time_series_updated;


   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- STORE_TS -
   --
   --v 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvvvv -
   PROCEDURE store_ts (
      p_office_id         IN VARCHAR2,
      p_cwms_ts_id        IN VARCHAR2,
      p_units             IN VARCHAR2,
      p_timeseries_data   IN tsv_array,
      p_store_rule        IN VARCHAR2,
      p_override_prot     IN NUMBER DEFAULT cwms_util.false_num,
      p_versiondate       IN DATE DEFAULT cwms_util.non_versioned)
   --^ 1.4 ^^^^ 1.4 ^^^^ 1.4 ^^^^ 1.4 ^^^^ 1.4 ^^^^ 1.4 ^^^^^^^ -
   IS
      l_override_prot   VARCHAR2 (1);
   BEGIN
      cwms_apex.aa1 (
            TO_CHAR (SYSDATE, 'YYYY-MM-DD HH24:MI')
         || 'store_ts(1.4): '
         || p_cwms_ts_id);

      IF p_override_prot IS NULL OR p_override_prot = cwms_util.false_num
      THEN
         l_override_prot := 'F';
      ELSIF p_override_prot = cwms_util.true_num
      THEN
         l_override_prot := 'T';
      ELSE
         cwms_err.raise ('INVALID_T_F_FLAG_OLD', p_override_prot);
      END IF;

      DBMS_OUTPUT.put_line ('tag wie gehts2?');
      store_ts (p_cwms_ts_id,
                p_units,
                p_timeseries_data,
                p_store_rule,
                l_override_prot,
                p_versiondate,
                p_office_id);
   END store_ts;                                                    -- v1.4 --

   --
   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- STORE_TS -
   --
   PROCEDURE store_ts (
      p_cwms_ts_id        IN VARCHAR2,
      p_units             IN VARCHAR2,
      p_timeseries_data   IN tsv_array,
      p_store_rule        IN VARCHAR2,
      p_override_prot     IN VARCHAR2 DEFAULT 'F',
      p_version_date      IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id         IN VARCHAR2 DEFAULT NULL)
   IS
      TS_ID_NOT_FOUND       EXCEPTION;
      PRAGMA EXCEPTION_INIT (ts_id_not_found, -20001);
      l_timeseries_data     tsv_array;
      l_cwms_ts_id          VARCHAR2(183);
      l_office_id           VARCHAR2 (16);
      l_office_code         NUMBER;
      l_location_code       NUMBER;
      l_ucount              NUMBER;
      l_store_date          TIMESTAMP (3) DEFAULT SYSTIMESTAMP AT TIME ZONE 'UTC';
      l_ts_code             NUMBER;
      l_interval_id         cwms_interval.interval_id%TYPE;
      l_interval_value      NUMBER;
      l_utc_offset          NUMBER;
      existing_utc_offset   NUMBER;
      mindate               DATE;
      maxdate               DATE;
      l_sql_txt             VARCHAR2 (10000);
      l_override_prot       BOOLEAN;
      l_version_date        DATE;
      --
      l_units               VARCHAR2 (16);
      l_base_parameter_id   VARCHAR2 (16);
      l_base_parameter_code NUMBER(10);
      l_base_unit_id        VARCHAR2 (16);
      --
      l_first_time          DATE;
      l_last_time           DATE;
      l_msg                 SYS.aq$_jms_map_message;
      l_msgid               PLS_INTEGER;
      i                     INTEGER;
      l_millis              NUMBER (14) := cwms_util.to_millis (l_store_date);
      idx                   NUMBER := 0;
      i_max_iterations      NUMBER := 100;
      --
      l_date_times          date_table_type;
      l_min_interval        number;
      l_count               number;
      l_value_offset        binary_double := 0; 
   --
      function bitor (num1 in integer, num2 in integer)
         return integer
      is
      begin
         return num1 + num2 - bitand (num1, num2);
      end;
   BEGIN
      DBMS_APPLICATION_INFO.set_module ('cwms_ts_store.store_ts',
                                        'get tscode from ts_id');
      cwms_apex.aa1 (
            TO_CHAR (SYSDATE, 'YYYY-MM-DD HH24:MI')
         || 'store_ts: '
         || p_cwms_ts_id);

      -- set default values, don't be fooled by NULL as an actual argument


      IF p_office_id IS NULL
      THEN
         l_office_id := cwms_util.user_office_id;

         --
         IF l_office_id = 'UNK'
         THEN
            cwms_err.RAISE ('INVALID_OFFICE_ID', 'Unkown');
         END IF;
      --
      ELSE
         l_office_id := cwms_util.strip(p_office_id);
      END IF;
      l_office_code := CWMS_UTIL.GET_OFFICE_CODE (l_office_id);
                                                                
      begin
         l_cwms_ts_id := clean_ts_id(p_cwms_ts_id);
         l_cwms_ts_id := get_cwms_ts_id(l_cwms_ts_id, l_office_id);
      exception
         when ts_id_not_found then
            null;
      end;                                        

      l_version_date := trunc(NVL(p_version_date, cwms_util.non_versioned), 'mi');
      if l_version_date = cwms_util.all_version_dates then
         cwms_err.raise('ERROR', 'Cannot use CWMS_UTIL.ALL_VERSION_DATES for storing data.');
      end if;

      IF NVL (p_override_prot, 'F') = 'F'
      THEN
         l_override_prot := FALSE;
      ELSE
         l_override_prot := TRUE;
      END IF;

      BEGIN
         SELECT i.interval
           INTO l_interval_value
           FROM cwms_interval i
          WHERE UPPER (i.interval_id) = UPPER (regexp_substr (l_cwms_ts_id, '[^.]+', 1, 4));
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise('INVALID_INTERVAL_ID', regexp_substr (l_cwms_ts_id, '[^.]+', 1, 4));
      END;

      begin
         select base_parameter_code,
                base_parameter_id
           into l_base_parameter_code,
                l_base_parameter_id
           from cwms_base_parameter
          where upper(base_parameter_id) = upper(cwms_util.get_base_id(regexp_substr (l_cwms_ts_id, '[^.]+', 1, 2)));
      exception
         when no_data_found then
            cwms_err.raise('INVALID_PARAM_ID', regexp_substr (l_cwms_ts_id, '[^.]+', 1, 2));
      end;
      if l_base_parameter_code < 0 then
         cwms_err.raise('ERROR', 'Cannot store values to time series with parameter "'||regexp_substr (l_cwms_ts_id, '[^.]+', 1, 2)||'"');
      end if;

      DBMS_APPLICATION_INFO.set_action (
         'Find or create a TS_CODE for your TS Desc');

      BEGIN                                        -- BEGIN - Find the TS_CODE
         l_ts_code :=
            get_ts_code (p_cwms_ts_id       => l_cwms_ts_id,
                         p_db_office_code   => l_office_code);

         SELECT interval_utc_offset
           INTO existing_utc_offset
           FROM at_cwms_ts_spec
          WHERE ts_code = l_ts_code;
      EXCEPTION
         WHEN TS_ID_NOT_FOUND
         THEN
            /*
            Exception is thrown when the Time Series Description passed
            does not exist in the database for the office_id. If this is
            the case a new TS_CODE will be created for the Time Series
            Descriptor.
            */
            create_ts_code (p_ts_code      => l_ts_code,
                            p_office_id    => l_office_id,
                            p_cwms_ts_id   => l_cwms_ts_id,
                            p_utc_offset   => cwms_util.UTC_OFFSET_UNDEFINED);

            existing_utc_offset := cwms_util.UTC_OFFSET_UNDEFINED;
      END;                                               -- END - Find TS_CODE

      IF l_ts_code IS NULL
      THEN
         raise_application_error (
            -20105,
            'Unable to create or locate ts_code for ' || l_cwms_ts_id,
            TRUE);
      END IF;
      

      if p_timeseries_data.count = 0 then
         dbms_application_info.set_action ('Returning due to no data provided');
         return;      -- have already created ts_code if it didn't exist
      end if;

      DBMS_APPLICATION_INFO.set_action ('Check for nulls in incoming data');
      
      l_timeseries_data := tsv_array();
      case get_nulls_storage_policy(l_ts_code)
         when set_null_values_to_missing then
            l_timeseries_data := p_timeseries_data;
            for i in 1..l_timeseries_data.count loop
               if l_timeseries_data(i).value is null then
                  l_timeseries_data(i).quality_code := bitor(l_timeseries_data(i).quality_code, 5);
               end if;
            end loop;
         when reject_ts_with_null_values then
            for i in 1..p_timeseries_data.count loop
               if p_timeseries_data(i).value is null and not cwms_ts.quality_is_missing(p_timeseries_data(i).quality_code) then
                  cwms_err.raise('ERROR', 'Incoming data contains null values with non-missing quality.');
               end if;
            end loop; 
            l_timeseries_data := p_timeseries_data;
         else -- filter_out_null_values or unset
            for i in 1..p_timeseries_data.count loop
               if p_timeseries_data(i).value is not null or cwms_ts.quality_is_missing(p_timeseries_data(i).quality_code) then
                  l_timeseries_data.extend;
                  l_timeseries_data(l_timeseries_data.count) := p_timeseries_data(i);
               end if;
            end loop;
      end case;

      if l_timeseries_data.count = 0 then
         dbms_application_info.set_action ('Returning due to no data passed null filter');
         return;      -- have already created ts_code if it didn't exist
      end if;
      
         
      DBMS_APPLICATION_INFO.set_action (
         'Truncate incoming times to minute and verify validity');
      ---------------------------------------------------------
      -- get the times as date types truncated to the minute --
      ---------------------------------------------------------
      select trunc(cast(date_time at time zone 'UTC' as date), 'mi')
        bulk collect into l_date_times
        from table(l_timeseries_data)
       order by date_time;

      select min(interval)
        into l_min_interval
        from (select column_value - lag(column_value, 1, null) over (order by column_value) as interval
                from table(l_date_times));

      if l_min_interval = 0 then
         cwms_err.raise('ERROR', 'Incoming data has multiple values for same minute.');
      end if;

      IF l_interval_value > 0
      THEN
         DBMS_APPLICATION_INFO.set_action (
            'Incoming data set has a regular interval, confirm data set matches interval_id');

         -----------------------------
         -- test for irregular data --
         -----------------------------
         begin
            select distinct get_utc_interval_offset(column_value, l_interval_value)
              into l_utc_offset
              from table(l_date_times);
         exception
            when too_many_rows then
               raise_application_error (
                  -20110,
                  'ERROR: Incoming data set appears to contain irregular data. Unable to store data for '
                  || l_cwms_ts_id,
                  TRUE);
         end;
         if existing_utc_offset = cwms_util.utc_offset_undefined then
            --------------------
            -- set the offset --
            --------------------
            update at_cwms_ts_spec
               set interval_utc_offset = l_utc_offset
             where ts_code = l_ts_code; 
         else
            -----------------------------
            -- test for invalid offset --
            -----------------------------
            if get_utc_interval_offset(l_date_times(1), l_interval_value) != existing_utc_offset then
               raise_application_error (
                  -20101,
                  'Incoming Data Set''s UTC_OFFSET: '
                  || l_utc_offset
                  || ' does not match its previously stored UTC_OFFSET of: '
                  || existing_utc_offset
                  || ' - data set was NOT stored',
                  TRUE);
            end if;
         end if;


      ELSE
         DBMS_APPLICATION_INFO.set_action ('Incoming data set is irregular');

         l_utc_offset := cwms_util.UTC_OFFSET_IRREGULAR;
      END IF;
                    

      DBMS_APPLICATION_INFO.set_action (
         'getting vertical datum offset if parameter is elevation');
       
      l_units := cwms_util.get_unit_id(p_units, l_office_id);
      if l_units is null then l_units := p_units; end if;
      if l_base_parameter_id = 'Elev' then
         l_location_code := cwms_loc.get_location_code(l_office_code, cwms_Util.split_text(l_cwms_ts_id, 1, '.', 1));
         l_value_offset  := cwms_loc.get_vertical_datum_offset(l_location_code, l_units);
      end if;

      DBMS_APPLICATION_INFO.set_action (
         'check p_units is a valid unit for this parameter');
         
      SELECT a.base_parameter_id
        INTO l_base_parameter_id
        FROM cwms_base_parameter a, at_parameter b, at_cwms_ts_spec c
       WHERE     A.BASE_PARAMETER_CODE = B.BASE_PARAMETER_CODE
             AND B.PARAMETER_CODE = C.PARAMETER_CODE
             AND c.ts_code = l_ts_code;

      l_units := cwms_util.get_valid_unit_id (l_units, l_base_parameter_id);

      DBMS_APPLICATION_INFO.set_action ('check for unit conversion factors');


      SELECT COUNT (*)
        INTO l_ucount
        FROM at_cwms_ts_spec s,
             at_parameter ap,
             cwms_unit_conversion c,
             cwms_base_parameter p,
             cwms_unit u
       WHERE     s.ts_code = l_ts_code
             AND s.parameter_code = ap.parameter_code
             AND ap.base_parameter_code = p.base_parameter_code
             AND p.unit_code = c.from_unit_code
             AND c.to_unit_code = u.unit_code
             AND u.unit_id = l_units;


      IF l_ucount <> 1
      THEN
         SELECT unit_id
           INTO l_base_unit_id
           FROM cwms_unit a, cwms_base_parameter b
          WHERE     A.UNIT_CODE = B.UNIT_CODE
                AND B.BASE_PARAMETER_ID = l_base_parameter_id;

         raise_application_error (
            -20103,
               'Unit conversion from '
            || l_units
            || ' to the CWMS Database Base Units of '
            || l_base_unit_id
            || ' is not available for the '
            || l_base_parameter_id
            || ' parameter_id.',
            TRUE);
      END IF;

      --
      -- Determine the min and max date in the dataset, convert
      -- the min and max dates to GMT dates.
      -- The min and max dates are used to determine which
      -- at_tsv tables need to be accessed during the store.
      --

      SELECT MIN (trunc(CAST ( (t.date_time AT TIME ZONE 'UTC') AS DATE), 'mi')),
             MAX (trunc(CAST ( (t.date_time AT TIME ZONE 'UTC') AS DATE), 'mi'))
        INTO mindate, maxdate
        FROM TABLE (CAST (l_timeseries_data AS tsv_array)) t;

      DBMS_OUTPUT.put_line (
            '*****************************'
         || CHR (10)
         || 'IN STORE_TS'
         || CHR (10)
         || 'TS Description: '
         || l_cwms_ts_id
         || CHR (10)
         || '       TS CODE: '
         || l_ts_code
         || CHR (10)
         || '    Store Rule: '
         || p_store_rule
         || CHR (10)
         || '      Override: '
         || p_override_prot
         || CHR (10)
         || '*****************************');

      /*
     A WHILE LOOP was added to catch primary key violations when multiple
     threads are simultaneously processing data for the same ts code and
     the data blocks have overlapping time windows. The loop allows    
     repeated attempts to store the data block, with the hope that the
     initial data block that successfully stored data for the overlapping
     date/times has finally completed and COMMITed the inserts. If after
     i_max_iterations, the dup_value_on_index exception is still being
     thrown, then the loop ends and the dup_value_on_index exception is
     raised one last time.
     */
      WHILE idx < i_max_iterations
      LOOP
         BEGIN
      CASE
         WHEN     l_override_prot
              AND UPPER (p_store_rule) = cwms_util.replace_all
         THEN
            --
            --**********************************
            -- CASE 1 - Store Rule: REPLACE ALL
            --          Override:   TRUE
            --**********************************
            --
            DBMS_APPLICATION_INFO.set_action (
               'merge into table, override, replace_all ');

                  FOR x
                     IN (SELECT start_date, end_date, table_name
                        FROM at_ts_table_properties
                       WHERE start_date <= maxdate AND end_date > mindate)
            LOOP
               l_sql_txt :=
                     'merge into ' || x.table_name || ' t1
                           using (select trunc(cast((cwms_util.fixup_timezone(t.date_time) at time zone ''GMT'') as date), ''mi'') date_time,
                                         (t.value * c.factor + c.offset) - :l_value_offset value,
                                         cwms_ts.clean_quality_code(t.quality_code) quality_code
                                    from table(cast(:l_timeseries_data as tsv_array)) t,
                                         at_cwms_ts_spec s,
                                         at_parameter ap,
                                         cwms_unit_conversion c,
                                         cwms_base_parameter p,
                                         cwms_unit u
                                   where cwms_util.is_nan(t.value) = ''F''
                                     and s.ts_code = :l_ts_code
                                     and s.parameter_code = ap.parameter_code
                                     and ap.base_parameter_code = p.base_parameter_code
                                     and p.unit_code = c.to_unit_code
                                     and c.from_unit_code = u.unit_code
                                     and u.unit_id = :l_units
                                     and date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                                     and date_time < from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                              on (t1.ts_code = :l_ts_code and t1.date_time = t2.date_time and t1.version_date = :l_version_date)
                      when matched then
                         update set t1.value = t2.value, t1.data_entry_date = :l_store_date, t1.quality_code = t2.quality_code
                      when not matched then
                         insert     (  ts_code,
                                       date_time,
                                       data_entry_date,
                                       value,
                                       quality_code,
                                       version_date)
                             values (  :l_ts_code,
                                       t2.date_time,
                                       :l_store_date,
                                       t2.value,
                                       t2.quality_code,
                                       :l_version_date)';
               cwms_util.check_dynamic_sql(l_sql_txt);

               EXECUTE IMMEDIATE l_sql_txt
                  USING l_value_offset,
                        l_timeseries_data,
                        l_ts_code,
                        l_units,
                        x.start_date,
                        x.end_date,
                        l_ts_code,
                        l_version_date,
                        l_store_date,
                        l_ts_code,
                        l_store_date,
                        l_version_date;
            END LOOP;
         WHEN     NOT l_override_prot
              AND UPPER (p_store_rule) = cwms_util.replace_all
         THEN
            --
            --*************************************
            -- CASE 2 - Store Rule: REPLACE ALL -
            --         Override:   FALSE -
            --*************************************
            --
            DBMS_APPLICATION_INFO.set_action (
               'CASE 2: merge into  table, no override, replace_all ');

                  FOR x
                     IN (SELECT start_date, end_date, table_name
                        FROM at_ts_table_properties
                       WHERE start_date <= maxdate AND end_date > mindate)
            LOOP
               l_sql_txt :=
                     'merge into ' || x.table_name || ' t1
                           using (select trunc(cast((cwms_util.fixup_timezone(t.date_time) at time zone ''GMT'') as date), ''mi'') date_time,
                                         (t.value * c.factor + c.offset)  - :l_value_offset value,
                                         cwms_ts.clean_quality_code(t.quality_code) quality_code
                                    from table(cast(:l_timeseries_data as tsv_array)) t,
                                         at_cwms_ts_spec s,
                                         at_parameter ap,
                                         cwms_unit_conversion c,
                                         cwms_base_parameter p,
                                         cwms_unit u
                                   where cwms_util.is_nan(t.value) = ''F''
                                     and s.ts_code = :l_ts_code
                                     and s.parameter_code = ap.parameter_code
                                     and ap.base_parameter_code = p.base_parameter_code
                                     and p.unit_code = c.to_unit_code
                                     and c.from_unit_code = u.unit_code
                                     and u.unit_id = :l_units
                                     and date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                                     and date_time < from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                              on (t1.ts_code = :l_ts_code and t1.date_time = t2.date_time and t1.version_date = :l_version_date)
                      when matched then
                         update set t1.value = t2.value, t1.data_entry_date = :l_store_date, t1.quality_code = t2.quality_code
                                 where (t1.quality_code in (select quality_code
                                                              from cwms_data_quality q
                                                             where q.protection_id = ''UNPROTECTED''))
                                    or (t2.quality_code in (select quality_code
                                                              from cwms_data_quality q
                                                             where q.protection_id = ''PROTECTED''))
                      when not matched then
                         insert     (  ts_code,
                                       date_time,
                                       data_entry_date,
                                       value,
                                       quality_code,
                                       version_date)
                             values (  :l_ts_code,
                                       t2.date_time,
                                       :l_store_date,
                                       t2.value,
                                       t2.quality_code,
                                       :l_version_date)';
               cwms_util.check_dynamic_sql(l_sql_txt);
               EXECUTE IMMEDIATE l_sql_txt
                  USING l_value_offset,
                        l_timeseries_data,
                        l_ts_code,
                        l_units,
                        x.start_date,
                        x.end_date,
                        l_ts_code,
                        l_version_date,
                        l_store_date,
                        l_ts_code,
                        l_store_date,
                        l_version_date;
            END LOOP;
         WHEN UPPER (p_store_rule) = cwms_util.do_not_replace
         THEN
            --
            --*************************************
            -- CASE 3 - Store Rule: DO NOT REPLACE
            --*************************************
            --
            DBMS_APPLICATION_INFO.set_action (
               'merge into table, do_not_replace ');

                  FOR x
                     IN (SELECT start_date, end_date, table_name
                        FROM at_ts_table_properties
                       WHERE start_date <= maxdate AND end_date > mindate)
            LOOP
               l_sql_txt :=
                     'merge into ' || x.table_name || ' t1
                           using (select trunc(cast((cwms_util.fixup_timezone(t.date_time) at time zone ''GMT'') as date), ''mi'') date_time,
                                         (t.value * c.factor + c.offset) - :l_value_offset value,
                                         cwms_ts.clean_quality_code(t.quality_code) quality_code
                                    from table(cast(:l_timeseries_data as tsv_array)) t,
                                         at_cwms_ts_spec s,
                                         at_parameter ap,
                                         cwms_unit_conversion c,
                                         cwms_base_parameter p,
                                         cwms_unit u
                                   where cwms_util.is_nan(t.value) = ''F''
                                     and s.ts_code = :l_ts_code
                                     and s.parameter_code = ap.parameter_code
                                     and ap.base_parameter_code = p.base_parameter_code
                                     and p.unit_code = c.to_unit_code
                                     and c.from_unit_code = u.unit_code
                                     and u.unit_id = :l_units
                                     and date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                                     and date_time < from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                              on (t1.ts_code = :l_ts_code and t1.date_time = t2.date_time and t1.version_date = :l_version_date)
                      when not matched then
                         insert     (  ts_code,
                                       date_time,
                                       data_entry_date,
                                       value,
                                       quality_code,
                                       version_date)
                             values (  :l_ts_code,
                                       t2.date_time,
                                       :l_store_date,
                                       t2.value,
                                       t2.quality_code,
                                       :l_version_date)';
               cwms_util.check_dynamic_sql(l_sql_txt);

               EXECUTE IMMEDIATE l_sql_txt
                  USING l_value_offset,
                        l_timeseries_data,
                        l_ts_code,
                        l_units,
                        x.start_date,
                        x.end_date,
                        l_ts_code,
                        l_version_date,
                        l_ts_code,
                        l_store_date,
                        l_version_date;
            END LOOP;
               WHEN UPPER (p_store_rule) =
                       cwms_util.replace_missing_values_only
         THEN
            --
            --***************************************************
            -- CASE 4 - Store Rule: REPLACE MISSING VALUES ONLY -
            --***************************************************
            --
            DBMS_APPLICATION_INFO.set_action (
               'merge into table, replace_missing_values_only');

                  FOR x
                     IN (SELECT start_date, end_date, table_name
                        FROM at_ts_table_properties
                       WHERE start_date <= maxdate AND end_date > mindate)
            LOOP
               if not l_override_prot then
                  --
                  --***************************************************
                  -- CASE 4a - Store Rule: REPLACE MISSING VALUES ONLY -
                  --           Override:   FALSE
                  --***************************************************
                  --
                  l_sql_txt :=
                        'merge into ' || x.table_name || ' t1
                              using (select trunc(cast((cwms_util.fixup_timezone(t.date_time) at time zone ''GMT'') as date), ''mi'') date_time,
                                            (t.value * c.factor + c.offset) - :l_value_offset value,
                                            cwms_ts.clean_quality_code(t.quality_code) quality_code
                                       from table(cast(:l_timeseries_data as tsv_array)) t,
                                            at_cwms_ts_spec s,
                                            at_parameter ap,
                                            cwms_unit_conversion c,
                                            cwms_base_parameter p,
                                            cwms_unit u
                                      where cwms_util.is_nan(t.value) = ''F''
                                        and s.ts_code = :l_ts_code
                                        and s.parameter_code = ap.parameter_code
                                        and ap.base_parameter_code = p.base_parameter_code
                                        and p.unit_code = c.to_unit_code
                                        and c.from_unit_code = u.unit_code
                                        and u.unit_id = :l_units
                                        and date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                                        and date_time < from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                                 on (t1.ts_code = :l_ts_code and t1.date_time = t2.date_time and t1.version_date = :l_version_date)
                         when matched then
                            update set t1.value = t2.value, t1.quality_code = t2.quality_code, t1.data_entry_date = :l_store_date
                                    where t1.quality_code in (select quality_code
                                                                from cwms_data_quality q
                                                               where q.validity_id = ''MISSING'')
                                      and ((t1.quality_code in (select quality_code
                                                                  from cwms_data_quality q
                                                                 where q.protection_id = ''UNPROTECTED''))
                                        or (t2.quality_code in (select quality_code
                                                                  from cwms_data_quality q
                                                                 where q.protection_id = ''PROTECTED'')))
                         when not matched then
                            insert     (  ts_code,
                                          date_time,
                                          data_entry_date,
                                          value,
                                          quality_code,
                                          version_date)
                                values (  :l_ts_code,
                                          t2.date_time,
                                          :l_store_date,
                                          t2.value,
                                          t2.quality_code,
                                          :l_version_date)';
               else
                  --
                  --***************************************************
                  -- CASE 4b - Store Rule: REPLACE MISSING VALUES ONLY -
                  --           Override:   TRUE
                  --***************************************************
                  --
                  l_sql_txt :=
                        'merge into ' || x.table_name || ' t1
                              using (select trunc(cast((cwms_util.fixup_timezone(t.date_time) at time zone ''GMT'') as date), ''mi'') date_time,
                                            (t.value * c.factor + c.offset) - :l_value_offset value,
                                            cwms_ts.clean_quality_code(t.quality_code) quality_code
                                       from table(cast(:l_timeseries_data as tsv_array)) t,
                                            at_cwms_ts_spec s,
                                            at_parameter ap,
                                            cwms_unit_conversion c,
                                            cwms_base_parameter p,
                                            cwms_unit u
                                      where cwms_util.is_nan(t.value) = ''F''
                                        and s.ts_code = :l_ts_code
                                        and s.parameter_code = ap.parameter_code
                                        and ap.base_parameter_code = p.base_parameter_code
                                        and p.unit_code = c.to_unit_code
                                        and c.from_unit_code = u.unit_code
                                        and u.unit_id = :l_units
                                        and date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                                        and date_time < from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                                 on (t1.ts_code = :l_ts_code and t1.date_time = t2.date_time and t1.version_date = :l_version_date)
                         when matched then
                            update set t1.value = t2.value, t1.quality_code = t2.quality_code, t1.data_entry_date = :l_store_date
                                    where t1.quality_code in (select quality_code
                                                                from cwms_data_quality q
                                                               where q.validity_id = ''MISSING'')
                         when not matched then
                            insert     (  ts_code,
                                          date_time,
                                          data_entry_date,
                                          value,
                                          quality_code,
                                          version_date)
                                values (  :l_ts_code,
                                          t2.date_time,
                                          :l_store_date,
                                          t2.value,
                                          t2.quality_code,
                                          :l_version_date)';
               end if;
               cwms_util.check_dynamic_sql(l_sql_txt);

               EXECUTE IMMEDIATE l_sql_txt
                  USING l_value_offset,
                        l_timeseries_data,
                        l_ts_code,
                        l_units,
                        x.start_date,
                        x.end_date,
                        l_ts_code,
                        l_version_date,
                        l_store_date,
                        l_ts_code,
                        l_store_date,
                        l_version_date;
            END LOOP;
         WHEN     l_override_prot
                    AND UPPER (p_store_rule) =
                           cwms_util.replace_with_non_missing
         THEN
            --
            --*******************************************
            -- CASE 5 - Store Rule: REPLACE W/NON-MISSING -
            --         Override:   TRUE -
            --*******************************************
            --
            DBMS_APPLICATION_INFO.set_action (
               'merge into table, override, replace_with_non_missing ');

                  FOR x
                     IN (SELECT start_date, end_date, table_name
                        FROM at_ts_table_properties
                       WHERE start_date <= maxdate AND end_date > mindate)
            LOOP
               l_sql_txt :=
                     'merge into ' || x.table_name || ' t1
                           using (select trunc(cast((cwms_util.fixup_timezone(t.date_time) at time zone ''GMT'') as date), ''mi'') date_time,
                                         (t.value * c.factor + c.offset) - :l_value_offset value,
                                         cwms_ts.clean_quality_code(t.quality_code) quality_code
                                    from table(cast(:l_timeseries_data as tsv_array)) t,
                                         at_cwms_ts_spec s,
                                         at_parameter ap,
                                         cwms_unit_conversion c,
                                         cwms_base_parameter p,
                                         cwms_unit u,
                                         cwms_data_quality q
                                   where cwms_util.is_nan(t.value) = ''F''
                                     and t.value is not null
                                     and cwms_ts.quality_is_missing_text(t.quality_code) = ''F''
                                     and s.ts_code = :l_ts_code
                                     and s.parameter_code = ap.parameter_code
                                     and ap.base_parameter_code = p.base_parameter_code
                                     and q.quality_code = t.quality_code
                                     and p.unit_code = c.to_unit_code
                                     and c.from_unit_code = u.unit_code
                                     and u.unit_id = :l_units
                                     and date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                                     and date_time < from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                              on (t1.ts_code = :l_ts_code and t1.date_time = t2.date_time and t1.version_date = :l_version_date)
                      when matched then
                         update set t1.value = t2.value, t1.data_entry_date = :l_store_date, t1.quality_code = t2.quality_code
                                 where t2.quality_code not in (select quality_code
                                                                 from cwms_data_quality
                                                                where validity_id = ''MISSING'')
                      when not matched then
                         insert     (  ts_code,
                                       date_time,
                                       data_entry_date,
                                       value,
                                       quality_code,
                                       version_date)
                             values (  :l_ts_code,
                                       t2.date_time,
                                       :l_store_date,
                                       t2.value,
                                       t2.quality_code,
                                       :l_version_date)';
               cwms_util.check_dynamic_sql(l_sql_txt);

               EXECUTE IMMEDIATE l_sql_txt
                  USING l_value_offset,
                        l_timeseries_data,
                        l_ts_code,
                        l_units,
                        x.start_date,
                        x.end_date,
                        l_ts_code,
                        l_version_date,
                        l_store_date,
                        l_ts_code,
                        l_store_date,
                        l_version_date;
            END LOOP;
         WHEN     NOT l_override_prot
                    AND UPPER (p_store_rule) =
                           cwms_util.replace_with_non_missing
         THEN
            --
            --*******************************************
            -- Case 6 - Store Rule: Replace w/Non-Missing -
            --         Override:   FALSE -
            --*******************************************
            --
            DBMS_APPLICATION_INFO.set_action (
               'merge into table, no override, replace_with_non_missing ');

                  FOR x
                     IN (SELECT start_date, end_date, table_name
                        FROM at_ts_table_properties
                       WHERE start_date <= maxdate AND end_date > mindate)
            LOOP
               l_sql_txt :=
                     'merge into ' || x.table_name || ' t1
                           using (select trunc(cast((cwms_util.fixup_timezone(t.date_time) at time zone ''GMT'') as date), ''mi'') date_time,
                                         (t.value * c.factor + c.offset) - :l_value_offset value,
                                         cwms_ts.clean_quality_code(t.quality_code) quality_code
                                    from table(cast(:l_timeseries_data as tsv_array)) t,
                                         at_cwms_ts_spec s,
                                         at_parameter ap,
                                         cwms_unit_conversion c,
                                         cwms_base_parameter p,
                                         cwms_unit u,
                                         cwms_data_quality q
                                   where cwms_util.is_nan(t.value) = ''F''
                                     and t.value is not null
                                     and cwms_ts.quality_is_missing_text(t.quality_code) = ''F''
                                     and s.ts_code = :l_ts_code
                                     and s.parameter_code = ap.parameter_code
                                     and ap.base_parameter_code = p.base_parameter_code
                                     and q.quality_code = t.quality_code
                                     and p.unit_code = c.to_unit_code
                                     and c.from_unit_code = u.unit_code
                                     and u.unit_id = :l_units
                                     and date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                                     and date_time < from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                              on (t1.ts_code = :l_ts_code and t1.date_time = t2.date_time and t1.version_date = :l_version_date)
                      when matched then
                         update set t1.value = t2.value, t1.data_entry_date = :l_store_date, t1.quality_code = t2.quality_code
                                 where ((t1.quality_code in (select quality_code
                                                               from cwms_data_quality q
                                                              where q.protection_id = ''UNPROTECTED''))
                                     or (t2.quality_code in (select quality_code
                                                               from cwms_data_quality q
                                                              where q.protection_id = ''PROTECTED'')))
                                   and (t2.quality_code not in (select quality_code
                                                                  from cwms_data_quality q
                                                                 where q.validity_id = ''MISSING''))
                      when not matched then
                         insert     (  ts_code,
                                       date_time,
                                       data_entry_date,
                                       value,
                                       quality_code,
                                       version_date)
                             values (  :l_ts_code,
                                       t2.date_time,
                                       :l_store_date,
                                       t2.value,
                                       t2.quality_code,
                                       :l_version_date)';
               cwms_util.check_dynamic_sql(l_sql_txt);
               EXECUTE IMMEDIATE l_sql_txt
                  USING l_value_offset,
                        l_timeseries_data,
                        l_ts_code,
                        l_units,
                        x.start_date,
                        x.end_date,
                        l_ts_code,
                        l_version_date,
                        l_store_date,
                        l_ts_code,
                        l_store_date,
                        l_version_date;
            END LOOP;
         WHEN     NOT l_override_prot
              AND UPPER (p_store_rule) = cwms_util.delete_insert
         THEN
            --
            --*************************************
            -- CASE 7 - Store Rule: DELETE - INSERT -
            --         Override:   FALSE -
            --*************************************
            --
            DBMS_APPLICATION_INFO.set_action (
               'delete/merge from table, no override, delete_insert ');

                  FOR x
                     IN (SELECT start_date, end_date, table_name
                        FROM at_ts_table_properties
                       WHERE start_date <= maxdate AND end_date > mindate)
            LOOP
               EXECUTE IMMEDIATE REPLACE (
                  'insert
                     into at_ts_deleted_times
                   select :millis,
                          :ts_code,
                          :version_date,
                          t1.date_time
                     from table_name t1
                    where t1.ts_code = :ts_code
                      and t1.version_date = :version_date
                      and t1.date_time between
                          (SELECT MIN (trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi''))
                             FROM TABLE (CAST (:timeseries_data AS tsv_array)) t)
                          and
                          (SELECT MAX (trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi''))
                             FROM TABLE (CAST (:timeseries_data AS tsv_array)) t)
                      and t1.quality_code NOT IN (SELECT quality_code
                                                   FROM cwms_data_quality q
                                                  WHERE q.protection_id = ''PROTECTED'')',
                                   'table_name',
                                   x.table_name)
                  USING l_millis,
                        l_ts_code,
                        l_version_date,
                        l_ts_code,
                        l_version_date,
                        p_timeseries_data, -- get the ENTIRE time window of incoming data, even if it was trimmed by filtering NULLs
                        p_timeseries_data;

               EXECUTE IMMEDIATE REPLACE (
                  'delete
                     from table_name t1
                    where t1.ts_code = :ts_code
                      and t1.version_date = :version_date
                      and t1.date_time between
                          (SELECT MIN (trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi''))
                             FROM TABLE (CAST (:timeseries_data AS tsv_array)) t)
                          and
                          (SELECT MAX (trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi''))
                             FROM TABLE (CAST (:timeseries_data AS tsv_array)) t)
                      and t1.quality_code NOT IN (SELECT quality_code
                                                   FROM cwms_data_quality q
                                                  WHERE q.protection_id = ''PROTECTED'')',
                                   'table_name',
                                   x.table_name)
                  USING l_ts_code,
                        l_version_date,
                        p_timeseries_data, -- get the ENTIRE time window of incoming data, even if it was trimmed by filtering NULLs
                        p_timeseries_data;

               EXECUTE IMMEDIATE REPLACE (
                  'MERGE INTO table_name t1
                     USING (SELECT trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi'') as date_time,
                                   (t.value * c.factor + c.offset) - :l_value_offset as value,
                                   cwms_ts.clean_quality_code(t.quality_code) as quality_code
                              FROM TABLE (CAST (:timeseries_data AS tsv_array)) t,
                                   at_cwms_ts_spec s,
                                   at_parameter ap,
                                   cwms_unit_conversion c,
                                   cwms_base_parameter p,
                                   cwms_unit u
                             WHERE cwms_util.is_nan(t.value) = ''F''
                               AND s.ts_code = :ts_code
                               AND s.parameter_code = ap.parameter_code
                               AND ap.base_parameter_code = p.base_parameter_code
                               AND p.unit_code = c.to_unit_code
                               AND c.from_unit_code = u.unit_code
                               AND u.unit_id = :units
                               AND date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                               AND date_time <  from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                     ON (    t1.ts_code = :ts_code
                         AND t1.date_time = t2.date_time
                         AND t1.version_date = :version_date)
                     WHEN NOT MATCHED THEN
                        INSERT (ts_code, date_time, version_date, data_entry_date, value, quality_code)
                        VALUES (:ts_code, t2.date_time, :version_date, :store_date, t2.value, t2.quality_code)
                     WHEN MATCHED THEN
                        UPDATE
                           SET t1.VALUE = t2.VALUE,
                               t1.quality_code = t2.quality_code,
                               t1.data_entry_date = :store_date
                         WHERE ( (  t1.value != t2.value
                                    OR
                                    t1.quality_code != t2.quality_code
                                 )
                                 AND
                                 (  t1.quality_code NOT IN (SELECT quality_code
                                                              FROM cwms_data_quality q
                                                             WHERE q.protection_id = ''PROTECTED'')
                                    OR
                                    t2.quality_code IN (SELECT quality_code
                                                          FROM cwms_data_quality q
                                                         WHERE q.protection_id = ''PROTECTED'')
                                 )
                               )',
                                   'table_name',
                                   x.table_name)
                  USING l_value_offset,
                        l_timeseries_data,
                        l_ts_code,
                        l_units,
                        x.start_date,
                        x.end_date,
                        l_ts_code,
                        l_version_date,
                        l_ts_code,
                        l_version_date,
                        l_store_date,
                        l_store_date;
            END LOOP;
         WHEN     l_override_prot
              AND UPPER (p_store_rule) = cwms_util.delete_insert
         THEN
            --
            --*************************************
            --CASE 8 - Store Rule: DELETE - INSERT -
            --         Override:   TRUE -
            --*************************************
            --
            DBMS_APPLICATION_INFO.set_action (
               'delete/merge from  table, override, delete_insert ');

                  FOR x
                     IN (SELECT start_date, end_date, table_name
                        FROM at_ts_table_properties
                       WHERE start_date <= maxdate AND end_date > mindate)
            LOOP
               EXECUTE IMMEDIATE REPLACE (
                  'insert
                     into at_ts_deleted_times
                   select :millis,
                          :ts_code,
                          :version_date,
                          t1.date_time
                     from table_name t1
                    where t1.ts_code = :ts_code
                      and t1.version_date = :version_date
                      and t1.date_time between
                          (SELECT MIN (trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi''))
                             FROM TABLE (CAST (:timeseries_data AS tsv_array)) t)
                          and
                          (SELECT MAX (trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi''))
                             FROM TABLE (CAST (:timeseries_data AS tsv_array)) t)',
                                   'table_name',
                                   x.table_name)
                  USING l_millis,
                        l_ts_code,
                        l_version_date,
                        l_ts_code,
                        l_version_date,
                        p_timeseries_data, -- get the ENTIRE time window of incoming data, even if it was trimmed by filtering NULLs
                        p_timeseries_data;

               EXECUTE IMMEDIATE REPLACE (
                  'delete
                     from table_name t1
                    where t1.ts_code = :ts_code
                      and t1.version_date = :version_date
                      and t1.date_time between
                          (SELECT MIN (trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi''))
                             FROM TABLE (CAST (:timeseries_data AS tsv_array)) t)
                          and
                          (SELECT MAX (trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi''))
                             FROM TABLE (CAST (:timeseries_data AS tsv_array)) t)',
                                   'table_name',
                                   x.table_name)
                  USING l_ts_code,
                        l_version_date,
                        p_timeseries_data, -- get the ENTIRE time window of incoming data, even if it was trimmed by filtering NULLs
                        p_timeseries_data;

               EXECUTE IMMEDIATE REPLACE (
                  'MERGE INTO table_name t1
                     USING (SELECT trunc(CAST ((cwms_util.fixup_timezone(t.date_time) AT TIME ZONE ''GMT'') AS DATE), ''mi'') as date_time,
                                   (t.value * c.factor + c.offset) - :l_value_offset as value,
                                   cwms_ts.clean_quality_code(t.quality_code) as quality_code
                              FROM TABLE (CAST (:timeseries_data AS tsv_array)) t,
                                   at_cwms_ts_spec s,
                                   at_parameter ap,
                                   cwms_unit_conversion c,
                                   cwms_base_parameter p,
                                   cwms_unit u
                             WHERE cwms_util.is_nan(t.value) = ''F''
                               AND s.ts_code = :ts_code
                               AND s.parameter_code = ap.parameter_code
                               AND ap.base_parameter_code = p.base_parameter_code
                               AND p.unit_code = c.to_unit_code
                               AND c.from_unit_code = u.unit_code
                               AND u.unit_id = :units
                               AND date_time >= from_tz(cast(:start_date as timestamp), ''UTC'')
                               AND date_time <  from_tz(cast(:end_date as timestamp), ''UTC'')) t2
                     ON (    t1.ts_code = :ts_code
                         AND t1.date_time = t2.date_time
                         AND t1.version_date = :version_date)
                     WHEN NOT MATCHED THEN
                        INSERT (ts_code, date_time, version_date, data_entry_date, value, quality_code)
                        VALUES (:ts_code, t2.date_time, :version_date, :store_date, t2.value, t2.quality_code)
                     WHEN MATCHED THEN
                        UPDATE
                           SET t1.VALUE = t2.VALUE,
                               t1.quality_code = t2.quality_code,
                               t1.data_entry_date = :store_date
                         WHERE ( t1.value != t2.value
                                 OR
                                 t1.quality_code != t2.quality_code
                               )',
                                   'table_name',
                                   x.table_name)
                  USING l_value_offset,
                        l_timeseries_data,
                        l_ts_code,
                        l_units,
                        x.start_date,
                        x.end_date,
                        l_ts_code,
                        l_version_date,
                        l_ts_code,
                        l_version_date,
                        l_store_date,
                        l_store_date;
            END LOOP;
                  DBMS_OUTPUT.put_line (
                     'CASE 7: delete-insert FALSE Completed.');
         ELSE
            cwms_err.raise ('INVALID_STORE_RULE',
                            NVL (p_store_rule, '<NULL>'));
      END CASE;

            idx := i_max_iterations;
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX
            THEN
               idx := idx + 1;

               IF idx >= i_max_iterations
               THEN
                  RAISE DUP_VAL_ON_INDEX;
               ELSE
                  DBMS_LOCK.sleep (0.02);
               END IF;
         END;
      END LOOP;

      ---------------------------------
      -- archive and publish message --
      ---------------------------------
      declare
         l_first_time timestamp with time zone;
         l_last_time  timestamp with time zone;
      begin
         select min(date_time)
           into l_first_time
           from table(l_timeseries_data);
         select max(date_time)
           into l_last_time
           from table(l_timeseries_data);
         time_series_updated (
            l_ts_code,
            l_cwms_ts_id,
            l_office_id,
            l_first_time,
            l_last_time,
            FROM_TZ (CAST (l_version_date AS TIMESTAMP), 'UTC'),
            l_store_date,
            upper(p_store_rule));
      end;
     

      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         CWMS_MSG.LOG_DB_MESSAGE (
            'store_ts',
            1,
               'STORE_TS ERROR ***'
            || l_cwms_ts_id
            || '*** '
            || SQLCODE
            || ': '
            || SQLERRM);

         cwms_err.raise ('ERROR', DBMS_UTILITY.format_error_backtrace);
   END store_ts;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- STORE_TS - This version is for Python/CxOracle
   --
   PROCEDURE store_ts (
      p_cwms_ts_id      IN VARCHAR2,
      p_units           IN VARCHAR2,
      p_times           IN number_array,
      p_values          IN double_array,
      p_qualities       IN number_array,
      p_store_rule      IN VARCHAR2,
      p_override_prot   IN VARCHAR2 DEFAULT 'F',
      p_version_date    IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id       IN VARCHAR2 DEFAULT NULL)
   IS
      l_timeseries_data   tsv_array := tsv_array ();
      i                   BINARY_INTEGER;
   BEGIN
      IF p_values.COUNT != p_times.COUNT
      THEN
         cwms_err.raise ('ERROR', 'Inconsistent number of times and values.');
      END IF;

      IF p_qualities.COUNT != p_times.COUNT
      THEN
         cwms_err.raise ('ERROR',
                         'Inconsistent number of times and qualities.');
      END IF;

      l_timeseries_data.EXTEND (p_times.COUNT);

      FOR i IN 1 .. p_times.COUNT
      LOOP
         l_timeseries_data (i) :=
            tsv_type (FROM_TZ (cwms_util.TO_TIMESTAMP (p_times (i)), 'UTC'),
                      p_values (i),
                      p_qualities (i));
      END LOOP;

      store_ts (p_cwms_ts_id,
                p_units,
                l_timeseries_data,
                p_store_rule,
                p_override_prot,
                p_version_date,
                p_office_id);
   END store_ts;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- STORE_TS - This version is for Java/Jython bypassing TIMESTAMPTZ type
   --
   PROCEDURE store_ts (
      p_cwms_ts_id      IN VARCHAR2,
      p_units           IN VARCHAR2,
      p_times           IN number_tab_t,
      p_values          IN number_tab_t,
      p_qualities       IN number_tab_t,
      p_store_rule      IN VARCHAR2,
      p_override_prot   IN VARCHAR2 DEFAULT 'F',
      p_version_date    IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id       IN VARCHAR2 DEFAULT NULL)
   IS
      l_timeseries_data   tsv_array := tsv_array ();
      i                   BINARY_INTEGER;
   BEGIN
      IF p_values.COUNT != p_times.COUNT
      THEN
         cwms_err.raise ('ERROR', 'Inconsistent number of times and values.');
      END IF;

      IF p_qualities.COUNT != p_times.COUNT
      THEN
         cwms_err.raise ('ERROR',
                         'Inconsistent number of times and qualities.');
      END IF;

      l_timeseries_data.EXTEND (p_times.COUNT);

      FOR i IN 1 .. p_times.COUNT
      LOOP
         l_timeseries_data (i) :=
            tsv_type (FROM_TZ (cwms_util.TO_TIMESTAMP (p_times (i)), 'UTC'),
                      p_values (i),
                      p_qualities (i));
      END LOOP;

      store_ts (p_cwms_ts_id,
                p_units,
                l_timeseries_data,
                p_store_rule,
                p_override_prot,
                p_version_date,
                p_office_id);
   END store_ts;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- STORE_TS_MULTI -
   --
   procedure store_ts_multi (
      p_timeseries_array   in timeseries_array,
      p_store_rule         in varchar2,
      p_override_prot      in varchar2 default 'F',
      p_version_dates      in date_table_type default null,
      p_office_id          in varchar2 default null)
   is
      l_err_msg        varchar2 (722)  := null;
      l_all_err_msgs   varchar2 (2048) := null;
      l_version_dates  date_table_type := date_table_type();
      l_len            pls_integer := 0;
      l_total_len      pls_integer := 0;
      l_num_ts_ids     pls_integer := 0;
      l_num_errors     pls_integer := 0;
      l_excep_errors   pls_integer := 0;
   begin
                 
      if p_timeseries_array is not null then
         dbms_application_info.set_module (
            'cwms_ts_store.store_ts_multi',
            'processing parameters');
         if p_version_dates is not null and p_version_dates.count != p_timeseries_array.count then
            cwms_err.raise(
               'ERROR',
               'Counts of time series and version dates don''t match.');               
         end if;
         l_version_dates.extend(p_timeseries_array.count);
         for i in 1..l_version_dates.count loop
            if p_version_dates is null or p_version_dates(i) is null then
               l_version_dates(i) := cwms_util.non_versioned;
            else
               l_version_dates(i) := p_version_dates(i); 
            end if;
         end loop;
         for i in 1..p_timeseries_array.count loop
            dbms_application_info.set_module (
               'cwms_ts_store.store_ts_multi',
               'calling store_ts');

            begin
               store_ts (p_timeseries_array(i).tsid,
                         p_timeseries_array(i).unit,
                         p_timeseries_array(i).data,
                         p_store_rule,
                         p_override_prot,
                         l_version_dates(i),
                         p_office_id);
            exception
               when others then
                  l_num_errors := l_num_errors + 1;

                  l_err_msg :=
                        'STORE_ERROR ***'
                     || p_timeseries_array(i).tsid
                     || '*** '
                     || sqlcode
                     || ': '
                     || sqlerrm;

                  if   nvl (length (l_all_err_msgs), 0)
                     + nvl (length (l_err_msg),      0) <= 1930
                  then
                     l_excep_errors := l_excep_errors + 1;
                     l_all_err_msgs := l_all_err_msgs || ' ' || l_err_msg;
                  end if;
            end;
         end loop;
      end if;

      if l_all_err_msgs is not null then
         l_all_err_msgs :=
               'STORE ERRORS: store_ts_multi processed '
            || l_num_ts_ids
            || ' ts_ids of which '
            || l_num_errors
            || ' had STORE ERRORS. '
            || l_excep_errors
            || ' of those errors are: '
            || l_all_err_msgs;

         raise_application_error (-20999, l_all_err_msgs);
      end if;


      dbms_application_info.set_module (null, null);
   end store_ts_multi;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- STORE_TS_MULTI -
   --
   procedure store_ts_multi (
      p_timeseries_array   in timeseries_array,
      p_store_rule         in varchar2,
      p_override_prot      in varchar2 default 'F',
      p_version_date       in date default cwms_util.non_versioned,
      p_office_id          in varchar2 default null)
   is
      l_version_dates date_table_type;
   begin
      if p_timeseries_array is not null then
         l_version_dates := date_table_type();
         l_version_dates.extend(p_timeseries_array.count);
         for i in 1..p_timeseries_array.count loop
            l_version_dates(i) := p_version_date;
         end loop;
         store_ts_multi(
            p_timeseries_array,
            p_store_rule,
            p_override_prot,
            l_version_dates,
            p_office_id);
      end if;
   end store_ts_multi;

   --
   --*******************************************************************   --
   --** PRIVATE **** PRIVATE **** PRIVATE **** PRIVATE **** PRIVATE ****   --
   --
   -- DELETE_TS_CLEANUP -
   --

   PROCEDURE delete_ts_cleanup (p_ts_code_old IN NUMBER)
   IS
   BEGIN
      -- NOTE TO GERHARD Need to think about cleaning up
      -- all of the dependancies when deleting.
      DELETE FROM at_shef_decode
            WHERE ts_code = p_ts_code_old;
   END delete_ts_cleanup;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- DELETE_TS -
   --
   ---------------------------------------------------------------------   --
   -- valid p_delete_actions:                                              --
   --  delete_ts_id:      This action will delete the cwms_ts_id only if there
   --                     is no actual data associated with this cwms_ts_id.
   --                     If there is data assciated with the cwms_ts_id, then
   --                     an exception is thrown.
   --  delete_ts_data:    This action will delete all of the data associated
   --                     with the cwms_ts_id. The cwms_ts_id is not deleted.
   --  delete_ts_cascade: This action will delete both the data and the
   --                     cwms_ts_id.
   ----------------------------------------------------------------------  --


   PROCEDURE delete_ts (
      p_cwms_ts_id      IN VARCHAR2,
      p_delete_action   IN VARCHAR2 DEFAULT cwms_util.delete_ts_id,
      p_db_office_id    IN VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_code   NUMBER := cwms_util.GET_OFFICE_CODE (p_db_office_id);
   BEGIN
      delete_ts (p_cwms_ts_id       => p_cwms_ts_id,
                 p_delete_action    => p_delete_action,
                 p_db_office_code   => l_db_office_code);
   END;

   procedure delete_ts(
      p_cwms_ts_id     in varchar2,
      p_delete_action  in varchar2,
      p_db_office_code in number)
   is
      l_db_office_code   number := p_db_office_code;
      l_db_office_id     varchar2(16);
      l_cwms_ts_id       varchar2(183);
      l_ts_code          number;
      l_count            number;
      l_value_count      number;
      l_std_text_count   number;
      l_text_count       number;
      l_binary_count     number;
      l_delete_action    varchar2(22) := upper(nvl(p_delete_action, cwms_util.delete_ts_id));
      l_delete_date      timestamp(9) := systimestamp;
      l_msg              sys.aq$_jms_map_message;
      l_msgid            pls_integer;
      i                  integer;
   begin
      if p_db_office_code is null then
         l_db_office_code := cwms_util.get_office_code(null);
      end if;

      select office_id
        into l_db_office_id
        from cwms_office
       where office_code = l_db_office_code;

      l_cwms_ts_id := get_cwms_ts_id(p_cwms_ts_id, l_db_office_id);

      begin
         select ts_code
           into l_ts_code
           from at_cwms_ts_id mcts
          where upper(mcts.cwms_ts_id) = upper(l_cwms_ts_id) and mcts.db_office_code = l_db_office_code;
      exception
         when no_data_found then
            begin
               select ts_code
                 into l_ts_code
                 from at_cwms_ts_id mcts
                where upper(mcts.cwms_ts_id) = upper(l_cwms_ts_id) and mcts.db_office_code = l_db_office_code;
            exception
               when no_data_found then
                  cwms_err.raise('TS_ID_NOT_FOUND', l_cwms_ts_id,cwms_util.get_db_office_id_from_code(p_db_office_code));
            end;
      end;

      ----------------------------------------------
      -- translate non-ts-specific delete_actions --
      ----------------------------------------------
      if l_delete_action = cwms_util.delete_key then
         l_delete_action := cwms_util.delete_ts_id;
      end if;

      if l_delete_action = cwms_util.delete_all then
         l_delete_action := cwms_util.delete_ts_cascade;
      end if;

      if l_delete_action = cwms_util.delete_data then
         l_delete_action := cwms_util.delete_ts_data;
      end if;

      case
         when l_delete_action = cwms_util.delete_ts_id then
            select count(*)
              into l_value_count
              from av_tsv
             where ts_code = l_ts_code;

            select count(*)
              into l_std_text_count
              from at_tsv_std_text
             where ts_code = l_ts_code;

            select count(*)
              into l_text_count
              from at_tsv_text
             where ts_code = l_ts_code;

            select count(*)
              into l_binary_count
              from at_tsv_binary
             where ts_code = l_ts_code;

            l_count := l_value_count + l_std_text_count + l_text_count + l_binary_count;

            if l_count = 0 then
               loop
                  begin
                     update at_cwms_ts_spec
                        set location_code = 0, delete_date = l_delete_date
                      where ts_code = l_ts_code;

                     exit;
                  exception
                     when others then
                        if sqlcode = -1 then
                           l_delete_date := systimestamp;
                        end if;
                  end;
               end loop;
            else
               cwms_err.raise('ERROR', 'cwms_ts_id: ' || p_cwms_ts_id || ' contains data. Cannot use the DELETE TS ID action');
            end if;
         when l_delete_action in (cwms_util.delete_ts_cascade, cwms_util.delete_ts_data) then
            -------------------------------
            -- delete data from database --
            -------------------------------
            for rec in (select table_name
                          from at_ts_table_properties
                         where start_date in (select distinct start_date
                                                from av_tsv
                                               where ts_code = l_ts_code)) loop
               execute immediate replace('delete from $t where ts_code = :1', '$t', rec.table_name) using l_ts_code;
            end loop;

            delete from at_tsv_std_text
                  where ts_code = l_ts_code;

            delete from at_tsv_text
                  where ts_code = l_ts_code;

            delete from at_tsv_binary
                  where ts_code = l_ts_code;

            if l_delete_action = cwms_util.delete_ts_cascade then
               ---------------------------------------
               -- delete location group assignments --
               ---------------------------------------
               delete
                 from at_ts_group_assignment
                where ts_code = l_ts_code
                   or ts_ref_code = l_ts_code;
               ------------------------------
               -- delete the timeseries id --
               ------------------------------
               update at_cwms_ts_spec
                  set location_code = 0, delete_date = l_delete_date
                where ts_code = l_ts_code;

               delete_ts_cleanup(l_ts_code);
            end if;

            commit;
         else
            cwms_err.raise('INVALID_DELETE_ACTION', p_delete_action);
      end case;

      if l_delete_action in (cwms_util.delete_ts_id, cwms_util.delete_ts_cascade) then
         -------------------------------
         -- publish TSDeleted message --
         -------------------------------
         cwms_msg.new_message(l_msg, l_msgid, 'TSDeleted');
         l_msg.set_string(l_msgid, 'ts_id', l_cwms_ts_id);
         l_msg.set_string(l_msgid, 'office_id', l_db_office_id);
         l_msg.set_long(l_msgid, 'ts_code', l_ts_code);
         i := cwms_msg.publish_message(l_msg, l_msgid, l_db_office_id || '_ts_stored');
      end if;
   end delete_ts;
   
   procedure delete_ts (
      p_cwms_ts_id           in varchar2,
      p_override_protection  in varchar2,
      p_start_time           in date,
      p_end_time             in date,                        
      p_start_time_inclusive in varchar2,
      p_end_time_inclusive   in varchar2,
      p_version_date         in date,
      p_time_zone            in varchar2 default null,
      p_date_times           in date_table_type default null,
      p_max_version          in varchar2 default 'T',
      p_ts_item_mask         in integer default cwms_util.ts_all,
      p_db_office_id         in varchar2 default null)
   is
      l_ts_code    integer;
      l_start_time date;
      l_end_time   date;
      l_time_zone  varchar2(28);
      l_date_times date_table_type;
   begin
      l_ts_code := get_ts_code(p_cwms_ts_id, p_db_office_id);
      l_time_zone := cwms_util.get_timezone(nvl(p_time_zone, cwms_loc.get_local_timezone(cwms_util.split_text(p_cwms_ts_id, 1, '.'), p_db_office_id)));
      if p_date_times is not null then
         select cwms_util.change_timezone(column_value, l_time_zone, 'UTC')
           bulk collect
           into l_date_times
           from table(p_date_times);
      end if;
      if p_date_times is null then
         if cwms_util.is_true(p_start_time_inclusive) then
            l_start_time := p_start_time;
         else
            l_start_time := p_start_time + 1/86400;
         end if;
         if cwms_util.is_true(p_end_time_inclusive) then
            l_end_time := p_end_time;
         else
            l_end_time := p_end_time - 1/86400;
         end if;
      end if;
      purge_ts_data(
         l_ts_code,
         p_override_protection, 
         case p_version_date = cwms_util.non_versioned 
            when true then p_version_date
            else cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC')
         end, 
         cwms_util.change_timezone(l_start_time, l_time_zone, 'UTC'), 
         cwms_util.change_timezone(l_end_time, l_time_zone, 'UTC'), 
         l_date_times, 
         p_max_version, 
         p_ts_item_mask);
   end delete_ts;
   
   procedure delete_ts (
      p_timeseries_info      in timeseries_req_array,
      p_override_protection  in varchar2,
      p_start_time_inclusive in varchar2,
      p_end_time_inclusive   in varchar2,
      p_version_date         in date,
      p_time_zone            in varchar2 default null,
      p_max_version          in varchar2 default 'T',
      p_ts_item_mask         in integer default cwms_util.ts_all,
      p_db_office_id         in varchar2 default null)
   is
   begin
      if p_timeseries_info is not null then
         for i in 1..p_timeseries_info.count loop
            delete_ts(
                p_cwms_ts_id           => p_timeseries_info(i).tsid,
                p_override_protection  => p_override_protection,
                p_start_time           => p_timeseries_info(i).start_time,
                p_end_time             => p_timeseries_info(i).end_time,
                p_start_time_inclusive => p_start_time_inclusive,
                p_end_time_inclusive   => p_end_time_inclusive,
                p_version_date         => p_version_date,
                p_time_zone            => p_time_zone,
                p_date_times           => null,
                p_max_version          => p_max_version,
                p_ts_item_mask         => p_ts_item_mask,
                p_db_office_id         => p_db_office_id);
         end loop;
      end if;
   end delete_ts;      
         
   procedure purge_ts_data(
      p_ts_code          in number,
      p_version_date_utc in date,
      p_start_time_utc   in date,
      p_end_time_utc     in date,
      p_date_times_utc   in date_table_type default null,
      p_max_version      in varchar2 default 'T',
      p_ts_item_mask     in integer default cwms_util.ts_all)
   is
   begin
      purge_ts_data(
         p_ts_code,
         'ERROR',
         p_version_date_utc,
         p_start_time_utc,
         p_end_time_utc,
         p_date_times_utc,
         p_max_version,
         p_ts_item_mask);
   end purge_ts_data;
         
   procedure purge_ts_data(
      p_ts_code             in number,
      p_override_protection in varchar2,
      p_version_date_utc    in date,
      p_start_time_utc      in date,
      p_end_time_utc        in date,
      p_date_times_utc      in date_table_type default null,
      p_max_version         in varchar2 default 'T',
      p_ts_item_mask        in integer default cwms_util.ts_all)
   is
      l_tsid                     varchar2(183);
      l_office_id                varchar2(16);
      l_override_protection      boolean;
      l_error_on_protection      boolean;
      l_deleted_time             timestamp := systimestamp at time zone 'UTC';
      l_msg                      sys.aq$_jms_map_message;
      l_msgid                    pls_integer;
      i                          integer;
      l_protected_count          integer;
      l_max_version              boolean;
      l_date_times_values        date_table_type := date_table_type();
      l_version_dates_values     date_table_type := date_table_type();
      l_date_times_std_text      date_table_type := date_table_type();
      l_version_dates_std_text   date_table_type := date_table_type();
      l_date_times_text          date_table_type := date_table_type();
      l_version_dates_text       date_table_type := date_table_type();
      l_date_times_binary        date_table_type := date_table_type();
      l_version_dates_binary     date_table_type := date_table_type();
      l_times_values             date2_tab_t := date2_tab_t();
      l_times_std_text           date2_tab_t := date2_tab_t();
      l_times_text               date2_tab_t := date2_tab_t();
      l_times_binary             date2_tab_t := date2_tab_t();
      l_cursor                   sys_refcursor;
   begin
      l_max_version := cwms_util.return_true_or_false(p_max_version);
      if instr('ERROR', upper(trim(p_override_protection))) = 1 then
         l_override_protection := false;
         l_error_on_protection := true;
      else
         l_override_protection := cwms_util.return_true_or_false(p_override_protection);
         l_error_on_protection := false;
      end if;      

      --------------------------------------------------------------------
      -- get the date_times and version_dates of all the items to purge --
      --------------------------------------------------------------------
      if bitand(p_ts_item_mask, cwms_util.ts_values) > 0 then
         l_cursor      :=
            retrieve_existing_times_f(
               p_ts_code,
               p_start_time_utc,
               p_end_time_utc,
               p_date_times_utc,
               p_version_date_utc,
               l_max_version,
               cwms_util.ts_values);

         fetch l_cursor
         bulk collect into l_date_times_values, l_version_dates_values;
         close l_cursor;
      end if;

      if bitand(p_ts_item_mask, cwms_util.ts_std_text) > 0 then
         l_cursor      :=
            retrieve_existing_times_f(
               p_ts_code,
               p_start_time_utc,
               p_end_time_utc,
               p_date_times_utc,
               p_version_date_utc,
               l_max_version,
               cwms_util.ts_std_text);

         fetch l_cursor
         bulk collect into l_date_times_std_text, l_version_dates_std_text;
         close l_cursor;
      end if;

      if bitand(p_ts_item_mask, cwms_util.ts_text) > 0 then
         l_cursor      :=
            retrieve_existing_times_f(
               p_ts_code,
               p_start_time_utc,
               p_end_time_utc,
               p_date_times_utc,
               p_version_date_utc,
               l_max_version,
               cwms_util.ts_text);

         fetch l_cursor
         bulk collect into l_date_times_text, l_version_dates_text;
         close l_cursor;
      end if;

      if bitand(p_ts_item_mask, cwms_util.ts_binary) > 0 then
         l_cursor      :=
            retrieve_existing_times_f(
               p_ts_code,
               p_start_time_utc,
               p_end_time_utc,
               p_date_times_utc,
               p_version_date_utc,
               l_max_version,
               cwms_util.ts_binary);

         fetch l_cursor
         bulk collect into l_date_times_binary, l_version_dates_binary;
         close l_cursor;
      end if;

      -------------------------------------------------
      -- collect the times into queryable structures --
      -------------------------------------------------
      l_times_values.extend(l_date_times_values.count);

      for i in 1 .. l_date_times_values.count loop
         l_times_values(i) := date2_t(l_date_times_values(i), l_version_dates_values(i));
      end loop;

      l_times_std_text.extend(l_date_times_std_text.count);

      for i in 1 .. l_date_times_std_text.count loop
         l_times_std_text(i) := date2_t(l_date_times_std_text(i), l_version_dates_std_text(i));
      end loop;

      l_times_text.extend(l_date_times_text.count);

      for i in 1 .. l_date_times_text.count loop
         l_times_text(i) := date2_t(l_date_times_text(i), l_version_dates_text(i));
      end loop;

      l_times_binary.extend(l_date_times_binary.count);

      for i in 1 .. l_date_times_binary.count loop
         l_times_binary(i) := date2_t(l_date_times_binary(i), l_version_dates_binary(i));
      end loop;

      ----------------------------------------
      -- perform actions specific to values --
      ----------------------------------------
      if l_times_values.count > 0 then
         if l_error_on_protection then
            ------------------------------
            -- check for protected data --
            ------------------------------
            for rec
               in (select table_name
                     from at_ts_table_properties
                    where start_date in (select distinct v.start_date
                                           from cwms_v_tsv v, table(l_times_values) d
                                          where v.ts_code = p_ts_code and v.date_time = d.date_1 and v.version_date = d.date_2)) loop
               execute immediate replace(
                    'select count(*)
                       from $t
                      where rowid in (select t.rowid
                                         from $t t,
                                              table(:1) d
                                        where t.ts_code = :2
                                          and t.date_time = d.date_1
                                          and t.version_date = d.date_2
                                          and bitand(t.quality_code, 2147483648) <> 0)', '$t', rec.table_name)
                  into l_protected_count
                 using l_times_values, p_ts_code;
                 
               if l_protected_count > 0 then
                  cwms_err.raise('ERROR', 'One or more values are protected');
               end if;     
            end loop;

         end if;
         ------------------------------------------
         -- insert records into at_deleted_times --
         ------------------------------------------
         insert into at_ts_deleted_times
            select cwms_util.to_millis(l_deleted_time),
                   p_ts_code,
                   d.version_date,
                   d.date_time
              from (select date_1 as date_time, date_2 as version_date from table(l_times_values)) d;
        ------------------------------------
         -- Publish TSDataDeleted messages --
         ------------------------------------
         select cwms_ts_id, db_office_id
           into l_tsid, l_office_id
           from cwms_v_ts_id
          where ts_code = p_ts_code;

         for rec1 in (select distinct date_2 as version_date from table(l_times_values)) loop
            for rec2 in (select min(date_1) as start_time, max(date_1) as end_time
                           from table(l_times_values)
                          where date_2 = rec1.version_date) loop
               cwms_msg.new_message(l_msg, l_msgid, 'TSDataDeleted');
               l_msg.set_string(l_msgid, 'ts_id', l_tsid);
               l_msg.set_string(l_msgid, 'office_id', l_office_id);
               l_msg.set_long(l_msgid, 'ts_code', p_ts_code);
               l_msg.set_long(l_msgid, 'start_time', cwms_util.to_millis(cast(rec2.start_time as timestamp)));
               l_msg.set_long(l_msgid, 'end_time', cwms_util.to_millis(cast(rec2.end_time as timestamp)));
               l_msg.set_long(l_msgid, 'version_date', cwms_util.to_millis(cast(rec1.version_date as timestamp)));
               l_msg.set_long(l_msgid, 'deleted_time', cwms_util.to_millis(l_deleted_time));
               i := cwms_msg.publish_message(l_msg, l_msgid, l_office_id || '_ts_stored');
            end loop;
         end loop;
      end if;
      ------------------------------
      -- actually delete the data --
      ------------------------------
      for rec
         in (select table_name
               from at_ts_table_properties
              where start_date in (select distinct v.start_date
                                     from cwms_v_tsv v, table(l_times_values) d
                                    where v.ts_code = p_ts_code and v.date_time = d.date_1 and v.version_date = d.date_2)) loop
         if l_override_protection then
            execute immediate replace(
                 'delete 
                    from $t
                   where rowid in (select t.rowid
                                      from $t t,
                                           table(:1) d
                                     where t.ts_code = :2
                                       and t.date_time = d.date_1
                                       and t.version_date = d.date_2)', '$t', rec.table_name)
               using l_times_values, p_ts_code;
         else
            execute immediate replace(
                 'delete 
                    from $t
                   where rowid in (select t.rowid
                                      from $t t,
                                           table(:1) d
                                     where t.ts_code = :2
                                       and t.date_time = d.date_1
                                       and t.version_date = d.date_2
                                       and bitand(t.quality_code, 2147483648) = 0)', '$t', rec.table_name)
               using l_times_values, p_ts_code;
         end if;                                    
      end loop;

      delete from at_tsv_std_text
            where rowid in (select t.rowid
                              from at_tsv_std_text t, table(l_times_std_text) d
                             where ts_code = p_ts_code and t.date_time = d.date_1 and t.version_date = d.date_2);

      delete from at_tsv_text
            where rowid in (select t.rowid
                              from at_tsv_text t, table(l_times_text) d
                             where ts_code = p_ts_code and t.date_time = d.date_1 and t.version_date = d.date_2);

      delete from at_tsv_binary
            where rowid in (select t.rowid
                              from at_tsv_binary t, table(l_times_binary) d
                             where ts_code = p_ts_code and t.date_time = d.date_1 and t.version_date = d.date_2);
   end purge_ts_data;

   procedure change_version_date(
      p_ts_code              in number,
      p_old_version_date_utc in date,
      p_new_version_date_utc in date,
      p_start_time_utc       in date,
      p_end_time_utc         in date,
      p_date_times_utc       in date_table_type default null,
      p_ts_item_mask         in integer default cwms_util.ts_all)
   is
      l_is_versioned             varchar2(1);
      l_date_times_values        date_table_type := date_table_type();
      l_version_dates_values     date_table_type := date_table_type();
      l_date_times_std_text      date_table_type := date_table_type();
      l_version_dates_std_text   date_table_type := date_table_type();
      l_date_times_text          date_table_type := date_table_type();
      l_version_dates_text       date_table_type := date_table_type();
      l_date_times_binary        date_table_type := date_table_type();
      l_version_dates_binary     date_table_type := date_table_type();
      l_times_values             date2_tab_t := date2_tab_t();
      l_times_std_text           date2_tab_t := date2_tab_t();
      l_times_text               date2_tab_t := date2_tab_t();
      l_times_binary             date2_tab_t := date2_tab_t();
      l_cursor                   sys_refcursor;
   begin
      -------------------
      -- sanity checks --
      -------------------
      is_ts_versioned(l_is_versioned, p_ts_code);

      if cwms_util.is_false(l_is_versioned) then
         cwms_err.raise('ERROR', 'Cannot change version date on non-versioned data.');
      end if;

      if cwms_util.all_version_dates in (p_old_version_date_utc, p_new_version_date_utc) then
         cwms_err.raise('ERROR', 'CWMS_UTIL.ALL_VERSION_DATES cannot be used for actual version date');
      end if;

      -------------------------------------------------------------------------------
      -- NOTE: The version dates in all the following collections will be the same --
      -- as the p_old_version_date_utc parameter                                   --
      -------------------------------------------------------------------------------

      ---------------------------------------------------------------------
      -- get the date_times and version_dates of all the items to update --
      ---------------------------------------------------------------------
      if bitand(p_ts_item_mask, cwms_util.ts_values) > 0 then
         l_cursor      :=
            retrieve_existing_times_f(
               p_ts_code,
               p_start_time_utc,
               p_end_time_utc,
               p_date_times_utc,
               p_old_version_date_utc,
               true,
               cwms_util.ts_values);

         fetch l_cursor
         bulk collect into l_date_times_values, l_version_dates_values;

         close l_cursor;
      end if;

      if bitand(p_ts_item_mask, cwms_util.ts_std_text) > 0 then
         l_cursor      :=
            retrieve_existing_times_f(
               p_ts_code,
               p_start_time_utc,
               p_end_time_utc,
               p_date_times_utc,
               p_old_version_date_utc,
               true,
               cwms_util.ts_std_text);

         fetch l_cursor
         bulk collect into l_date_times_std_text, l_version_dates_std_text;

         close l_cursor;
      end if;

      if bitand(p_ts_item_mask, cwms_util.ts_text) > 0 then
         l_cursor      :=
            retrieve_existing_times_f(
               p_ts_code,
               p_start_time_utc,
               p_end_time_utc,
               p_date_times_utc,
               p_old_version_date_utc,
               true,
               cwms_util.ts_text);

         fetch l_cursor
         bulk collect into l_date_times_text, l_version_dates_text;

         close l_cursor;
      end if;

      if bitand(p_ts_item_mask, cwms_util.ts_binary) > 0 then
         l_cursor      :=
            retrieve_existing_times_f(
               p_ts_code,
               p_start_time_utc,
               p_end_time_utc,
               p_date_times_utc,
               p_old_version_date_utc,
               true,
               cwms_util.ts_binary);

         fetch l_cursor
         bulk collect into l_date_times_binary, l_version_dates_binary;

         close l_cursor;
      end if;

      -------------------------------------------------
      -- collect the times into queryable structures --
      -------------------------------------------------
      l_times_values.extend(l_date_times_values.count);

      for i in 1 .. l_date_times_values.count loop
         l_times_values(i) := date2_t(l_date_times_values(i), l_version_dates_values(i));
      end loop;

      l_times_std_text.extend(l_date_times_std_text.count);

      for i in 1 .. l_date_times_std_text.count loop
         l_times_std_text(i) := date2_t(l_date_times_std_text(i), l_version_dates_std_text(i));
      end loop;

      l_times_text.extend(l_date_times_text.count);

      for i in 1 .. l_date_times_text.count loop
         l_times_text(i) := date2_t(l_date_times_text(i), l_version_dates_text(i));
      end loop;

      l_times_binary.extend(l_date_times_binary.count);

      for i in 1 .. l_date_times_binary.count loop
         l_times_binary(i) := date2_t(l_date_times_binary(i), l_version_dates_binary(i));
      end loop;

      ---------------------
      -- update the data --
      ---------------------
      for rec
         in (select table_name
               from at_ts_table_properties
              where start_date in (select distinct v.start_date
                                     from cwms_v_tsv v, table(l_times_values) d
                                    where v.ts_code = p_ts_code and v.date_time = d.date_1 and v.version_date = d.date_2)) loop
         execute immediate replace(
                 'update $t
                     set version_date = :1
                    where rowid in (select t.rowid
                                      from $t t,
                                           table(:2) d
                                     where t.ts_code = :3
                                       and t.date_time = d.date_1
                                       and t.version_date = d.date_2)', '$t', rec.table_name)
            using p_new_version_date_utc, l_times_values, p_ts_code;
      end loop;

      update at_tsv_std_text
         set version_date = p_new_version_date_utc
       where rowid in (select t.rowid
                         from at_tsv_std_text t, table(l_times_std_text) d
                        where ts_code = p_ts_code and t.date_time = d.date_1 and t.version_date = d.date_2);

      update at_tsv_text
         set version_date = p_new_version_date_utc
       where rowid in (select t.rowid
                         from at_tsv_text t, table(l_times_text) d
                        where ts_code = p_ts_code and t.date_time = d.date_1 and t.version_date = d.date_2);

      update at_tsv_binary
         set version_date = p_new_version_date_utc
       where rowid in (select t.rowid
                         from at_tsv_binary t, table(l_times_binary) d
                        where ts_code = p_ts_code and t.date_time = d.date_1 and t.version_date = d.date_2);
   end change_version_date;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- RENAME...
   --
   --v 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvv 1.4 vvvvvv -
   PROCEDURE rename_ts (p_office_id             IN VARCHAR2,
                        p_timeseries_desc_old   IN VARCHAR2,
                        p_timeseries_desc_new   IN VARCHAR2)
   --^ 1.4 ^^^^ 1.4 ^^^^ 1.4 ^^^^ 1.4 ^^^^ 1.4 ^^^^ 1.4 ^^^^^^^ -
   IS
      l_utc_offset   NUMBER := NULL;
   BEGIN
      rename_ts (p_timeseries_desc_old,
                 p_timeseries_desc_new,
                 l_utc_offset,
                 p_office_id);
   END;

   --
   ---------------------------------------------------------------------
   --
   -- Rename a time series id.
   -- If no data exists, then you can rename every part of a cwms_ts_id.
   -- If data exists then you can rename everything except the interval.
   --
   ---------------------------------------------------------------------
   --
   PROCEDURE rename_ts (p_cwms_ts_id_old   IN VARCHAR2,
                        p_cwms_ts_id_new   IN VARCHAR2,
                        p_utc_offset_new   IN NUMBER DEFAULT NULL,
                        p_office_id        IN VARCHAR2 DEFAULT NULL)
   IS
      l_utc_offset_old            at_cwms_ts_spec.interval_utc_offset%TYPE;
      --
      l_location_code_old         at_cwms_ts_spec.location_code%TYPE;
      l_interval_code_old         cwms_interval.interval_code%TYPE;
      --
      l_base_location_id_new      at_base_location.base_location_id%TYPE;
      l_sub_location_id_new       at_physical_location.sub_location_id%TYPE;
      l_location_new              VARCHAR2 (49);
      l_base_parameter_id_new     cwms_base_parameter.base_parameter_id%TYPE;
      l_sub_parameter_id_new      at_parameter.sub_parameter_id%TYPE;
      l_parameter_type_id_new     cwms_parameter_type.parameter_type_id%TYPE;
      l_interval_id_new           cwms_interval.interval_id%TYPE;
      l_duration_id_new           cwms_duration.duration_id%TYPE;
      l_version_id_new            at_cwms_ts_spec.VERSION%TYPE;
      l_utc_offset_new            at_cwms_ts_spec.interval_utc_offset%TYPE;
      --
      l_location_code_new         at_cwms_ts_spec.location_code%TYPE;
      l_interval_dur_new          cwms_interval.INTERVAL%TYPE;
      l_interval_code_new         cwms_interval.interval_code%TYPE;
      l_base_parameter_code_new   cwms_base_parameter.base_parameter_code%TYPE;
      l_parameter_type_code_new   cwms_parameter_type.parameter_type_code%TYPE;
      l_parameter_code_new        at_parameter.parameter_code%TYPE;
      l_duration_code_new         cwms_duration.duration_code%TYPE;
      --
      l_office_code               NUMBER;
      l_ts_code_old               NUMBER;
      l_ts_code_new               NUMBER;
      l_office_id                 cwms_office.office_id%TYPE;
      l_has_data                  BOOLEAN;
      l_tmp                       NUMBER;
   --
   BEGIN
      DBMS_APPLICATION_INFO.set_module ('rename_ts_code',
                                        'get ts_code from materialized view');

      --
      --------------------------------------------------------
      -- Set office_id...
      --------------------------------------------------------
      IF p_office_id IS NULL
      THEN
         l_office_id := cwms_util.user_office_id;
      ELSE
         l_office_id := UPPER (p_office_id);
      END IF;

      DBMS_APPLICATION_INFO.set_module ('rename_ts_code', 'get office code');
      --------------------------------------------------------
      -- Get the office_code...
      --------------------------------------------------------
      l_office_code := cwms_util.get_office_code (l_office_id);
      --------------------------------------------------------
      -- Confirm old cwms_ts_id exists...
      --------------------------------------------------------
      l_ts_code_old :=
         get_ts_code (p_cwms_ts_id     => clean_ts_id(p_cwms_ts_id_old),
                      p_db_office_id   => l_office_id);

      --
      --------------------------------------------------------
      -- Retrieve old codes for the old ts_code...
      --------------------------------------------------------
      --
      SELECT location_code, interval_code, acts.INTERVAL_UTC_OFFSET
        INTO l_location_code_old, l_interval_code_old, l_utc_offset_old
        FROM at_cwms_ts_spec acts
       WHERE ts_code = l_ts_code_old;

      DBMS_OUTPUT.put_line ('l_utc_offset_old-1: ' || l_utc_offset_old);

      --------------------------------------------------------
      -- Confirm new cwms_ts_id does not exist...
      --------------------------------------------------------
      BEGIN
         --
         l_ts_code_new :=
            get_ts_code (p_cwms_ts_id     => clean_ts_id(p_cwms_ts_id_new),
                         p_db_office_id   => l_office_id);
      --

      EXCEPTION
         -----------------------------------------------------------------
         -- Exception means cwms_ts_id_new does not exist - a good thing!.
         -----------------------------------------------------------------
         WHEN OTHERS
         THEN
            l_ts_code_new := NULL;
      END;

      IF l_ts_code_new IS NOT NULL
      THEN
         cwms_err.RAISE ('TS_ALREADY_EXISTS',
                         l_office_id || '.' || p_cwms_ts_id_new);
      END IF;

      ------------------------------------------------------------------
      -- Parse cwms_id_new --
      ------------------------------------------------------------------
      parse_ts (clean_ts_id(p_cwms_ts_id_new),
                l_base_location_id_new,
                l_sub_location_id_new,
                l_base_parameter_id_new,
                l_sub_parameter_id_new,
                l_parameter_type_id_new,
                l_interval_id_new,
                l_duration_id_new,
                l_version_id_new);
      --
      l_location_new :=
         cwms_util.concat_base_sub_id (l_base_location_id_new,
                                       l_sub_location_id_new);

      ---------------------------
      -- Validate the interval --
      ---------------------------
      BEGIN
         SELECT interval_code, INTERVAL, interval_id
           INTO l_interval_code_new, l_interval_dur_new, l_interval_id_new
           FROM cwms_interval ci
          WHERE UPPER (ci.interval_id) = UPPER (l_interval_id_new);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.RAISE ('INVALID_INTERVAL_ID', l_interval_id_new);
         WHEN OTHERS
         THEN
            RAISE;
      END;

      ----------------------------------
      -- Validate the base parameter --
      ----------------------------------
      BEGIN
         SELECT base_parameter_code
           INTO l_base_parameter_code_new
           FROM cwms_base_parameter
          WHERE UPPER (base_parameter_id) = UPPER (l_base_parameter_id_new);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.RAISE ('INVALID_PARAM_ID', l_base_parameter_id_new);
         WHEN OTHERS
         THEN
            RAISE;
      END;

      ---------------------------------
      -- Validate the parameter type --
      ---------------------------------
      BEGIN
         SELECT parameter_type_code
           INTO l_parameter_type_code_new
           FROM cwms_parameter_type
          WHERE UPPER (parameter_type_id) = UPPER (l_parameter_type_id_new);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.RAISE ('INVALID_PARAM_TYPE', l_parameter_type_id_new);
         WHEN OTHERS
         THEN
            RAISE;
      END;

      ---------------------------
      -- Validate the duration --
      ---------------------------
      BEGIN
         SELECT duration_code
           INTO l_duration_code_new
           FROM cwms_duration
          WHERE UPPER (duration_id) = UPPER (l_duration_id_new);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.RAISE ('INVALID_DURATION_ID', l_duration_id_new);
         WHEN OTHERS
         THEN
            RAISE;
      END;

      --------------------------------------------------------
      -- Set default utc_offset if null was passed in as new...
      --------------------------------------------------------
      IF p_utc_offset_new IS NULL
      THEN
         DBMS_OUTPUT.put_line ('l_utc_offset_old-2: ' || l_utc_offset_old);

         IF CWMS_UTIL.IS_IRREGULAR_CODE (l_interval_code_new)
         THEN
            l_utc_offset_new := cwms_util.utc_offset_irregular;
         ELSIF CWMS_UTIL.IS_IRREGULAR_CODE (l_interval_code_old)
         THEN
            l_utc_offset_new := cwms_util.utc_offset_undefined;
         ELSE
            l_utc_offset_new := l_utc_offset_old;
         END IF;
      ELSE
         IF CWMS_UTIL.IS_IRREGULAR_CODE (l_interval_code_new)
         THEN
            l_utc_offset_new := cwms_util.utc_offset_irregular;
         ELSIF p_utc_offset_new >= l_interval_dur_new
         THEN
            cwms_err.RAISE ('INVALID_UTC_OFFSET',
                            p_utc_offset_new,
                            l_interval_dur_new);
         ELSE
            l_utc_offset_new := p_utc_offset_new;
         END IF;
      END IF;
      DBMS_OUTPUT.put_line ('l_utc_offset_new: ' || l_utc_offset_new);

      -------------------------------------------------------------
      ---- Make sure that 'Inst' Parameter type doesn't have a duration--
      --------------------------------------------------------------
      IF (UPPER (l_parameter_type_id_new) = 'INST' AND l_duration_id_new <> '0')
      THEN
        raise_application_error (-20205, 'Inst parameter type can not have non-zero duration', TRUE);
      END IF;

      ---------------------------------------------------
      -- Check whether the ts_code has associated data --
      ---------------------------------------------------
      SELECT COUNT (*)
        INTO l_tmp
        FROM av_tsv
       WHERE ts_code = l_ts_code_old;

      l_has_data := l_tmp > 0;

      ------------------------------------------------------------------
      -- Perform these checks only if the ts_code has associated data --
      ------------------------------------------------------------------
      IF l_has_data
      THEN
         --------------------------------------------------------------
         -- Do not allow the interval to change, except to irregular --
         --------------------------------------------------------------
         IF NOT CWMS_UTIL.IS_IRREGULAR_CODE (l_interval_code_new)
         THEN
            IF l_interval_code_new <> l_interval_code_old
            THEN
               cwms_err.RAISE (
                  'GENERIC_ERROR',
                  'Cannot change to a regular interval when data is present');
            END IF;

            ----------------------------------------------------
            -- Do not allow the interval UTC offset to change --
            ----------------------------------------------------
            IF l_utc_offset_new <> l_utc_offset_old
            THEN
               cwms_err.RAISE (
                  'GENERIC_ERROR',
                  'Cannot change interval offsets when data is present');
            END IF;
         END IF;
      END IF;

      ----------------------------------------------------
      -- Determine the new location_code --
      ----------------------------------------------------
      BEGIN
         l_location_code_new :=
            cwms_loc.get_location_code (l_office_id, l_location_new);
      EXCEPTION                              -- New Location does not exist...
         WHEN OTHERS
         THEN
            cwms_loc.create_location (p_location_id    => l_location_new,
                                      p_db_office_id   => l_office_id);
            --
            l_location_code_new :=
               cwms_loc.get_location_code (l_office_id, l_location_new);
      END;

      ----------------------------------------------------
      -- Determine the new parameter_code --
      ----------------------------------------------------
      l_parameter_code_new :=
         get_parameter_code (
            p_base_parameter_code   => l_base_parameter_code_new,
            p_sub_parameter_id      => l_sub_parameter_id_new,
            p_office_code           => l_office_code,
            p_create                => TRUE);


      --
      ----------------------------------------------------
      -- Perform the Rename by updating at_cwms_ts_spec --
      ----------------------------------------------------
      --
      UPDATE at_cwms_ts_spec s
         SET s.location_code = l_location_code_new,
             s.parameter_code = l_parameter_code_new,
             s.parameter_type_code = l_parameter_type_code_new,
             s.interval_code = l_interval_code_new,
             s.duration_code = l_duration_code_new,
             s.VERSION = l_version_id_new,
             s.interval_utc_offset = l_utc_offset_new
       WHERE s.ts_code = l_ts_code_old;

      COMMIT;

      --
      ---------------------------------
      -- Publish a TSRenamed message --
      ---------------------------------
      --
      DECLARE
         l_msg     SYS.aq$_jms_map_message;
         l_msgid   PLS_INTEGER;
         i         INTEGER;
      BEGIN
         cwms_msg.new_message (l_msg, l_msgid, 'TSRenamed');
         l_msg.set_string (l_msgid, 'ts_id', p_cwms_ts_id_old);
         l_msg.set_string (l_msgid, 'new_ts_id', p_cwms_ts_id_new);
         l_msg.set_string (l_msgid, 'office_id', l_office_id);
         l_msg.set_long (l_msgid, 'ts_code', l_ts_code_old);
         i :=
            cwms_msg.publish_message (l_msg,
                                      l_msgid,
                                      l_office_id || '_ts_stored');
      END;

      --
      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   --
   END rename_ts;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- PARSE_TS -
   --
   PROCEDURE parse_ts (p_cwms_ts_id          IN     VARCHAR2,
                       p_base_location_id       OUT VARCHAR2,
                       p_sub_location_id        OUT VARCHAR2,
                       p_base_parameter_id      OUT VARCHAR2,
                       p_sub_parameter_id       OUT VARCHAR2,
                       p_parameter_type_id      OUT VARCHAR2,
                       p_interval_id            OUT VARCHAR2,
                       p_duration_id            OUT VARCHAR2,
                       p_version_id             OUT VARCHAR2)
   IS
   BEGIN
      SELECT cwms_util.get_base_id (REGEXP_SUBSTR (p_cwms_ts_id,
                                                   '[^.]+',
                                                   1,
                                                   1))
                base_location_id,
             cwms_util.get_sub_id (REGEXP_SUBSTR (p_cwms_ts_id,
                                                  '[^.]+',
                                                  1,
                                                  1))
                sub_location_id,
             cwms_util.get_base_id (REGEXP_SUBSTR (p_cwms_ts_id,
                                                   '[^.]+',
                                                   1,
                                                   2))
                base_parameter_id,
             cwms_util.get_sub_id (REGEXP_SUBSTR (p_cwms_ts_id,
                                                  '[^.]+',
                                                  1,
                                                  2))
                sub_parameter_id,
             REGEXP_SUBSTR (p_cwms_ts_id,
                            '[^.]+',
                            1,
                            3)
                parameter_type_id,
             REGEXP_SUBSTR (p_cwms_ts_id,
                            '[^.]+',
                            1,
                            4)
                interval_id,
             REGEXP_SUBSTR (p_cwms_ts_id,
                            '[^.]+',
                            1,
                            5)
                duration_id,
             REGEXP_SUBSTR (p_cwms_ts_id,
                            '[^.]+',
                            1,
                            6)
                VERSION
        INTO p_base_location_id,
             p_sub_location_id,
             p_base_parameter_id,
             p_sub_parameter_id,
             p_parameter_type_id,
             p_interval_id,
             p_duration_id,
             p_version_id
        FROM DUAL;
   END parse_ts;



   PROCEDURE zretrieve_ts (p_at_tsv_rc      IN OUT SYS_REFCURSOR,
                           p_units          IN     VARCHAR2,
                           p_cwms_ts_id     IN     VARCHAR2,
                           p_start_time     IN     DATE,
                           p_end_time       IN     DATE,
                           p_trim           IN     VARCHAR2 DEFAULT 'F',
                           p_inclusive      IN     NUMBER DEFAULT NULL,
                           p_version_date   IN     DATE DEFAULT NULL,
                           p_max_version    IN     VARCHAR2 DEFAULT 'T',
                           p_db_office_id   IN     VARCHAR2 DEFAULT NULL)
   IS
      l_ts_interval       NUMBER;
      l_ts_offset         NUMBER;
      l_versioned         NUMBER;
      l_ts_code           NUMBER;
      l_version_date      DATE;
      l_max_version       BOOLEAN;
      l_trim              BOOLEAN;
      l_start_time        DATE := p_start_time;
      l_start_trim_time   DATE;
      l_end_time          DATE := p_end_time;
      l_end_trim_time     DATE;
      l_end_time_init     DATE := l_end_time;
      l_db_office_id      VARCHAR2 (16);
   BEGIN
      --
      DBMS_APPLICATION_INFO.set_module ('Cwms_ts_retrieve', 'Check Interval');

      --
      -- set default values, don't be fooled by NULL as an actual argument
      IF p_db_office_id IS NULL
      THEN
         l_db_office_id := cwms_util.user_office_id;
      ELSE
         l_db_office_id := p_db_office_id;
      END IF;

      IF p_trim IS NULL
      THEN
         l_trim := FALSE;
      ELSE
         l_trim := cwms_util.return_true_or_false (p_trim);
      END IF;

      IF NVL (p_max_version, 'T') = 'T'
      THEN
         l_max_version := FALSE;
      ELSE
         l_max_version := TRUE;
      END IF;

      l_version_date := NVL (p_version_date, cwms_util.non_versioned);

      -- Make initial checks on start/end dates...
      IF p_start_time IS NULL OR p_end_time IS NULL
      THEN
         cwms_err.raise ('ERROR', 'No way Jose');
      END IF;

      IF p_end_time < p_start_time
      THEN
         cwms_err.raise ('ERROR', 'No way Jose');
      END IF;


      --Get Time series parameters for retrieval load into record structure
      BEGIN
         SELECT INTERVAL,
                CASE interval_utc_offset
                   WHEN cwms_util.utc_offset_undefined THEN NULL
                   WHEN cwms_util.utc_offset_irregular THEN NULL
                   ELSE (interval_utc_offset)
                END,
                version_flag,
                ts_code
           INTO l_ts_interval,
                l_ts_offset,
                l_versioned,
                l_ts_code
           FROM at_cwms_ts_id
          WHERE     db_office_id = UPPER (l_db_office_id)
                AND UPPER (cwms_ts_id) = UPPER (p_cwms_ts_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            SELECT INTERVAL,
                   CASE interval_utc_offset
                      WHEN cwms_util.utc_offset_undefined THEN NULL
                      WHEN cwms_util.utc_offset_irregular THEN NULL
                      ELSE (interval_utc_offset)
                   END,
                   version_flag,
                   ts_code
              INTO l_ts_interval,
                   l_ts_offset,
                   l_versioned,
                   l_ts_code
              FROM at_cwms_ts_id
             WHERE     db_office_id = UPPER (l_db_office_id)
                   AND UPPER (cwms_ts_id) = UPPER (p_cwms_ts_id);
      END;


      IF l_ts_interval = 0
      THEN
         IF p_inclusive IS NOT NULL
         THEN
            IF l_versioned IS NULL
            THEN                                      -- l_versioned IS NULL -
               --
               -- nonl_versioned, irregular, inclusive retrieval
               --
               DBMS_OUTPUT.put_line ('RETRIEVE_TS #1');

               --
               OPEN p_at_tsv_rc FOR
                    SELECT date_time, VALUE, quality_code
                      FROM (SELECT date_time,
                                   VALUE,
                                   quality_code,
                                   LAG (date_time, 1, l_start_time)
                                      OVER (ORDER BY date_time)
                                      lagdate,
                                   LEAD (date_time, 1, l_end_time)
                                      OVER (ORDER BY date_time)
                                      leaddate
                              FROM av_tsv_dqu v
                             WHERE     v.ts_code = l_ts_code
                                   AND v.unit_id = cwms_util.get_unit_id(p_units)
                                   AND v.start_date <= l_end_time
                                   AND v.end_date > l_start_time)
                     WHERE leaddate >= l_start_time AND lagdate <= l_end_time
                  ORDER BY date_time ASC;
            ELSE                                  -- l_versioned IS NOT NULL -
               --
               -- l_versioned, irregular, inclusive retrieval -
               IF p_version_date IS NULL
               THEN                                -- p_version_date IS NULL -
                  IF l_max_version
                  THEN                              -- l_max_version is TRUE -
                     --latest version_date query -
                     --
                     DBMS_OUTPUT.put_line ('RETRIEVE_TS #2');

                     --
                     OPEN p_at_tsv_rc FOR
                          SELECT date_time, VALUE, quality_code
                            FROM (SELECT date_time,
                                         MAX (
                                            VALUE)
                                         KEEP (DENSE_RANK LAST ORDER BY
                                                                  version_date)
                                            VALUE,
                                         MAX (
                                            quality_code)
                                         KEEP (DENSE_RANK LAST ORDER BY
                                                                  version_date)
                                            quality_code
                                    FROM (SELECT date_time,
                                                 VALUE,
                                                 quality_code,
                                                 version_date,
                                                 LAG (date_time,
                                                      1,
                                                      l_start_time)
                                                 OVER (ORDER BY date_time)
                                                    lagdate,
                                                 LEAD (date_time,
                                                       1,
                                                       l_end_time)
                                                 OVER (ORDER BY date_time)
                                                    leaddate
                                            FROM av_tsv_dqu v
                                           WHERE     v.ts_code = l_ts_code
                                                 AND v.unit_id = cwms_util.get_unit_id(p_units)
                                                 AND v.start_date <= l_end_time
                                                 AND v.end_date > l_start_time)
                                   WHERE     leaddate >= l_start_time
                                         AND lagdate <= l_end_time)
                        ORDER BY date_time ASC;
                  ELSE                              --l_max_version is FALSE -
                     -- first version_date query -
                     --
                     DBMS_OUTPUT.put_line ('RETRIEVE_TS #3');

                     --
                     OPEN p_at_tsv_rc FOR
                          SELECT date_time, VALUE, quality_code
                            FROM (SELECT date_time,
                                         MAX (
                                            VALUE)
                                         KEEP (DENSE_RANK FIRST ORDER BY
                                                                   version_date)
                                            VALUE,
                                         MAX (
                                            quality_code)
                                         KEEP (DENSE_RANK FIRST ORDER BY
                                                                   version_date)
                                            quality_code
                                    FROM (SELECT date_time,
                                                 VALUE,
                                                 quality_code,
                                                 version_date,
                                                 LAG (date_time,
                                                      1,
                                                      l_start_time)
                                                 OVER (ORDER BY date_time)
                                                    lagdate,
                                                 LEAD (date_time,
                                                       1,
                                                       l_end_time)
                                                 OVER (ORDER BY date_time)
                                                    leaddate
                                            FROM av_tsv_dqu v
                                           WHERE     v.ts_code = l_ts_code
                                                 AND v.unit_id = cwms_util.get_unit_id(p_units)
                                                 AND v.start_date <= l_end_time
                                                 AND v.end_date > l_start_time)
                                   WHERE     leaddate >= l_start_time
                                         AND lagdate <= l_end_time)
                        ORDER BY date_time ASC;
                  END IF;                                    --l_max_version -
               ELSE                             --p_version_date IS NOT NULL -
                  --
                  --selected version_date query -
                  --
                  DBMS_OUTPUT.put_line ('RETRIEVE_TS #4');

                  --
                  OPEN p_at_tsv_rc FOR
                       SELECT date_time, VALUE, quality_code
                         FROM (SELECT date_time,
                                      VALUE,
                                      quality_code,
                                      LAG (date_time, 1, l_start_time)
                                         OVER (ORDER BY date_time)
                                         lagdate,
                                      LEAD (date_time, 1, l_end_time)
                                         OVER (ORDER BY date_time)
                                         leaddate
                                 FROM av_tsv_dqu v
                                WHERE     v.ts_code = l_ts_code
                                      AND v.unit_id = cwms_util.get_unit_id(p_units)
                                      AND v.version_date = p_version_date
                                      AND v.start_date <= l_end_time
                                      AND v.end_date > l_start_time)
                        WHERE     leaddate >= l_start_time
                              AND lagdate <= l_end_time
                     ORDER BY date_time ASC;
               END IF;                                      --p_version_date -
            END IF;                                           -- l_versioned -
         ELSE                                         -- p_inclusive IS NULL -
            DBMS_APPLICATION_INFO.set_action (
                  'return  irregular  ts '
               || l_ts_code
               || ' from '
               || TO_CHAR (l_start_time, 'mm/dd/yyyy hh24:mi')
               || ' to '
               || TO_CHAR (l_end_time, 'mm/dd/yyyy hh24:mi')
               || ' in units '
               || p_units);

            IF l_versioned IS NULL
            THEN
               -- nonl_versioned, irregular, noninclusive retrieval -
               --
               DBMS_OUTPUT.put_line ('gk - RETRIEVE_TS #5 ');

               --
               OPEN p_at_tsv_rc FOR
                    SELECT date_time, VALUE, quality_code
                      FROM av_tsv_dqu v
                     WHERE     v.ts_code = l_ts_code
                           AND v.date_time BETWEEN l_start_time AND l_end_time
                           AND v.unit_id = cwms_util.get_unit_id(p_units)
                           AND v.start_date <= l_end_time
                           AND v.end_date > l_start_time
                  ORDER BY date_time ASC;
            ELSE                                  -- l_versioned IS NOT NULL -
               --
               -- l_versioned, irregular, noninclusive retrieval -
               --
               IF p_version_date IS NULL
               THEN
                  IF l_max_version
                  THEN
                     --latest version_date query
                     --
                     DBMS_OUTPUT.put_line ('RETRIEVE_TS #6');

                     --
                     OPEN p_at_tsv_rc FOR
                          SELECT date_time, VALUE, quality_code
                            FROM (  SELECT date_time,
                                           MAX (
                                              VALUE)
                                           KEEP (DENSE_RANK LAST ORDER BY
                                                                    version_date)
                                              VALUE,
                                           MAX (
                                              quality_code)
                                           KEEP (DENSE_RANK LAST ORDER BY
                                                                    version_date)
                                              quality_code
                                      FROM (SELECT date_time,
                                                   VALUE,
                                                   quality_code,
                                                   version_date
                                              FROM av_tsv_dqu v
                                             WHERE     v.ts_code = l_ts_code
                                                   AND v.date_time BETWEEN l_start_time
                                                                       AND l_end_time
                                                   AND v.unit_id = cwms_util.get_unit_id(p_units)
                                                   AND v.start_date <= l_end_time
                                                   AND v.end_date > l_start_time)
                                  GROUP BY date_time)
                        ORDER BY date_time ASC;
                  ELSE                         -- p_version_date IS NOT NULL -
                     --
                     DBMS_OUTPUT.put_line ('RETRIEVE_TS #7');

                     --
                     OPEN p_at_tsv_rc FOR
                          SELECT date_time, VALUE, quality_code
                            FROM (  SELECT date_time,
                                           MAX (
                                              VALUE)
                                           KEEP (DENSE_RANK FIRST ORDER BY
                                                                     version_date)
                                              VALUE,
                                           MAX (
                                              quality_code)
                                           KEEP (DENSE_RANK FIRST ORDER BY
                                                                     version_date)
                                              quality_code
                                      FROM (SELECT date_time,
                                                   VALUE,
                                                   quality_code,
                                                   version_date
                                              FROM av_tsv_dqu v
                                             WHERE     v.ts_code = l_ts_code
                                                   AND v.date_time BETWEEN l_start_time
                                                                       AND l_end_time
                                                   AND v.unit_id = cwms_util.get_unit_id(p_units)
                                                   AND v.start_date <= l_end_time
                                                   AND v.end_date > l_start_time)
                                  GROUP BY date_time)
                        ORDER BY date_time ASC;
                  END IF;                      -- p_version_date IS NOT NULL -
               ELSE                                -- l_max_version is FALSE -
                  --
                  DBMS_OUTPUT.put_line ('RETRIEVE_TS #8');

                  --
                  OPEN p_at_tsv_rc FOR
                       SELECT date_time, VALUE, quality_code
                         FROM av_tsv_dqu v
                        WHERE     v.ts_code = l_ts_code
                              AND v.date_time BETWEEN l_start_time
                                                  AND l_end_time
                              AND v.unit_id = cwms_util.get_unit_id(p_units)
                              AND v.version_date = version_date
                              AND v.start_date <= l_end_time
                              AND v.end_date > l_start_time
                     ORDER BY date_time ASC;
               END IF;                                      -- l_max_version -
            END IF;                                           -- l_versioned -
         END IF;                                              -- p_inclusive -
      ELSE                                             -- l_ts_interval <> 0 -
         DBMS_APPLICATION_INFO.set_action (
               'return  regular  ts '
            || l_ts_code
            || ' from '
            || TO_CHAR (l_start_time, 'mm/dd/yyyy hh24:mi')
            || ' to '
            || TO_CHAR (l_end_time, 'mm/dd/yyyy hh24:mi')
            || ' in units '
            || p_units);
         -- Make sure start_time and end_time fall on a valid date/time for the regular -
         --    time series given the interval and offset. -
         l_start_time :=
            get_time_on_after_interval (l_start_time,
                                        l_ts_offset,
                                        l_ts_interval);
         l_end_time :=
            get_time_on_after_interval (l_end_time,
                                        l_ts_offset,
                                        l_ts_interval);

         IF l_end_time > l_end_time_init
         THEN
            l_end_time := l_end_time - (l_ts_interval / 1440);
         END IF;

         IF l_versioned IS NULL
         THEN
            --
            -- non_versioned, regular ts query
            --
            DBMS_OUTPUT.put_line (
               'RETRIEVE_TS #9 - non versioned, regular ts query');

            --

            IF l_trim
            THEN
               SELECT MAX (date_time), MIN (date_time)
                 INTO l_end_trim_time, l_start_trim_time
                 FROM av_tsv v
                WHERE     v.ts_code = l_ts_code
                      AND v.date_time BETWEEN l_start_time AND l_end_time
                      AND v.start_date <= l_end_time
                      AND v.end_date > l_start_time;
            ELSE
               l_end_trim_time := l_end_time;
               l_start_trim_time := l_start_time;
            END IF;

            OPEN p_at_tsv_rc FOR
                 SELECT date_time "DATE_TIME",
                        VALUE,
                        NVL (quality_code, 0) quality_code
                   FROM (SELECT date_time, v.VALUE, v.quality_code
                           FROM    (SELECT date_time, v.VALUE, v.quality_code
                                      FROM av_tsv_dqu v
                                     WHERE     v.ts_code = l_ts_code
                                           AND v.date_time BETWEEN l_start_time
                                                               AND l_end_time
                                           AND v.unit_id = cwms_util.get_unit_id(p_units)
                                           AND v.start_date <= l_end_time
                                           AND v.end_date > l_start_time) v
                                RIGHT OUTER JOIN
                                   (    SELECT   l_start_trim_time
                                               + (  (LEVEL - 1)
                                                  / (1440 / (l_ts_interval)))
                                                  date_time
                                          FROM DUAL
                                    CONNECT BY     1 = 1
                                               AND LEVEL <=
                                                        (  ROUND (
                                                                (  l_end_trim_time
                                                                 - l_start_trim_time)
                                                              * 1440)
                                                         / l_ts_interval)
                                                      + 1) t
                                USING (date_time))
               ORDER BY date_time;
         ELSE                                    --  l_versioned IS NOT NULL -
            IF p_version_date IS NULL
            THEN
               IF l_max_version
               THEN
                  --
                  DBMS_OUTPUT.put_line ('RETRIEVE_TS #10');

                  --
                  OPEN p_at_tsv_rc FOR
                       SELECT date_time, VALUE, quality_code
                         FROM (  SELECT jdate_time date_time,
                                        MAX (
                                           VALUE)
                                        KEEP (DENSE_RANK LAST ORDER BY
                                                                 version_date)
                                           VALUE,
                                        MAX (
                                           quality_code)
                                        KEEP (DENSE_RANK LAST ORDER BY
                                                                 version_date)
                                           quality_code
                                   FROM (SELECT *
                                           FROM    (SELECT *
                                                      FROM av_tsv_dqu v
                                                     WHERE     v.ts_code =
                                                                  l_ts_code
                                                           AND v.date_time BETWEEN l_start_time
                                                                               AND l_end_time
                                                           AND v.unit_id =
                                                                  cwms_util.get_unit_id(p_units)
                                                           AND v.start_date <=
                                                                  l_end_time
                                                           AND v.end_date >
                                                                  l_start_time) v
                                                RIGHT OUTER JOIN
                                                   (    SELECT   l_start_time
                                                               + (  (LEVEL - 1)
                                                                  / (  1440
                                                                     / l_ts_interval))
                                                                  jdate_time
                                                          FROM DUAL
                                                    CONNECT BY     1 = 1
                                                               AND LEVEL <=
                                                                        (  ROUND (
                                                                                (  l_end_time
                                                                                 - l_start_time)
                                                                              * 1440)
                                                                         / l_ts_interval)
                                                                      + 1) t
                                                ON t.jdate_time = v.date_time)
                               ORDER BY jdate_time)
                     GROUP BY date_time;
               ELSE                                -- l_max_version is FALSE -
                  --
                  DBMS_OUTPUT.put_line ('RETRIEVE_TS #11');

                  --
                  OPEN p_at_tsv_rc FOR
                       SELECT date_time, VALUE, quality_code
                         FROM (  SELECT jdate_time date_time,
                                        MAX (
                                           VALUE)
                                        KEEP (DENSE_RANK FIRST ORDER BY
                                                                  version_date)
                                           VALUE,
                                        MAX (
                                           quality_code)
                                        KEEP (DENSE_RANK FIRST ORDER BY
                                                                  version_date)
                                           quality_code
                                   FROM (SELECT *
                                           FROM    (SELECT *
                                                      FROM av_tsv_dqu v
                                                     WHERE     v.ts_code =
                                                                  l_ts_code
                                                           AND v.date_time BETWEEN l_start_time
                                                                               AND l_end_time
                                                           AND v.unit_id =
                                                                  cwms_util.get_unit_id(p_units)
                                                           AND v.start_date <=
                                                                  l_end_time
                                                           AND v.end_date >
                                                                  l_start_time) v
                                                RIGHT OUTER JOIN
                                                   (    SELECT   l_start_time
                                                               + (  (LEVEL - 1)
                                                                  / (  1440
                                                                     / l_ts_interval))
                                                                  jdate_time
                                                          FROM DUAL
                                                    CONNECT BY     1 = 1
                                                               AND LEVEL <=
                                                                        (  ROUND (
                                                                                (  l_end_time
                                                                                 - l_start_time)
                                                                              * 1440)
                                                                         / l_ts_interval)
                                                                      + 1) t
                                                ON t.jdate_time = v.date_time)
                               ORDER BY jdate_time)
                     GROUP BY date_time;
               END IF;                                      -- l_max_version -
            ELSE                               -- p_version_date IS NOT NULL -
               --
               DBMS_OUTPUT.put_line ('RETRIEVE_TS #12');

               --
               OPEN p_at_tsv_rc FOR
                    SELECT jdate_time date_time,
                           VALUE,
                           NVL (quality_code, 0) quality_code
                      FROM (SELECT *
                              FROM    (SELECT *
                                         FROM av_tsv_dqu v
                                        WHERE     v.ts_code = l_ts_code
                                              AND v.date_time BETWEEN l_start_time
                                                                  AND l_end_time
                                              AND v.unit_id = cwms_util.get_unit_id(p_units)
                                              AND v.version_date =
                                                     p_version_date
                                              AND v.start_date <= l_end_time
                                              AND v.end_date > l_start_time) v
                                   RIGHT OUTER JOIN
                                      (    SELECT   l_start_time
                                                  + (  (LEVEL - 1)
                                                     / (1440 / l_ts_interval))
                                                     jdate_time
                                             FROM DUAL
                                       CONNECT BY     1 = 1
                                                  AND LEVEL <=
                                                           (  ROUND (
                                                                   (  l_end_time
                                                                    - l_start_time)
                                                                 * 1440)
                                                            / l_ts_interval)
                                                         + 1) t
                                   ON t.jdate_time = v.date_time)
                  ORDER BY jdate_time;
            END IF;
         END IF;
      END IF;

      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   END zretrieve_ts;

   PROCEDURE zretrieve_ts_java (
      p_transaction_time      OUT DATE,
      p_at_tsv_rc             OUT SYS_REFCURSOR,
      p_units_out             OUT VARCHAR2,
      p_cwms_ts_id_out        OUT VARCHAR2,
      p_units_in           IN     VARCHAR2,
      p_cwms_ts_id_in      IN     VARCHAR2,
      p_start_time         IN     DATE,
      p_end_time           IN     DATE,
      p_trim               IN     VARCHAR2 DEFAULT 'F',
      p_inclusive          IN     NUMBER DEFAULT NULL,
      p_version_date       IN     DATE DEFAULT NULL,
      p_max_version        IN     VARCHAR2 DEFAULT 'T',
      p_db_office_id       IN     VARCHAR2 DEFAULT NULL)
   IS
      /*l_at_tsv_rc   sys_refcursor;*/
      l_inclusive   VARCHAR2 (1);
   BEGIN
      p_transaction_time := CAST ( (SYSTIMESTAMP AT TIME ZONE 'GMT') AS DATE);

      IF NVL (p_inclusive, 0) = 0
      THEN
         l_inclusive := 'F';
      ELSE
         l_inclusive := 'T';
      END IF;

      retrieve_ts_out (p_at_tsv_rc,
                       p_cwms_ts_id_out,
                       p_units_out,
                       p_cwms_ts_id_in,
                       p_units_in,
                       p_start_time,
                       p_end_time,
                       'UTC',
                       p_trim,
                       l_inclusive,
                       l_inclusive,
                       'F',
                       'F',
                       p_version_date,
                       p_max_version,
                       p_db_office_id);
   END zretrieve_ts_java;

   PROCEDURE retrieve_existing_times(
      p_cursor           OUT sys_refcursor,
      p_ts_code          IN  NUMBER,
      p_start_time_utc   IN  DATE            DEFAULT NULL,
      p_end_time_utc     IN  DATE            DEFAULT NULL,
      p_date_times_utc   in  date_table_type DEFAULT NULL,
      p_version_date_utc IN  DATE            DEFAULT NULL,
      p_max_version      IN  BOOLEAN         DEFAULT TRUE,
      p_item_mask        IN  BINARY_INTEGER  DEFAULT cwms_util.ts_all)
   IS
   BEGIN
      p_cursor := retrieve_existing_times_f(
         p_ts_code,
         p_start_time_utc,
         p_end_time_utc,
         p_date_times_utc,
         p_version_date_utc,
         p_max_version);

   END retrieve_existing_times;

   FUNCTION retrieve_existing_times_f(
      p_ts_code          IN  NUMBER,
      p_start_time_utc   IN  DATE            DEFAULT NULL,
      p_end_time_utc     IN  DATE            DEFAULT NULL,
      p_date_times_utc   in  date_table_type DEFAULT NULL,
      p_version_date_utc IN  DATE            DEFAULT NULL,
      p_max_version      IN  BOOLEAN         DEFAULT TRUE,
      p_item_mask        IN  BINARY_INTEGER  DEFAULT cwms_util.ts_all)
      RETURN sys_refcursor
   IS
      l_is_versioned           varchar2(1);
      l_version_date_utc       date;
      l_date_times_values      date_table_type := date_table_type();
      l_version_dates_values   date_table_type := date_table_type();
      l_date_times_std_text    date_table_type := date_table_type();
      l_version_dates_std_text date_table_type := date_table_type();
      l_date_times_text        date_table_type := date_table_type();
      l_version_dates_text     date_table_type := date_table_type();
      l_date_times_binary      date_table_type := date_table_type();
      l_version_dates_binary   date_table_type := date_table_type();
      l_value_times            date2_tab_t := date2_tab_t();
      l_std_text_times         date2_tab_t := date2_tab_t();
      l_text_times             date2_tab_t := date2_tab_t();
      l_binary_times           date2_tab_t := date2_tab_t();
      l_cursor                 sys_refcursor;
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      if p_ts_code is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TS_CODE');
      end if;
      if p_date_times_utc is not null and (p_start_time_utc is not null or p_end_time_utc is not null) then
         cwms_err.raise('ERROR', 'Start and/or end times cannot be specified with specific times.');
      end if;

      -----------------------------------------------
      -- collect the times for the specified items --
      -----------------------------------------------
      cwms_ts.is_ts_versioned(l_is_versioned, p_ts_code);
      if p_version_date_utc is null then
         -------------------------------
         -- no version_date specified --
         -------------------------------
         if cwms_util.return_true_or_false(l_is_versioned) then
            ---------------------------
            -- versioned time series --
            ---------------------------
            if p_max_version then
               ---------------------------
               -- max_version specified --
               ---------------------------
               if bitand(p_item_mask, cwms_util.ts_values) > 0 then
                  if p_date_times_utc is null then
                       select date_time, max(version_date)
                         bulk collect into l_date_times_values, l_version_dates_values
                         from av_tsv
                        where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                     group by ts_code, date_time;
                  else
                       select date_time, max(version_date)
                         bulk collect into l_date_times_values, l_version_dates_values
                         from av_tsv
                        where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc))
                     group by ts_code, date_time;
                  end if;
               end if;
               if bitand(p_item_mask, cwms_util.ts_std_text) > 0 then
                  if p_date_times_utc is null then
                       select date_time, max(version_date)
                         bulk collect into l_date_times_std_text, l_version_dates_std_text
                         from at_tsv_std_text
                        where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                     group by ts_code, date_time;
                  else
                       select date_time, max(version_date)
                         bulk collect into l_date_times_std_text, l_version_dates_std_text
                         from at_tsv_std_text
                        where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc))
                     group by ts_code, date_time;
                  end if;
               end if;
               if bitand(p_item_mask, cwms_util.ts_text) > 0 then
                  if p_date_times_utc is null then
                       select date_time, max(version_date)
                         bulk collect into l_date_times_text, l_version_dates_text
                         from at_tsv_text
                        where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                     group by ts_code, date_time;
                  else
                       select date_time, max(version_date)
                         bulk collect into l_date_times_text, l_version_dates_text
                         from at_tsv_text
                        where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc))
                     group by ts_code, date_time;
                  end if;
               end if;
               if bitand(p_item_mask, cwms_util.ts_binary) > 0 then
                  if p_date_times_utc is null then
                       select date_time, max(version_date)
                         bulk collect into l_date_times_binary, l_version_dates_binary
                         from at_tsv_binary
                        where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                     group by ts_code, date_time;
                  else
                       select date_time, max(version_date)
                         bulk collect into l_date_times_binary, l_version_dates_binary
                         from at_tsv_binary
                        where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc))
                     group by ts_code, date_time;
                  end if;
               end if;
            else
               ---------------------------
               -- min_version specified --
               ---------------------------
               if bitand(p_item_mask, cwms_util.ts_values) > 0 then
                  if p_date_times_utc is null then
                       select date_time, min(version_date)
                         bulk collect into l_date_times_values, l_version_dates_values
                         from av_tsv
                        where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                     group by ts_code, date_time;
                  else
                       select date_time, min(version_date)
                         bulk collect into l_date_times_values, l_version_dates_values
                         from av_tsv
                        where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc))
                     group by ts_code, date_time;
                  end if;
               end if;
               if bitand(p_item_mask, cwms_util.ts_std_text) > 0 then
                  if p_date_times_utc is null then
                       select date_time, min(version_date)
                         bulk collect into l_date_times_std_text, l_version_dates_std_text
                         from at_tsv_std_text
                        where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                     group by ts_code, date_time;
                  else
                       select date_time, min(version_date)
                         bulk collect into l_date_times_std_text, l_version_dates_std_text
                         from at_tsv_std_text
                        where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc))
                     group by ts_code, date_time;
                  end if;
               end if;
               if bitand(p_item_mask, cwms_util.ts_text) > 0 then
                  if p_date_times_utc is null then
                       select date_time, min(version_date)
                         bulk collect into l_date_times_text, l_version_dates_text
                         from at_tsv_text
                        where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                     group by ts_code, date_time;
                  else
                       select date_time, min(version_date)
                         bulk collect into l_date_times_text, l_version_dates_text
                         from at_tsv_text
                        where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc))
                     group by ts_code, date_time;
                  end if;
               end if;
               if bitand(p_item_mask, cwms_util.ts_binary) > 0 then
                  if p_date_times_utc is null then
                       select date_time, min(version_date)
                         bulk collect into l_date_times_binary, l_version_dates_binary
                         from at_tsv_binary
                        where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                     group by ts_code, date_time;
                  else
                       select date_time, min(version_date)
                         bulk collect into l_date_times_binary, l_version_dates_binary
                         from at_tsv_binary
                        where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc))
                     group by ts_code, date_time;
                  end if;
               end if;
            end if;
         else
            -------------------------------
            -- non-versioned time series --
            -------------------------------
            if bitand(p_item_mask, cwms_util.ts_values) > 0 then
               if p_date_times_utc is null then
                  select date_time, version_date
                    bulk collect into l_date_times_values, l_version_dates_values
                    from av_tsv
                   where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time);
               else
                  select date_time, version_date
                    bulk collect into l_date_times_values, l_version_dates_values
                    from av_tsv
                   where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc));
               end if;
            end if;
            if bitand(p_item_mask, cwms_util.ts_std_text) > 0 then
               if p_date_times_utc is null then
                  select date_time, version_date
                    bulk collect into l_date_times_std_text, l_version_dates_std_text
                    from at_tsv_std_text
                   where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time);
               else
                  select date_time, version_date
                    bulk collect into l_date_times_std_text, l_version_dates_std_text
                    from at_tsv_std_text
                   where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc));
               end if;
            end if;
            if bitand(p_item_mask, cwms_util.ts_text) > 0 then
               if p_date_times_utc is null then
                  select date_time, version_date
                    bulk collect into l_date_times_text, l_version_dates_text
                    from at_tsv_text
                   where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time);
               else
                  select date_time, version_date
                    bulk collect into l_date_times_text, l_version_dates_text
                    from at_tsv_text
                   where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc));
               end if;
            end if;
            if bitand(p_item_mask, cwms_util.ts_binary) > 0 then
               if p_date_times_utc is null then
                  select date_time, version_date
                    bulk collect into l_date_times_binary, l_version_dates_binary
                    from at_tsv_binary
                   where ts_code = p_ts_code and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time);
               else
                  select date_time, version_date
                    bulk collect into l_date_times_binary, l_version_dates_binary
                    from at_tsv_binary
                   where ts_code = p_ts_code and date_time in (select column_value from table(p_date_times_utc));
               end if;
            end if;
         end if;
      else
         -------------------------------
         -- version_date is specified --
         -------------------------------
         if p_version_date_utc != cwms_util.all_version_dates then
            l_version_date_utc := p_version_date_utc;
         end if;
         if bitand(p_item_mask, cwms_util.ts_values) > 0 then
            if p_date_times_utc is null then
               select date_time, version_date
                 bulk collect into l_date_times_values, l_version_dates_values
                 from av_tsv
                where ts_code = p_ts_code
                  and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                  and version_date = nvl(l_version_date_utc, version_date);
            else
               select date_time, version_date
                 bulk collect into l_date_times_values, l_version_dates_values
                 from av_tsv
                where ts_code = p_ts_code
                  and date_time in (select column_value from table(p_date_times_utc))
                  and version_date = nvl(l_version_date_utc, version_date);
            end if;
         end if;
         if bitand(p_item_mask, cwms_util.ts_std_text) > 0 then
            if p_date_times_utc is null then
               select date_time, version_date
                 bulk collect into l_date_times_std_text, l_version_dates_std_text
                 from at_tsv_std_text
                where ts_code = p_ts_code
                  and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                  and version_date = nvl(l_version_date_utc, version_date);
            else
               select date_time, version_date
                 bulk collect into l_date_times_std_text, l_version_dates_std_text
                 from at_tsv_std_text
                where ts_code = p_ts_code
                  and date_time in (select column_value from table(p_date_times_utc))
                  and version_date = nvl(l_version_date_utc, version_date);
            end if;
         end if;
         if bitand(p_item_mask, cwms_util.ts_text) > 0 then
            if p_date_times_utc is null then
               select date_time, version_date
                 bulk collect into l_date_times_text, l_version_dates_text
                 from at_tsv_text
                where ts_code = p_ts_code
                  and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                  and version_date = nvl(l_version_date_utc, version_date);
            else
               select date_time, version_date
                 bulk collect into l_date_times_text, l_version_dates_text
                 from at_tsv_text
                where ts_code = p_ts_code
                  and date_time in (select column_value from table(p_date_times_utc))
                  and version_date = nvl(l_version_date_utc, version_date);
            end if;
         end if;
         if bitand(p_item_mask, cwms_util.ts_binary) > 0 then
            if p_date_times_utc is null then
               select date_time, version_date
                 bulk collect into l_date_times_binary, l_version_dates_binary
                 from at_tsv_binary
                where ts_code = p_ts_code
                  and date_time between nvl(p_start_time_utc, date_time) and nvl(p_end_time_utc, date_time)
                  and version_date = nvl(l_version_date_utc, version_date);
            else
               select date_time, version_date
                 bulk collect into l_date_times_binary, l_version_dates_binary
                 from at_tsv_binary
                where ts_code = p_ts_code
                  and date_time in (select column_value from table(p_date_times_utc))
                  and version_date = nvl(l_version_date_utc, version_date);
            end if;
         end if;
      end if;
      ----------------------------------------------------
      -- collect the results into queryable collections --
      ----------------------------------------------------
      l_value_times.extend(l_date_times_values.count);
      for i in 1..l_date_times_values.count loop
         l_value_times(i) := date2_t(l_date_times_values(i), l_version_dates_values(i));
      end loop;
      l_std_text_times.extend(l_date_times_std_text.count);
      for i in 1..l_date_times_std_text.count loop
         l_std_text_times(i) := date2_t(l_date_times_std_text(i), l_version_dates_std_text(i));
      end loop;
      l_text_times.extend(l_date_times_text.count);
      for i in 1..l_date_times_text.count loop
         l_text_times(i) := date2_t(l_date_times_text(i), l_version_dates_text(i));
      end loop;
      l_binary_times.extend(l_date_times_binary.count);
      for i in 1..l_date_times_binary.count loop
         l_binary_times(i) := date2_t(l_date_times_binary(i), l_version_dates_binary(i));
      end loop;
      --------------------------------------
      -- return a cursor into the results --
      --------------------------------------
      open l_cursor for
         select date_1 as date_time,
                date_2 as version_date
           from (select * from table(l_value_times)
                 union
                 select * from table(l_std_text_times)
                 union
                 select * from table(l_text_times)
                 union
                 select * from table(l_binary_times)
                )
          order by date_1, date_2;
      return l_cursor;
   END retrieve_existing_times_f;

   PROCEDURE retrieve_existing_item_counts(
      p_cursor           OUT sys_refcursor,
      p_ts_code          IN  NUMBER,
      p_start_time_utc   IN  DATE            DEFAULT NULL,
      p_end_time_utc     IN  DATE            DEFAULT NULL,
      p_date_times_utc   in  date_table_type DEFAULT NULL,
      p_version_date_utc IN  DATE            DEFAULT NULL,
      p_max_version      IN  BOOLEAN         DEFAULT TRUE)
   IS
   BEGIN
      p_cursor := retrieve_existing_item_counts(
         p_ts_code,
         p_start_time_utc,
         p_end_time_utc,
         p_date_times_utc,
         p_version_date_utc,
         p_max_version);
   END retrieve_existing_item_counts;

function retrieve_existing_item_counts(
   p_ts_code          in number,
   p_start_time_utc   in date default null,
   p_end_time_utc     in date default null,
   p_date_times_utc   in date_table_type default null,
   p_version_date_utc in date default null,
   p_max_version      in boolean default true)
   return sys_refcursor
is
   l_cursor          sys_refcursor;
   l_date_times      date_table_type;
   l_version_dates   date_table_type;
   l_times           date2_tab_t := date2_tab_t();
begin
   l_cursor      :=
      retrieve_existing_times_f(
         p_ts_code,
         p_start_time_utc,
         p_end_time_utc,
         p_date_times_utc,
         p_version_date_utc,
         p_max_version,
         cwms_util.ts_all);

   fetch l_cursor
   bulk collect into l_date_times, l_version_dates;

   close l_cursor;

   l_times.extend(l_date_times.count);

   for i in 1 .. l_date_times.count loop
      l_times(i) := date2_t(l_date_times(i), l_version_dates(i));
   end loop;

   open l_cursor for
        select d.date_time,
               d.version_date,
               count(v.date_time) as value_count,
               count(s.date_time) as std_text_count,
               count(t.date_time) as text_count,
               count(b.date_time) as binary_count
          from (select date_1 as date_time, date_2 as version_date from table(l_times)) d
               left outer join (select date_time, version_date
                                  from av_tsv
                                 where ts_code = p_ts_code) v
                  on v.date_time = d.date_time and v.version_date = d.version_date
               left outer join (select date_time, version_date
                                  from at_tsv_std_text
                                 where ts_code = p_ts_code) s
                  on s.date_time = d.date_time and s.version_date = d.version_date
               left outer join (select date_time, version_date
                                  from at_tsv_text
                                 where ts_code = p_ts_code) t
                  on t.date_time = d.date_time and t.version_date = d.version_date
               left outer join (select date_time, version_date
                                  from at_tsv_binary
                                 where ts_code = p_ts_code) b
                  on b.date_time = d.date_time and b.version_date = d.version_date
      group by d.date_time, d.version_date
      order by d.date_time, d.version_date;

   return l_cursor;
end retrieve_existing_item_counts;

   PROCEDURE collect_deleted_times (p_deleted_time   IN TIMESTAMP,
                                    p_ts_code        IN NUMBER,
                                    p_version_date   IN DATE,
                                    p_start_time     IN DATE,
                                    p_end_time       IN DATE)
   IS
      l_table_names   str_tab_t;
      l_millis        NUMBER (14);
   BEGIN
      SELECT table_name
        BULK COLLECT INTO l_table_names
        FROM at_ts_table_properties
       WHERE start_date <= p_end_time AND end_date > p_start_time;

      l_millis := cwms_util.to_millis (p_deleted_time);

      FOR i IN 1 .. l_table_names.COUNT
      LOOP
         EXECUTE IMMEDIATE REPLACE (
            'insert
               into at_ts_deleted_times
             select :millis,
                    :ts_code,
                    :version_date,
                    date_time
               from table_name
              where ts_code = :ts_code
                and version_date = :version_date
                and date_time between :start_time and :end_time',
                             'table_name',
                             l_table_names (i))
            USING l_millis,
                  p_ts_code,
                  p_version_date,
                  p_ts_code,
                  p_version_date,
                  p_start_time,
                  p_end_time;
      END LOOP;
   END collect_deleted_times;

   PROCEDURE retrieve_deleted_times (
      p_deleted_times      OUT date_table_type,
      p_deleted_time    IN     NUMBER,
      p_ts_code         IN     NUMBER,
      p_version_date    IN     NUMBER)
   IS
   BEGIN
        SELECT date_time
          BULK COLLECT INTO p_deleted_times
          FROM at_ts_deleted_times
         WHERE     deleted_time = p_deleted_time
               AND ts_code = p_ts_code
               AND version_date =
                      CAST (cwms_util.TO_TIMESTAMP (p_version_date) AS DATE)
      ORDER BY date_time;
   END retrieve_deleted_times;

   FUNCTION retrieve_deleted_times_f (p_deleted_time   IN NUMBER,
                                      p_ts_code        IN NUMBER,
                                      p_version_date   IN NUMBER)
      RETURN date_table_type
   IS
      l_deleted_times   date_table_type;
   BEGIN
      retrieve_deleted_times (l_deleted_times,
                              p_deleted_time,
                              p_ts_code,
                              p_version_date);

      RETURN l_deleted_times;
   END retrieve_deleted_times_f;

   -- p_fail_if_exists 'T' will throw an exception if the parameter_id already    -
   --                        exists.                                              -
   --                  'F' will simply return the parameter code of the already   -
   --                        existing parameter id.                               -
   PROCEDURE create_parameter_code (
      p_base_parameter_code      OUT NUMBER,
      p_parameter_code           OUT NUMBER,
      p_base_parameter_id     IN     VARCHAR2,
      p_sub_parameter_id      IN     VARCHAR2,
      p_fail_if_exists        IN     VARCHAR2 DEFAULT 'T',
      p_db_office_code        IN     NUMBER)
   IS
      l_all_office_code       NUMBER := cwms_util.db_office_code_all;
      l_parameter_id_exists   BOOLEAN := FALSE;
   BEGIN
      IF p_db_office_code = 0
      THEN
         cwms_err.RAISE ('INVALID_OFFICE_ID', 'Unkown');
      END IF;

      BEGIN
         SELECT base_parameter_code
           INTO p_base_parameter_code
           FROM cwms_base_parameter
          WHERE UPPER (base_parameter_id) = UPPER (p_base_parameter_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.RAISE (
               'INVALID_PARAM_ID',
                  p_base_parameter_id
               || SUBSTR ('-', 1, LENGTH (p_sub_parameter_id))
               || p_sub_parameter_id);
      END;

      BEGIN
         IF p_sub_parameter_id IS NULL
         THEN
            SELECT parameter_code
              INTO p_parameter_code
              FROM at_parameter ap
             WHERE     base_parameter_code = p_base_parameter_code
                   AND sub_parameter_id IS NULL
                   AND db_office_code IN
                          (p_db_office_code, l_all_office_code);
         ELSE
            SELECT parameter_code
              INTO p_parameter_code
              FROM at_parameter ap
             WHERE     base_parameter_code = p_base_parameter_code
                   AND UPPER (sub_parameter_id) = UPPER (p_sub_parameter_id)
                   AND db_office_code IN
                          (p_db_office_code, l_all_office_code);
         END IF;

         l_parameter_id_exists := TRUE;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            IF p_sub_parameter_id IS NULL
            THEN
               cwms_err.RAISE (
                  'INVALID_PARAM_ID',
                     p_base_parameter_id
                  || SUBSTR ('-', 1, LENGTH (p_sub_parameter_id))
                  || p_sub_parameter_id);
            ELSE                                -- Insert new sub_parameter...
               INSERT INTO at_parameter (parameter_code,
                                         db_office_code,
                                         base_parameter_code,
                                         sub_parameter_id)
                    VALUES (cwms_seq.NEXTVAL,
                            p_db_office_code,
                            p_base_parameter_code,
                            p_sub_parameter_id)
                 RETURNING parameter_code
                      INTO p_parameter_code;
            END IF;
      END;

      IF UPPER (NVL (p_fail_if_exists, 'T')) = 'T' AND l_parameter_id_exists
      THEN
         cwms_err.RAISE (
            'ITEM_ALREADY_EXISTS',
               p_base_parameter_id
            || SUBSTR ('-', 1, LENGTH (p_sub_parameter_id))
            || p_sub_parameter_id,
            'Parameter Id');
      END IF;
   END create_parameter_code;


   PROCEDURE create_parameter_id (p_parameter_id   IN VARCHAR2,
                                  p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_code        NUMBER
                                 := cwms_util.get_db_office_code (p_db_office_id);
      l_base_parameter_code   NUMBER;
      l_parameter_code        NUMBER;
   BEGIN
      create_parameter_code (
         p_base_parameter_code   => l_base_parameter_code,
         p_parameter_code        => l_parameter_code,
         p_base_parameter_id     => cwms_util.get_base_id (p_parameter_id),
         p_sub_parameter_id      => cwms_util.get_sub_id (p_parameter_id),
         p_fail_if_exists        => 'F',
         p_db_office_code        => l_db_office_code);
   END;


   PROCEDURE delete_parameter_id (p_base_parameter_id   IN VARCHAR2,
                                  p_sub_parameter_id    IN VARCHAR2,
                                  p_db_office_code      IN NUMBER)
   IS
      l_base_parameter_code   NUMBER;
      l_parameter_code        NUMBER;
   BEGIN
      BEGIN
         SELECT base_parameter_code
           INTO l_base_parameter_code
           FROM cwms_base_parameter
          WHERE UPPER (base_parameter_id) = UPPER (p_base_parameter_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.RAISE (
               'INVALID_PARAM_ID',
                  p_base_parameter_id
               || SUBSTR ('-', 1, LENGTH (p_sub_parameter_id))
               || p_sub_parameter_id);
      END;

      DELETE FROM at_parameter
            WHERE     base_parameter_code = l_base_parameter_code
                  AND UPPER (sub_parameter_id) =
                         UPPER (TRIM (p_sub_parameter_id))
                  AND db_office_code = p_db_office_code;
   END;

   PROCEDURE delete_parameter_id (p_parameter_id   IN VARCHAR2,
                                  p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      delete_parameter_id (
         p_base_parameter_id   => cwms_util.get_base_id (p_parameter_id),
         p_sub_parameter_id    => cwms_util.get_sub_id (p_parameter_id),
         p_db_office_code      => cwms_util.get_db_office_code (
                                    p_db_office_id));
   END;


   PROCEDURE rename_parameter_id (
      p_parameter_id_old   IN VARCHAR2,
      p_parameter_id_new   IN VARCHAR2,
      p_db_office_id       IN VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_code_all        NUMBER := cwms_util.db_office_code_all;
      l_db_office_code            NUMBER
         := cwms_util.get_db_office_code (p_db_office_id);
      --
      l_db_office_code_old        NUMBER;
      l_base_parameter_code_old   NUMBER;
      l_parameter_code_old        NUMBER;
      l_sub_parameter_id_old      VARCHAR2 (32);
      l_parameter_code_new        NUMBER;
      l_base_parameter_code_new   NUMBER;
      l_base_parameter_id_new     VARCHAR2 (16);
      l_sub_parameter_id_new      VARCHAR2 (32);
      --
      l_new_parameter_id_exists   BOOLEAN := FALSE;
   BEGIN
      SELECT db_office_code,
             base_parameter_code,
             parameter_code,
             sub_parameter_id
        INTO l_db_office_code_old,
             l_base_parameter_code_old,
             l_parameter_code_old,
             l_sub_parameter_id_old
        FROM av_parameter
       WHERE     UPPER (parameter_id) = UPPER (TRIM (p_parameter_id_old))
             AND db_office_code IN (l_db_office_code_all, l_db_office_code);

      IF l_db_office_code_old = l_db_office_code_all
      THEN
         cwms_err.RAISE ('ITEM_OWNED_BY_CWMS', p_parameter_id_old);
      END IF;

      BEGIN
         SELECT base_parameter_code, parameter_code, sub_parameter_id
           INTO l_base_parameter_code_new,
                l_parameter_code_new,
                l_sub_parameter_id_new
           FROM av_parameter
          WHERE     UPPER (parameter_id) = UPPER (TRIM (p_parameter_id_new))
                AND db_office_code IN
                       (l_db_office_code_all, l_db_office_code);

         l_new_parameter_id_exists := TRUE;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            l_base_parameter_id_new :=
               cwms_util.get_base_id (cwms_util.strip(p_parameter_id_new));
            l_sub_parameter_id_new :=
               cwms_util.get_sub_id (cwms_util.strip(p_parameter_id_new));

            SELECT base_parameter_code
              INTO l_base_parameter_code_old
              FROM cwms_base_parameter
             WHERE UPPER (base_parameter_id) =
                      UPPER (l_base_parameter_id_new);

            l_parameter_code_new := 0;
      END;


      IF l_new_parameter_id_exists
      THEN
         IF     l_parameter_code_new = l_parameter_code_old
            AND l_sub_parameter_id_old = l_sub_parameter_id_new
         THEN
            cwms_err.RAISE ('CANNOT_RENAME_3', p_parameter_id_new);
         ELSE
            cwms_err.RAISE ('CANNOT_RENAME_2', p_parameter_id_new);
         END IF;
      END IF;

      UPDATE at_parameter
         SET sub_parameter_id = l_sub_parameter_id_new
       WHERE parameter_code = l_parameter_code_old;
   END;

   --
   --*******************************************************************   --
   --*******************************************************************   --
   --
   -- ZSTORE_TS -
   --
   PROCEDURE zstore_ts (
      p_cwms_ts_id        IN VARCHAR2,
      p_units             IN VARCHAR2,
      p_timeseries_data   IN ztsv_array,
      p_store_rule        IN VARCHAR2,
      p_override_prot     IN VARCHAR2 DEFAULT 'F',
      p_version_date      IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id         IN VARCHAR2 DEFAULT NULL)
   IS
      l_timeseries_data   tsv_array := tsv_array ();
   BEGIN
      l_timeseries_data.EXTEND (p_timeseries_data.COUNT);

      FOR i IN 1 .. p_timeseries_data.COUNT
      LOOP
         l_timeseries_data (i) :=
            tsv_type (
               FROM_TZ (CAST (p_timeseries_data (i).date_time AS TIMESTAMP),
                        'GMT'),
               p_timeseries_data (i).VALUE,
               p_timeseries_data (i).quality_code);
      --         DBMS_OUTPUT.put_line(   l_timeseries_data (i).date_time
      --                              || ' '
      --                              || l_timeseries_data (i).value
      --                              || ' '
      --                              || l_timeseries_data (i).quality_code);
      END LOOP;

      cwms_ts.store_ts (p_cwms_ts_id,
                        p_units,
                        l_timeseries_data,
                        p_store_rule,
                        p_override_prot,
                        p_version_date,
                        p_office_id);
   END zstore_ts;


   PROCEDURE zstore_ts_multi (
      p_timeseries_array   IN ztimeseries_array,
      p_store_rule         IN VARCHAR2,
      p_override_prot      IN VARCHAR2 DEFAULT 'F',
      p_version_date       IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id          IN VARCHAR2 DEFAULT NULL)
   IS
      l_timeseries     ztimeseries_type;
      l_err_msg        VARCHAR2 (722) := NULL;
      l_all_err_msgs   VARCHAR2 (2048) := NULL;
      l_len            NUMBER := 0;
      l_total_len      NUMBER := 0;
      l_num_ts_ids     NUMBER := 0;
      l_num_errors     NUMBER := 0;
      l_excep_errors   NUMBER := 0;
   BEGIN
      DBMS_APPLICATION_INFO.set_module ('cwms_ts.zstore_ts_multi',
                                        'selecting time series from input');

      FOR l_timeseries IN (SELECT * FROM TABLE (p_timeseries_array))
      LOOP
         DBMS_APPLICATION_INFO.set_module ('cwms_ts_store.zstore_ts_multi',
                                           'calling zstore_ts');

         BEGIN
            l_num_ts_ids := l_num_ts_ids + 1;

            cwms_ts.zstore_ts (l_timeseries.tsid,
                               l_timeseries.unit,
                               l_timeseries.data,
                               p_store_rule,
                               p_override_prot,
                               p_version_date,
                               p_office_id);
         EXCEPTION
            WHEN OTHERS
            THEN
               l_num_errors := l_num_errors + 1;

               l_err_msg :=
                     'STORE_ERROR ***'
                  || l_timeseries.tsid
                  || '*** '
                  || SQLCODE
                  || ': '
                  || SQLERRM;

               IF   NVL (LENGTH (l_all_err_msgs), 0)
                  + NVL (LENGTH (l_err_msg), 0) <= 1930
               THEN
                  l_excep_errors := l_excep_errors + 1;
                  l_all_err_msgs := l_all_err_msgs || ' ' || l_err_msg;
               END IF;
         END;
      END LOOP;

      IF l_all_err_msgs IS NOT NULL
      THEN
         l_all_err_msgs :=
               'STORE ERRORS: zstore_ts_multi processed '
            || l_num_ts_ids
            || ' ts_ids of which '
            || l_num_errors
            || ' had STORE ERRORS. '
            || l_excep_errors
            || ' of those errors are: '
            || l_all_err_msgs;

         raise_application_error (-20999, l_all_err_msgs);
      END IF;

      DBMS_APPLICATION_INFO.set_module (NULL, NULL);
   END zstore_ts_multi;

   PROCEDURE validate_ts_queue_name (p_queue_name IN VARCHAR)
   IS
      l_pattern   CONSTANT VARCHAR2 (39)
                              := '([a-z0-9_$]+\.)?([a-z0-9$]+_)?ts_stored' ;
      l_last               INTEGER := LENGTH (p_queue_name) + 1;
   BEGIN
      IF    REGEXP_INSTR (p_queue_name,
                          l_pattern,
                          1,
                          1,
                          0,
                          'i') != 1
         OR REGEXP_INSTR (p_queue_name,
                          l_pattern,
                          1,
                          1,
                          1,
                          'i') != l_last
      THEN
         cwms_err.raise ('INVALID_ITEM',
                         p_queue_name,
                         'queue name for (un)registister_ts_callback');
      END IF;
   END validate_ts_queue_name;

   FUNCTION register_ts_callback (
      p_procedure_name    IN VARCHAR2,
      p_subscriber_name   IN VARCHAR2 DEFAULT NULL,
      p_queue_name        IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_queue_name   VARCHAR2 (61) := NVL (p_queue_name, 'ts_stored');
   BEGIN
      validate_ts_queue_name (l_queue_name);
      RETURN cwms_msg.register_msg_callback (p_procedure_name,
                                             l_queue_name,
                                             p_subscriber_name);
   END register_ts_callback;

   PROCEDURE unregister_ts_callback (
      p_procedure_name    IN VARCHAR2,
      p_subscriber_name   IN VARCHAR2,
      p_queue_name        IN VARCHAR2 DEFAULT NULL)
   IS
      l_queue_name   VARCHAR2 (61) := NVL (p_queue_name, 'ts_stored');
   BEGIN
      validate_ts_queue_name (l_queue_name);
      cwms_msg.unregister_msg_callback (p_procedure_name,
                                        l_queue_name,
                                        p_subscriber_name);
   END unregister_ts_callback;

   PROCEDURE refresh_ts_catalog
   IS
   BEGIN
      -- Catalog is now refreshed during the  call to fetch the catalog
      -- cwms_util.refresh_mv_cwms_ts_id;
      NULL;
   END refresh_ts_catalog;

   -------------------------------
   -- Timeseries group routines --
   -------------------------------
   PROCEDURE store_ts_category (
      p_ts_category_id     IN VARCHAR2,
      p_ts_category_desc   IN VARCHAR2 DEFAULT NULL,
      p_fail_if_exists     IN VARCHAR2 DEFAULT 'F',
      p_ignore_null        IN VARCHAR2 DEFAULT 'T',
      p_db_office_id       IN VARCHAR2 DEFAULT NULL)
   IS
      l_code   NUMBER (10);
   BEGIN
      l_code :=
         store_ts_category_f (p_ts_category_id,
                              p_ts_category_desc,
                              p_fail_if_exists,
                              p_ignore_null,
                              p_db_office_id);
   END store_ts_category;

   FUNCTION store_ts_category_f (
      p_ts_category_id     IN VARCHAR2,
      p_ts_category_desc   IN VARCHAR2 DEFAULT NULL,
      p_fail_if_exists     IN VARCHAR2 DEFAULT 'F',
      p_ignore_null        IN VARCHAR2 DEFAULT 'T',
      p_db_office_id       IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER
   IS
      l_office_code      NUMBER;
      l_ignore_null      BOOLEAN;
      l_fail_if_exists   BOOLEAN;
      l_exists           BOOLEAN;
      l_rec              at_ts_category%ROWTYPE;
   BEGIN
      --------------------
      -- santity checks --
      --------------------
      l_fail_if_exists := cwms_util.is_true (p_fail_if_exists);
      l_ignore_null := cwms_util.is_true (p_ignore_null);
      l_office_code := cwms_util.get_db_office_code (p_db_office_id);
      ----------------------------------
      -- determine if category exists --
      ----------------------------------
      l_rec.ts_category_id := UPPER (cwms_util.strip(p_ts_category_id));

      BEGIN
         SELECT *
           INTO l_rec
           FROM at_ts_category
          WHERE     db_office_code IN
                       (l_office_code, cwms_util.db_office_code_all)
                AND UPPER (ts_category_id) = l_rec.ts_category_id;

         l_exists := TRUE;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            l_exists := FALSE;
      END;

      ----------------------------------------
      -- raise exceptions on invalid states --
      ----------------------------------------
      IF l_exists
      THEN
         IF l_fail_if_exists
         THEN
            cwms_err.raise ('ITEM_ALREADY_EXISTS',
                            'Time series category',
                            cwms_util.strip(p_ts_category_id));
         ELSE
            IF     l_rec.db_office_code = cwms_util.db_office_code_all
               AND l_office_code != cwms_util.db_office_code_all
            THEN
               cwms_err.raise (
                  'ERROR',
                     'CWMS time series category '
                  || p_ts_category_id
                  || ' can only be updated by owner.');
            END IF;
         END IF;
      END IF;

      -----------------------------------
      -- insert or update the category --
      -----------------------------------
      l_rec.ts_category_id := cwms_util.strip(p_ts_category_id);
      IF NOT l_exists OR p_ts_category_desc IS NOT NULL OR NOT l_ignore_null
      THEN
         l_rec.ts_category_desc := cwms_util.strip(p_ts_category_desc);
      END IF;

      IF l_exists
      THEN
         UPDATE at_ts_category
            SET row = l_rec
          WHERE ts_category_code = l_rec.ts_category_code;
      ELSE
         l_rec.ts_category_code := cwms_seq.NEXTVAL;
         l_rec.db_office_code := l_office_code;

         INSERT INTO at_ts_category
              VALUES l_rec;
      END IF;

      RETURN l_rec.ts_category_code;
   END store_ts_category_f;

   PROCEDURE rename_ts_category (
      p_ts_category_id_old   IN VARCHAR2,
      p_ts_category_id_new   IN VARCHAR2,
      p_db_office_id         IN VARCHAR2 DEFAULT NULL)
   IS
      l_office_code    NUMBER;
      l_category_rec   at_ts_category%ROWTYPE;
   BEGIN
      l_office_code := cwms_util.get_db_office_code (p_db_office_id);

      --------------------------------------
      -- determine if old category exists --
      --------------------------------------
      BEGIN
         SELECT *
           INTO l_category_rec
           FROM at_ts_category
          WHERE     db_office_code IN
                       (l_office_code, cwms_util.db_office_code_all)
                AND UPPER (ts_category_id) = UPPER (p_ts_category_id_old);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise ('ITEM_DOES_NOT_EXIST',
                            'Time series location category',
                            p_ts_category_id_old);
      END;

      --------------------------------------
      -- determine if new category exists --
      --------------------------------------
      BEGIN
         SELECT *
           INTO l_category_rec
           FROM at_ts_category
          WHERE     db_office_code IN
                       (l_office_code, cwms_util.db_office_code_all)
                AND UPPER (ts_category_id) = UPPER (cwms_util.strip(p_ts_category_id_new));

         cwms_err.raise ('ITEM_ALREADY_EXISTS',
                         'Time series location category',
                         cwms_util.strip(p_ts_category_id_new));
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
      END;

      ----------------------------------------
      -- raise exceptions on invalid states --
      ----------------------------------------
      IF     l_category_rec.db_office_code = cwms_util.db_office_code_all
         AND l_office_code != cwms_util.db_office_code_all
      THEN
         cwms_err.raise (
            'ERROR',
               'CWMS time series category '
            || p_ts_category_id_old
            || ' can only be renamed by owner.');
      END IF;

      -------------------------
      -- rename the category --
      -------------------------
      UPDATE at_ts_category
         SET ts_category_id = cwms_util.strip(p_ts_category_id_new)
       WHERE ts_category_code = l_category_rec.ts_category_code;
   END rename_ts_category;

   PROCEDURE delete_ts_category (p_ts_category_id   IN VARCHAR2,
                                 p_cascade          IN VARCHAR2 DEFAULT 'F',
                                 p_db_office_id     IN VARCHAR2 DEFAULT NULL)
   IS
      l_office_code    NUMBER;
      l_cascade        BOOLEAN;
      l_category_rec   at_ts_category%ROWTYPE;
   BEGIN
      --------------------
      -- santity checks --
      --------------------
      l_cascade := cwms_util.is_true (p_cascade);
      l_office_code := cwms_util.get_db_office_code (p_db_office_id);

      ----------------------------------
      -- determine if category exists --
      ----------------------------------
      BEGIN
         SELECT *
           INTO l_category_rec
           FROM at_ts_category
          WHERE     db_office_code IN
                       (l_office_code, cwms_util.db_office_code_all)
                AND UPPER (ts_category_id) = UPPER (p_ts_category_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise ('ITEM_DOES_NOT_EXIST',
                            'Time series location category',
                            p_ts_category_id);
      END;

      ----------------------------------------
      -- raise exceptions on invalid states --
      ----------------------------------------
      IF     l_category_rec.db_office_code = cwms_util.db_office_code_all
         AND l_office_code != cwms_util.db_office_code_all
      THEN
         cwms_err.raise (
            'ERROR',
               'CWMS time series category '
            || p_ts_category_id
            || ' can only be deleted by owner');
      END IF;

      -----------------
      -- do the work --
      -----------------
      IF l_cascade
      THEN
         ----------------------------------------------------------------------------
         -- delete any groups in the category (will fail if there are assignments) --
         ----------------------------------------------------------------------------
         FOR group_rec
            IN (SELECT ts_group_code
                  FROM at_ts_group
                 WHERE ts_category_code = l_category_rec.ts_category_code)
         LOOP
            FOR assign_rec
               IN (SELECT ts_code
                     FROM at_ts_group_assignment
                    WHERE ts_group_code = group_rec.ts_group_code)
            LOOP
               cwms_err.raise (
                  'ERROR',
                     'Cannot delete time series category '
                  || p_ts_category_id
                  || ' because at least one of its groups is not empty.');
            END LOOP;

            ----------------------
            -- delete the group --
            ----------------------
            DELETE FROM at_ts_group
                  WHERE ts_group_code = group_rec.ts_group_code;
         END LOOP;
      ELSE
         ------------------------------
         -- test for existing groups --
         ------------------------------
         FOR group_rec
            IN (SELECT ts_group_code
                  FROM at_ts_group
                 WHERE ts_category_code = l_category_rec.ts_category_code)
         LOOP
            cwms_err.raise (
               'ERROR',
                  'Cannot delete time series category '
               || p_ts_category_id
               || ' because it is not empty.');
         END LOOP;
      END IF;

      -------------------------
      -- delete the category --
      -------------------------
      DELETE FROM at_ts_category
            WHERE ts_category_code = l_category_rec.ts_category_code;
   END delete_ts_category;

   PROCEDURE store_ts_group (p_ts_category_id     IN VARCHAR2,
                             p_ts_group_id        IN VARCHAR2,
                             p_ts_group_desc      IN VARCHAR2 DEFAULT NULL,
                             p_fail_if_exists     IN VARCHAR2 DEFAULT 'F',
                             p_ignore_nulls       IN VARCHAR2 DEFAULT 'T',
                             p_shared_alias_id    IN VARCHAR2 DEFAULT NULL,
                             p_shared_ts_ref_id   IN VARCHAR2 DEFAULT NULL,
                             p_db_office_id       IN VARCHAR2 DEFAULT NULL)
   IS
      l_code   NUMBER (10);
   BEGIN
      l_code :=
         store_ts_group_f (p_ts_category_id,
                           p_ts_group_id,
                           p_ts_group_desc,
                           p_fail_if_exists,
                           p_ignore_nulls,
                           p_shared_alias_id,
                           p_shared_ts_ref_id,
                           p_db_office_id);
   END store_ts_group;

   FUNCTION store_ts_group_f (p_ts_category_id     IN VARCHAR2,
                              p_ts_group_id        IN VARCHAR2,
                              p_ts_group_desc      IN VARCHAR2 DEFAULT NULL,
                              p_fail_if_exists     IN VARCHAR2 DEFAULT 'F',
                              p_ignore_nulls       IN VARCHAR2 DEFAULT 'T',
                              p_shared_alias_id    IN VARCHAR2 DEFAULT NULL,
                              p_shared_ts_ref_id   IN VARCHAR2 DEFAULT NULL,
                              p_db_office_id       IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER
   IS
      l_office_code      NUMBER (10);
      l_fail_if_exists   BOOLEAN;
      l_exists           BOOLEAN;
      l_ignore_nulls     BOOLEAN;
      l_rec              at_ts_group%ROWTYPE;
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      l_fail_if_exists := cwms_util.is_true (p_fail_if_exists);
      l_ignore_nulls := cwms_util.is_true (p_ignore_nulls);
      l_office_code := cwms_util.get_db_office_code (p_db_office_id);
      --------------------------------------------------
      -- get the category code, creating if necessary --
      --------------------------------------------------
      l_rec.ts_category_code :=
         cwms_ts.store_ts_category_f (p_ts_category_id     => p_ts_category_id,
                                      p_ts_category_desc   => NULL,
                                      p_fail_if_exists     => 'F',
                                      p_ignore_null        => 'T',
                                      p_db_office_id       => p_db_office_id);
      -----------------------------------
      -- determine if the group exists --
      -----------------------------------
      l_rec.ts_group_id := cwms_util.strip(p_ts_group_id);

      BEGIN
         SELECT *
           INTO l_rec
           FROM at_ts_group
          WHERE     UPPER (ts_group_id) = UPPER (l_rec.ts_group_id)
                AND ts_category_code = l_rec.ts_category_code
                AND db_office_code IN
                       (l_office_code, cwms_util.db_office_code_all);

         l_exists := TRUE;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            l_exists := FALSE;
      END;

      ----------------------------------------
      -- raise exceptions on invalid states --
      ----------------------------------------
      IF l_exists
      THEN
         IF l_fail_if_exists
         THEN
            cwms_err.raise ('ITEM_ALREADY_EXISTS',
                            'Time series group',
                            cwms_util.strip(p_ts_category_id) || '/' || cwms_util.strip(p_ts_group_id));
         ELSE
            IF     l_rec.db_office_code = cwms_util.db_office_code_all
               AND l_office_code != cwms_util.db_office_code_all
            THEN
               cwms_err.raise (
                  'ERROR',
                     'CWMS time series group '
                  || cwms_util.strip(p_ts_category_id)
                  || '/'
                  || cwms_util.strip(p_ts_group_id)
                  || ' can only be updated by owner.');
            END IF;
         END IF;
      END IF;

      ------------------------
      -- prepare the record --
      ------------------------
      l_rec.db_office_code := l_office_code;

      IF NOT l_exists OR p_ts_group_desc IS NOT NULL OR NOT l_ignore_nulls
      THEN
         l_rec.ts_group_desc := cwms_util.strip(p_ts_group_desc);
      END IF;

      IF NOT l_exists OR p_shared_alias_id IS NOT NULL OR NOT l_ignore_nulls
      THEN
         l_rec.shared_ts_alias_id := p_shared_alias_id;
      END IF;

      IF NOT l_exists OR p_shared_ts_ref_id IS NOT NULL OR NOT l_ignore_nulls
      THEN
         IF p_shared_ts_ref_id IS NOT NULL
         THEN
            l_rec.shared_ts_ref_code :=
               cwms_ts.get_ts_code (p_shared_ts_ref_id, l_office_code);
         END IF;
      END IF;

      ---------------------------------
      -- update or insert the record --
      ---------------------------------
      IF l_exists
      THEN
         UPDATE at_ts_group
            SET row = l_rec
          WHERE ts_group_code = l_rec.ts_group_code;
      ELSE
         l_rec.ts_group_code := cwms_seq.NEXTVAL;

         INSERT INTO at_ts_group
              VALUES l_rec;
      END IF;

      RETURN l_rec.ts_group_code;
   END store_ts_group_f;

   PROCEDURE rename_ts_group (p_ts_category_id    IN VARCHAR2,
                              p_ts_group_id_old   IN VARCHAR2,
                              p_ts_group_id_new   IN VARCHAR2,
                              p_db_office_id      IN VARCHAR2 DEFAULT NULL)
   IS
      l_office_code   NUMBER (10);
      l_rec           at_ts_group%ROWTYPE;
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      l_office_code := cwms_util.get_db_office_code (p_db_office_id);

      -----------------------------------
      -- determine if the group exists --
      -----------------------------------
      BEGIN
         SELECT g.ts_group_code,
                g.ts_category_code,
                g.ts_group_id,
                g.ts_group_desc,
                g.db_office_code,
                g.shared_ts_alias_id,
                g.shared_ts_ref_code
           INTO l_rec
           FROM at_ts_category c, at_ts_group g
          WHERE     UPPER (c.ts_category_id) = UPPER (p_ts_category_id)
                AND UPPER (g.ts_group_id) = UPPER (p_ts_group_id_old)
                AND g.ts_category_code = c.ts_category_code
                AND g.db_office_code IN
                       (l_office_code, cwms_util.db_office_code_all);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise ('ITEM_DOES_NOT_EXIST',
                            'Time series group',
                            p_ts_category_id || '/' || p_ts_group_id_old);
      END;

      ----------------------------------------
      -- raise exceptions on invalid states --
      ----------------------------------------
      IF     l_rec.db_office_code = cwms_util.db_office_code_all
         AND l_office_code != cwms_util.db_office_code_all
      THEN
         cwms_err.raise (
            'ERROR',
               'CWMS time series group '
            || p_ts_category_id
            || '/'
            || p_ts_group_id_old
            || ' can only be renamed by owner.');
      END IF;

      ----------------------
      -- rename the group --
      ----------------------
      UPDATE at_ts_group
         SET ts_group_id = cwms_util.strip(p_ts_group_id_new)
       WHERE ts_group_code = l_rec.ts_group_code;
   END rename_ts_group;

   PROCEDURE delete_ts_group (p_ts_category_id   IN VARCHAR2,
                              p_ts_group_id      IN VARCHAR2,
                              p_db_office_id     IN VARCHAR2 DEFAULT NULL)
   IS
      l_office_code   NUMBER (10);
      l_rec           at_ts_group%ROWTYPE;
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      l_office_code := cwms_util.get_db_office_code (p_db_office_id);

      -----------------------------------
      -- determine if the group exists --
      -----------------------------------
      BEGIN
         SELECT g.ts_group_code,
                g.ts_category_code,
                g.ts_group_id,
                g.ts_group_desc,
                g.db_office_code,
                g.shared_ts_alias_id,
                g.shared_ts_ref_code
           INTO l_rec
           FROM at_ts_category c, at_ts_group g
          WHERE     UPPER (c.ts_category_id) = UPPER (p_ts_category_id)
                AND UPPER (g.ts_group_id) = UPPER (p_ts_group_id)
                AND g.ts_category_code = c.ts_category_code
                AND g.db_office_code IN
                       (l_office_code, cwms_util.db_office_code_all);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise ('ITEM_DOES_NOT_EXIST',
                            'Time series group',
                            p_ts_category_id || '/' || p_ts_group_id);
      END;

      ----------------------------------------
      -- raise exceptions on invalid states --
      ----------------------------------------
      IF     l_rec.db_office_code = cwms_util.db_office_code_all
         AND l_office_code != cwms_util.db_office_code_all
      THEN
         cwms_err.raise (
            'ERROR',
               'CWMS time series group '
            || p_ts_category_id
            || '/'
            || p_ts_group_id
            || ' can only be deleted by owner.');
      END IF;

      FOR rec IN (SELECT ts_code
                    FROM at_ts_group_assignment
                   WHERE ts_group_code = l_rec.ts_group_code)
      LOOP
         cwms_err.raise (
            'ERROR',
               'Cannot delete time series group '
            || p_ts_category_id
            || '/'
            || p_ts_group_id
            || ' because it is not empty.');
      END LOOP;

      ----------------------
      -- delete the group --
      ----------------------
      DELETE FROM at_ts_group
            WHERE ts_group_code = l_rec.ts_group_code;
   END delete_ts_group;

   procedure assign_ts_group (
      p_ts_category_id   in varchar2,
      p_ts_group_id      in varchar2,
      p_ts_id            in varchar2,
      p_ts_attribute     in number default null,
      p_ts_alias_id      in varchar2 default null,
      p_ref_ts_id        in varchar2 default null,
      p_db_office_id     in varchar2 default null)
   is
      l_office_code     number(10);
      l_ts_group_code   number(10);
      l_ts_code         number(10);
      l_ts_ref_code     number(10);
      l_rec             at_ts_group_assignment%rowtype;
      l_exists          boolean;
   begin
      -------------------
      -- sanity checks --
      -------------------
      l_office_code := cwms_util.get_db_office_code(p_db_office_id);

      ------------------------
      -- get the group code --
      ------------------------
      begin
         select ts_group_code
           into l_ts_group_code
           from at_ts_category c, at_ts_group g
          where upper(c.ts_category_id) = upper(p_ts_category_id)
            and upper(g.ts_group_id) = upper(p_ts_group_id)
            and g.ts_category_code = c.ts_category_code
            and g.db_office_code in (l_office_code, cwms_util.db_office_code_all);
      exception
         when no_data_found
         then
            cwms_err.raise(
               'ITEM_DOES_NOT_EXIST',
               'Time series group',
               p_ts_category_id || '/' || p_ts_group_id);
      end;

      -----------------------------------------------
      -- determine if an assignment already exists --
      -----------------------------------------------
      l_ts_code := get_ts_code(p_ts_id, l_office_code);

      if p_ref_ts_id is not null then
         l_ts_ref_code := get_ts_code(p_ref_ts_id, l_office_code);
      end if;

      begin
         select *
           into l_rec
           from at_ts_group_assignment
          where ts_code = l_ts_code and ts_group_code = l_ts_group_code;

         l_exists := true;
      exception
         when no_data_found then
            l_exists := false;
      end;

      ------------------------
      -- prepare the record --
      ------------------------
      l_rec.ts_attribute := nvl(p_ts_attribute, l_rec.ts_attribute);
      l_rec.ts_alias_id  := nvl(p_ts_alias_id, l_rec.ts_alias_id);
      l_rec.ts_ref_code  := nvl(l_ts_ref_code, l_rec.ts_ref_code);
      l_rec.office_code  := l_office_code;

      ---------------------------------
      -- insert or update the record --
      ---------------------------------
      if l_exists then
         update at_ts_group_assignment
            set row = l_rec
          where ts_code = l_rec.ts_code
            and ts_group_code = l_rec.ts_group_code;
      else
         l_rec.ts_code := l_ts_code;
         l_rec.ts_group_code := l_ts_group_code;

         insert into at_ts_group_assignment
              values l_rec;
      end if;
   end assign_ts_group;

   PROCEDURE unassign_ts_group (p_ts_category_id   IN VARCHAR2,
                                p_ts_group_id      IN VARCHAR2,
                                p_ts_id            IN VARCHAR2,
                                p_unassign_all     IN VARCHAR2 DEFAULT 'F',
                                p_db_office_id     IN VARCHAR2 DEFAULT NULL)
   IS
      l_office_code     NUMBER (10);
      l_ts_group_code   NUMBER (10);
      l_ts_code         NUMBER (10);
      l_exists          BOOLEAN;
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      l_office_code := cwms_util.get_db_office_code (p_db_office_id);

      ------------------------
      -- get the group code --
      ------------------------
      BEGIN
         SELECT ts_group_code
           INTO l_ts_group_code
           FROM at_ts_category c, at_ts_group g
          WHERE     UPPER (c.ts_category_id) = UPPER (p_ts_category_id)
                AND UPPER (g.ts_group_id) = UPPER (p_ts_group_id)
                AND g.ts_category_code = c.ts_category_code
                AND g.db_office_code IN
                       (l_office_code, cwms_util.db_office_code_all);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise ('ITEM_DOES_NOT_EXIST',
                            'Time series group',
                            p_ts_category_id || '/' || p_ts_group_id);
      END;

      ------------------------------
      -- delete the assignment(s) --
      ------------------------------
      IF cwms_util.is_true (p_unassign_all)
      THEN
         DELETE FROM at_ts_group_assignment
               WHERE ts_group_code = l_ts_group_code
                 AND get_db_office_code(ts_code) = l_office_code;
      ELSE                               
         l_ts_code := get_ts_code (p_ts_id, l_office_code);
         DELETE FROM at_ts_group_assignment
               WHERE ts_group_code = l_ts_group_code 
                 AND ts_code = l_ts_code;
      END IF;
   END unassign_ts_group;

   PROCEDURE assign_ts_groups (p_ts_category_id   IN VARCHAR2,
                               p_ts_group_id      IN VARCHAR2,
                               p_ts_alias_array   IN ts_alias_tab_t,
                               p_db_office_id     IN VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      IF p_ts_alias_array IS NOT NULL
      THEN
         FOR i IN 1 .. p_ts_alias_array.COUNT
         LOOP
            cwms_ts.assign_ts_group (p_ts_category_id,
                                     p_ts_group_id,
                                     p_ts_alias_array (i).ts_id,
                                     p_ts_alias_array (i).ts_attribute,
                                     p_ts_alias_array (i).ts_alias_id,
                                     p_ts_alias_array (i).ts_ref_id,
                                     p_db_office_id);
         END LOOP;
      END IF;
   END assign_ts_groups;

   PROCEDURE unassign_ts_groups (p_ts_category_id   IN VARCHAR2,
                                 p_ts_group_id      IN VARCHAR2,
                                 p_ts_array         IN str_tab_t,
                                 p_unassign_all     IN VARCHAR2 DEFAULT 'F',
                                 p_db_office_id     IN VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      IF p_ts_array IS NULL
      THEN
         cwms_ts.unassign_ts_group (p_ts_category_id,
                                    p_ts_group_id,
                                    NULL,
                                    p_unassign_all,
                                    p_db_office_id);
      ELSE
         FOR i IN 1 .. p_ts_array.COUNT
         LOOP
            cwms_ts.unassign_ts_group (p_ts_category_id,
                                       p_ts_group_id,
                                       p_ts_array (i),
                                       p_unassign_all,
                                       p_db_office_id);
         END LOOP;
      END IF;
   END unassign_ts_groups;

   function get_ts_id_from_alias (
      p_alias_id      in varchar2,
      p_group_id      in varchar2 default null,
      p_category_id   in varchar2 default null,
      p_office_id     in varchar2 default null)
      return varchar2
   is
      l_office_code number(10);
      l_ts_code     number(10);
      l_ts_id       varchar2(183); 
      l_parts       str_tab_t;
      l_location_id varchar2(49);
   begin
      -------------------
      -- sanity checks --
      -------------------
      l_office_code := cwms_util.get_db_office_code(p_office_id);

      -----------------------------------
      -- retrieve and return the ts id --
      -----------------------------------
      begin
         select distinct ts_code
           into l_ts_code
           from at_ts_group_assignment a, 
                at_ts_group g, 
                at_ts_category c
          where a.office_code = l_office_code
            and upper(c.ts_category_id) = upper(nvl(p_category_id, c.ts_category_id))
            and upper(g.ts_group_id) = upper(nvl(p_group_id, g.ts_group_id))
            and upper(a.ts_alias_id) = upper(p_alias_id)
            and g.ts_category_code = c.ts_category_code
            and a.ts_group_code = g.ts_group_code;
      exception
         when no_data_found then
            ------------------------------------
            -- see if the location is aliased --
            ------------------------------------
            l_parts := cwms_util.split_text(p_alias_id, '.');
            if l_parts.count = 6 then
               l_location_id := cwms_loc.get_location_id(l_parts(1), p_office_id);
               if l_location_id is not null and l_location_id != l_parts(1) then
                  l_parts(1) := l_location_id;
                  l_ts_id := cwms_util.join_text(l_parts, '.');
                  l_ts_code := cwms_ts.get_ts_code(l_ts_id, p_office_id);
                  if l_ts_code is null then
                     l_ts_id := null;
                  end if;
               end if;
            end if;
         when too_many_rows
         then
            cwms_err.raise (
               'ERROR',
               'Alias ('
               || p_alias_id
               || ') matches more than one time series.');
      end;

      if l_ts_code is not null and l_ts_id is null then
         l_ts_id := get_ts_id (l_ts_code);
      end if;

      return l_ts_id;
   END get_ts_id_from_alias;


   FUNCTION get_ts_code_from_alias (p_alias_id      IN VARCHAR2,
                                    p_group_id      IN VARCHAR2 DEFAULT NULL,
                                    p_category_id   IN VARCHAR2 DEFAULT NULL,
                                    p_office_id     IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER
   IS
   BEGIN
      RETURN get_ts_code (get_ts_id_from_alias (p_alias_id,
                                                p_group_id,
                                                p_category_id,
                                                p_office_id),
                          p_office_id);
   END get_ts_code_from_alias;

   FUNCTION get_ts_id (p_ts_id_or_alias IN VARCHAR2, p_office_id IN VARCHAR2)
      RETURN VARCHAR2
   IS
      ts_id_not_found   EXCEPTION;
      PRAGMA EXCEPTION_INIT (ts_id_not_found, -20001);
      l_ts_code         NUMBER (10);
      l_ts_id           VARCHAR2 (183);
   BEGIN
      BEGIN
         l_ts_code := get_ts_code (p_ts_id_or_alias, p_office_id);
      EXCEPTION
         WHEN ts_id_not_found
         THEN
            NULL;
      END;

      IF l_ts_code IS NOT NULL
      THEN
         l_ts_id := get_ts_id (l_ts_code);
      END IF;

      RETURN l_ts_id;
   END get_ts_id;

   FUNCTION get_ts_id (p_ts_id_or_alias IN VARCHAR2, p_office_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_office_id   VARCHAR2 (16);
   BEGIN
      SELECT office_id
        INTO l_office_id
        FROM cwms_office
       WHERE office_code = p_office_code;

      RETURN get_ts_id (p_ts_id_or_alias, l_office_id);
   END get_ts_id;

   ---------------------------
   -- Data quality routines --
   ---------------------------
   FUNCTION get_quality_validity (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      result_cache
   IS
      l_validity   VARCHAR2 (16);
   BEGIN
      SELECT validity_id
        INTO l_validity
        FROM cwms_data_quality
       WHERE quality_code = p_quality_code + case 
                                                when p_quality_code < 0 then 4294967296
                                                else  0 
                                             end;
      RETURN l_validity;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise('INVALID_ITEM', p_quality_code, 'CWMS quality value');
   END get_quality_validity;

   FUNCTION get_quality_validity (p_value IN tsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN get_quality_validity (p_value.quality_code);
   END get_quality_validity;

   FUNCTION get_quality_validity (p_value IN ztsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN get_quality_validity (p_value.quality_code);
   END get_quality_validity;

   FUNCTION quality_is_okay (p_quality_code IN NUMBER)
      RETURN BOOLEAN
      result_cache
   IS
   BEGIN
      RETURN get_quality_validity (p_quality_code) = 'OKAY';
   END quality_is_okay;

   FUNCTION quality_is_okay (p_value IN tsv_type)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN quality_is_okay (p_value.quality_code);
   END quality_is_okay;

   FUNCTION quality_is_okay (p_value IN ztsv_type)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN quality_is_okay (p_value.quality_code);
   END quality_is_okay;

   FUNCTION quality_is_okay_text (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      result_cache
   IS
   BEGIN
      RETURN CASE get_quality_validity (p_quality_code) = 'OKAY'
                WHEN TRUE  THEN 'T'
                WHEN FALSE THEN 'F'
             END;
   END quality_is_okay_text;

   FUNCTION quality_is_okay_text (p_value IN tsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN quality_is_okay_text (p_value.quality_code);
   END quality_is_okay_text;

   FUNCTION quality_is_okay_text (p_value IN ztsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN quality_is_okay_text (p_value.quality_code);
   END quality_is_okay_text;

   FUNCTION quality_is_missing (p_quality_code IN NUMBER)
      RETURN BOOLEAN
      result_cache
   IS
   BEGIN
      RETURN get_quality_validity (p_quality_code) = 'MISSING';
   END quality_is_missing;

   FUNCTION quality_is_missing (p_value IN tsv_type)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN quality_is_missing (p_value.quality_code);
   END quality_is_missing;

   FUNCTION quality_is_missing (p_value IN ztsv_type)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN quality_is_missing (p_value.quality_code);
   END quality_is_missing;

   FUNCTION quality_is_missing_text (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      result_cache
   IS
   BEGIN
      RETURN CASE get_quality_validity (p_quality_code) = 'MISSING'
                WHEN TRUE  THEN 'T'
                WHEN FALSE THEN 'F'
             END;

   END quality_is_missing_text;

   FUNCTION quality_is_missing_text (p_value IN tsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN quality_is_missing_text (p_value.quality_code);
   END quality_is_missing_text;

   FUNCTION quality_is_missing_text (p_value IN ztsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN quality_is_missing_text (p_value.quality_code);
   END quality_is_missing_text;

   FUNCTION quality_is_questionable (p_quality_code IN NUMBER)
      RETURN BOOLEAN
      result_cache
   IS
   BEGIN
      RETURN get_quality_validity (p_quality_code) = 'QUESTIONABLE';
   END quality_is_questionable;

   FUNCTION quality_is_questionable (p_value IN tsv_type)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN quality_is_questionable (p_value.quality_code);
   END quality_is_questionable;

   FUNCTION quality_is_questionable (p_value IN ztsv_type)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN quality_is_okay (p_value.quality_code);
   END quality_is_questionable;

   FUNCTION quality_is_questionable_text (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      result_cache
   IS
   BEGIN
      RETURN CASE get_quality_validity (p_quality_code) = 'QUESTIONABLE'
                WHEN TRUE  THEN 'T'
                WHEN FALSE THEN 'F'
             END;
   END quality_is_questionable_text;

   FUNCTION quality_is_questionable_text (p_value IN tsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN quality_is_questionable_text (p_value.quality_code);
   END quality_is_questionable_text;

   FUNCTION quality_is_questionable_text (p_value IN ztsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN quality_is_questionable_text (p_value.quality_code);
   END quality_is_questionable_text;

   FUNCTION quality_is_rejected (p_quality_code IN NUMBER)
      RETURN BOOLEAN
      result_cache
   IS
   BEGIN
      RETURN get_quality_validity (p_quality_code) = 'REJECTED';
   END quality_is_rejected;

   FUNCTION quality_is_rejected (p_value IN tsv_type)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN quality_is_rejected (p_value.quality_code);
   END quality_is_rejected;

   FUNCTION quality_is_rejected (p_value IN ztsv_type)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN quality_is_rejected (p_value.quality_code);
   END quality_is_rejected;

   FUNCTION quality_is_rejected_text (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      result_cache
   IS
   BEGIN
      RETURN CASE get_quality_validity (p_quality_code) = 'REJECTED'
                WHEN TRUE  THEN 'T'
                WHEN FALSE THEN 'F'
             END;
   END quality_is_rejected_text;

   FUNCTION quality_is_rejected_text (p_value IN tsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN quality_is_rejected_text (p_value.quality_code);
   END quality_is_rejected_text;

   FUNCTION quality_is_rejected_text (p_value IN ztsv_type)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN quality_is_rejected_text (p_value.quality_code);
   END quality_is_rejected_text;

   FUNCTION get_quality_description (p_quality_code IN NUMBER)
      RETURN VARCHAR2
      result_cache
   IS
      l_description   VARCHAR2 (4000);
      l_rec           cwms_data_quality%ROWTYPE;
   BEGIN
      SELECT *
        INTO l_rec
        FROM cwms_data_quality
       WHERE quality_code = p_quality_code + case 
                                                when p_quality_code < 0 then 4294967296
                                                else  0 
                                             end;

      IF l_rec.screened_id = 'UNSCREENED'
      THEN
         l_description := l_rec.screened_id;
      ELSE
         l_description :=
            l_rec.screened_id || ', validity=' || l_rec.validity_id;

         IF l_rec.range_id != 'NO_RANGE'
         THEN
            l_description := l_description || ', range=' || l_rec.range_id;
         END IF;

         IF l_rec.changed_id != 'ORIGINAL'
         THEN
            l_description :=
                  l_description
               || ', '
               || l_rec.changed_id
               || ' (cause='
               || l_rec.repl_cause_id
               || ', method='
               || l_rec.repl_method_id
               || ')';
         END IF;

         IF l_rec.test_failed_id != 'NONE'
         THEN
            l_description :=
               l_description || ', failed=' || l_rec.test_failed_id;
         END IF;

         IF l_rec.protection_id != 'UNPROTECTED'
         THEN
            l_description := l_description || ', ' || l_rec.protection_id;
         END IF;
      END IF;

      l_description := INITCAP (l_description);
      RETURN l_description;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise('INVALID_ITEM', p_quality_code, 'CWMS quality value');
   END get_quality_description;

   FUNCTION get_ts_interval (p_ts_code IN NUMBER)
      RETURN NUMBER result_cache
   IS
      l_interval NUMBER;
   BEGIN
      select interval
        into l_interval
        from cwms_v_ts_id
       where ts_code = p_ts_code;

      return l_interval;
   END get_ts_interval;

   FUNCTION get_ts_interval (p_cwms_ts_id IN VARCHAR2)
      RETURN NUMBER result_cache
   IS
   BEGIN
      RETURN get_interval(get_ts_interval_string(p_cwms_ts_id));
   END get_ts_interval;

   FUNCTION get_ts_interval_string (p_cwms_ts_id IN VARCHAR2)
      RETURN VARCHAR2 result_cache
   IS
   BEGIN
      return regexp_substr (p_cwms_ts_id, '[^.]+', 1, 4);
   END get_ts_interval_string;

   FUNCTION get_interval (p_interval_id IN VARCHAR2)
      RETURN NUMBER result_cache
   IS
      l_interval NUMBER;
   BEGIN
      SELECT interval
        INTO l_interval
        FROM cwms_interval
       WHERE UPPER(interval_id) = UPPER(p_interval_id);

      RETURN l_interval;
   END get_interval;

   FUNCTION get_utc_interval_offset (
      p_date_time_utc    IN DATE,
      p_interval_minutes IN NUMBER)
      RETURN NUMBER result_cache
   IS
   BEGIN
      return round((p_date_time_utc - get_time_on_before_interval(p_date_time_utc, 0, p_interval_minutes)) * 1440);
   END get_utc_interval_offset;

   FUNCTION get_times_for_time_window (
      p_start_time                  IN DATE,
      p_end_time                    IN DATE,
      p_interval_minutes            IN INTEGER,
      p_utc_interval_offset_minutes IN INTEGER,
      p_time_zone                   IN VARCHAR2 DEFAULT 'UTC')
      RETURN date_table_type
   IS
      c_one_month_interval constant integer := 43200;
      c_one_year_interval  constant integer := 525600;
      l_start_time_utc   date;
      l_end_time_utc     date;
      l_months           integer;
      l_valid_interval   boolean := false;
      l_date_times       date_table_type;
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      if p_start_time is null then cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME'); end if;
      if p_end_time is null then cwms_err.raise('NULL_ARGUMENT', 'P_END_TIME'); end if;
      if p_interval_minutes is null then cwms_err.raise('NULL_ARGUMENT', 'P_INTERVAL_MINUTES'); end if;
      if p_utc_interval_offset_minutes is null then cwms_err.raise('NULL_ARGUMENT', 'P_UTC_INTERVAL_OFFSET_MINUTES'); end if;
      if p_start_time > p_end_time then cwms_err.raise('ERROR', 'End time is greater than start time'); end if;
      for rec in (select distinct interval from cwms_interval) loop
         if p_interval_minutes = rec.interval then
            l_valid_interval := true;
            exit;
         end if;
      end loop;
      if not l_valid_interval then
         cwms_err.raise('INVALID_ITEM', p_interval_minutes, 'CWMS interval minutes');
      end if;
      ----------------------------------------------------------------------
      -- get first and last times that are in time window and on interval --
      ----------------------------------------------------------------------
      l_start_time_utc := get_time_on_after_interval(
         cwms_util.change_timezone(p_start_time, p_time_zone, 'UTC'),
         p_utc_interval_offset_minutes,
         p_interval_minutes);
      l_end_time_utc := get_time_on_before_interval(
         cwms_util.change_timezone(p_end_time, p_time_zone, 'UTC'),
         p_utc_interval_offset_minutes,
         p_interval_minutes);
      if l_start_time_utc > l_end_time_utc then cwms_err.raise('ERROR', 'Time window contains no times on interval.'); end if;
      -------------------
      -- get the times --
      -------------------
      if p_interval_minutes >= c_one_month_interval then
         -----------------------
         -- calendar interval --
         -----------------------
         l_months := case mod(p_interval_minutes, c_one_month_interval) = 0
                        when true  then p_interval_minutes / c_one_month_interval
                        when false then p_interval_minutes / c_one_year_interval * 12
                     end;
         select add_months(l_start_time_utc, (level - 1) * l_months)
           bulk collect into l_date_times
           from dual
        connect by level <= months_between(l_end_time_utc, l_start_time_utc) / l_months + 1;
      else
         -------------------
         -- time interval --
         -------------------
         select l_start_time_utc + (level - 1) * p_interval_minutes / 1440
           bulk collect into l_date_times
           from dual
        connect by level <= round((l_end_time_utc - l_start_time_utc) * 1440 / p_interval_minutes + 1);
      end if;
      ----------------------------------------------------------------
      -- convert the times back to the input time zone if necessary --
      ----------------------------------------------------------------
      if p_time_zone != 'UTC' then
         for i in 1..l_date_times.count loop
            l_date_times(i) := cwms_util.change_timezone(l_date_times(i), 'UTC', p_time_zone);
         end loop;
      end if;
      return l_date_times;
   END get_times_for_time_window;

   FUNCTION get_times_for_time_window (
      p_start_time IN DATE,
      p_end_time   IN DATE,
      p_ts_code    IN INTEGER,
      p_time_zone  IN VARCHAR2 DEFAULT 'UTC')
      RETURN date_table_type
   IS
      l_interval INTEGER;
      l_offset   INTEGER;
   BEGIN
      select interval,
             interval_utc_offset
        into l_interval,
             l_offset
        from cwms_v_ts_id
       where ts_code = p_ts_code;

      if l_interval = 0 then
         cwms_err.raise('ERROR', 'Cannot retrieve times for irregular time series.');
      end if;
      if l_offset = cwms_util.utc_offset_undefined then
         cwms_err.raise('ERROR', 'UTC interval offset is undefined for time series');
      end if;

      return get_times_for_time_window(
         p_start_time,
         p_end_time,
         l_interval,
         l_offset,
         p_time_zone);
   END get_times_for_time_window;

   FUNCTION get_times_for_time_window (
      p_start_time IN DATE,
      p_end_time   IN DATE,
      p_ts_id      IN VARCHAR2,
      p_time_zone  IN VARCHAR2 DEFAULT 'UTC',
      p_office_id  IN VARCHAR2 DEFAULT NULL)
      RETURN date_table_type
   IS
   BEGIN
      return get_times_for_time_window(
         p_start_time,
         p_end_time,
         get_ts_code(p_ts_id, p_office_id),
         p_time_zone);
   END get_times_for_time_window;

   FUNCTION get_ts_min_date_utc (
      p_ts_code            IN NUMBER,
      p_version_date_utc   IN DATE DEFAULT cwms_util.non_versioned)
      RETURN DATE
   IS
      l_min_date_utc   DATE;
   BEGIN
      FOR rec IN (  SELECT table_name
                      FROM at_ts_table_properties
                  ORDER BY start_date)
      LOOP
         EXECUTE IMMEDIATE
            'select min(date_time)
               from '|| rec.table_name||'
              where ts_code = :1
                and version_date = :2'
            INTO l_min_date_utc
            USING p_ts_code, p_version_date_utc;

         EXIT WHEN l_min_date_utc IS NOT NULL;
      END LOOP;

      RETURN l_min_date_utc;
   END get_ts_min_date_utc;

   FUNCTION get_ts_min_date (
      p_cwms_ts_id     IN VARCHAR2,
      p_time_zone      IN VARCHAR2 DEFAULT 'UTC',
      p_version_date   IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id      IN VARCHAR2 DEFAULT NULL)
      RETURN DATE
   IS
      l_min_date_utc       DATE;
      l_version_date_utc   DATE;
   begin
      IF p_version_date is null or p_version_date = cwms_util.non_versioned
      THEN
         l_version_date_utc := cwms_util.non_versioned;
      ELSE
         l_version_date_utc :=
            cwms_util.change_timezone (p_version_date, p_time_zone, 'UTC');
      END IF;

      l_min_date_utc :=
         get_ts_min_date_utc (
            cwms_ts.get_ts_code (p_cwms_ts_id, p_office_id),
            l_version_date_utc);
      RETURN cwms_util.change_timezone (l_min_date_utc, 'UTC', p_time_zone);
   END get_ts_min_date;


   FUNCTION get_ts_max_date_utc (
      p_ts_code            IN NUMBER,
      p_version_date_utc   IN DATE DEFAULT cwms_util.non_versioned)
      RETURN DATE
   IS
      l_max_date_utc   DATE;
   BEGIN
      FOR rec IN (  SELECT table_name
                      FROM at_ts_table_properties
                  ORDER BY start_date DESC)
      LOOP
         EXECUTE IMMEDIATE
            'select max(date_time)
               from '||rec.table_name||'
              where ts_code = :1
                and version_date = :2'
            INTO l_max_date_utc
            USING p_ts_code, p_version_date_utc;

         EXIT WHEN l_max_date_utc IS NOT NULL;
      END LOOP;

      RETURN l_max_date_utc;
   END get_ts_max_date_utc;
      FUNCTION get_ts_max_date_utc_2 (
      p_ts_code            IN NUMBER,
      p_version_date_utc   IN DATE DEFAULT cwms_util.non_versioned,
      p_year               IN NUMBER DEFAULT NULL)
      RETURN DATE
   IS
      l_max_date_utc   DATE;
   BEGIN
      FOR rec IN (  SELECT table_name
                         , TO_NUMBER(TO_CHAR(start_date, 'YYYY')) table_year
                      FROM at_ts_table_properties
                  ORDER BY start_date DESC)
      LOOP
  
         CASE
          WHEN p_year IS NULL THEN
          --Process for the max date time for this at_tsv_xxxx table
             BEGIN
               EXECUTE IMMEDIATE
                  'select max(date_time)
                     from '||rec.table_name||'
                    where ts_code = :1
                      and version_date = :2'
                  INTO l_max_date_utc
                  USING p_ts_code, p_version_date_utc;
            
            EXCEPTION
             WHEN no_data_found THEN 
              l_max_date_utc := NULL;
            END;

        WHEN p_year = rec.table_year THEN

          --Process ONLY for one year
          BEGIN
            EXECUTE IMMEDIATE
            'select max(date_time)
               from '||rec.table_name||'
              where ts_code = :1
                and version_date = :2'
            INTO l_max_date_utc
            USING p_ts_code, p_version_date_utc;
        
        EXCEPTION
         WHEN no_data_found THEN 
          l_max_date_utc := NULL;
        END;
        ELSE
          --do nothing
          NULL;

        END CASE;

         EXIT WHEN l_max_date_utc IS NOT NULL;

      END LOOP;

      RETURN l_max_date_utc;
   END get_ts_max_date_utc_2;

   FUNCTION get_ts_max_date (
      p_cwms_ts_id     IN VARCHAR2,
      p_time_zone      IN VARCHAR2 DEFAULT 'UTC',
      p_version_date   IN DATE DEFAULT cwms_util.non_versioned,
      p_office_id      IN VARCHAR2 DEFAULT NULL)
      RETURN DATE
   IS
      l_max_date_utc       DATE;
      l_version_date_utc   DATE;
   BEGIN
      IF p_version_date is null or p_version_date = cwms_util.non_versioned
      THEN
         l_version_date_utc := cwms_util.non_versioned;
      ELSE
         l_version_date_utc :=
            cwms_util.change_timezone (p_version_date, p_time_zone, 'UTC');
      END IF;

      l_max_date_utc :=
         get_ts_max_date_utc (
            cwms_ts.get_ts_code (p_cwms_ts_id, p_office_id),
            l_version_date_utc);
      RETURN cwms_util.change_timezone (l_max_date_utc, 'UTC', p_time_zone);
   END get_ts_max_date;


   PROCEDURE get_ts_extents_utc (
      p_min_date_utc          OUT DATE,
      p_max_date_utc          OUT DATE,
      p_ts_code            IN     NUMBER,
      p_version_date_utc   IN     DATE DEFAULT cwms_util.non_versioned)
   IS
   BEGIN
      p_min_date_utc := get_ts_min_date_utc (p_ts_code, p_version_date_utc);
      p_max_date_utc := get_ts_max_date_utc (p_ts_code, p_version_date_utc);
   END get_ts_extents_utc;

   PROCEDURE get_ts_extents (
      p_min_date          OUT DATE,
      p_max_date          OUT DATE,
      p_cwms_ts_id     IN     VARCHAR2,
      p_time_zone      IN     VARCHAR2 DEFAULT 'UTC',
      p_version_date   IN     DATE DEFAULT cwms_util.non_versioned,
      p_office_id      IN     VARCHAR2 DEFAULT NULL)
   IS
      l_min_date_utc       DATE;
      l_max_date_utc       DATE;
      l_version_date_utc   DATE;
   BEGIN
      IF p_version_date IS NULL
      THEN
         l_version_date_utc := cwms_util.non_versioned;
      ELSIF p_version_date = cwms_util.non_versioned
      THEN
         l_version_date_utc := p_version_date;
      ELSE
         l_version_date_utc :=
            cwms_util.change_timezone (p_version_date, p_time_zone, 'UTC');
      END IF;

      get_ts_extents_utc (l_min_date_utc,
                          l_max_date_utc,
                          cwms_ts.get_ts_code (p_cwms_ts_id, p_office_id),
                          l_version_date_utc);
      p_min_date :=
         cwms_util.change_timezone (l_min_date_utc, 'UTC', p_time_zone);
      p_max_date :=
         cwms_util.change_timezone (l_max_date_utc, 'UTC', p_time_zone);
   END get_ts_extents;

   PROCEDURE get_value_extents (p_min_value      OUT BINARY_DOUBLE,
                                p_max_value      OUT BINARY_DOUBLE,
                                p_ts_id       IN     VARCHAR2,
                                p_unit        IN     VARCHAR2,
                                p_min_date    IN     DATE DEFAULT NULL,
                                p_max_date    IN     DATE DEFAULT NULL,
                                p_time_zone   IN     VARCHAR2 DEFAULT NULL,
                                p_office_id   IN     VARCHAR2 DEFAULT NULL)
   IS
      l_min_value      BINARY_DOUBLE;
      l_max_value      BINARY_DOUBLE;
      l_temp_min       BINARY_DOUBLE;
      l_temp_max       BINARY_DOUBLE;
      l_office_id      VARCHAR2 (16);
      l_unit           VARCHAR2 (16);
      l_time_zone      VARCHAR2 (28);
      l_min_date       DATE;
      l_max_date       DATE;
      l_ts_code        NUMBER (10);
      l_parts          str_tab_t;
      l_location_id    VARCHAR2 (49);
      l_parameter_id   VARCHAR2 (49);
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      ----------------------------
      -- set values from inputs --
      ----------------------------
      l_office_id := cwms_util.get_db_office_id (p_office_id);
      l_ts_code := cwms_ts.get_ts_code (p_ts_id, l_office_id);
      l_parts := cwms_util.split_text (p_ts_id, '.');
      l_location_id := l_parts (1);
      l_parameter_id := l_parts (2);
      l_unit := cwms_util.get_default_units (l_parameter_id);
      l_time_zone :=
         CASE p_time_zone IS NULL
            WHEN TRUE
            THEN
               cwms_loc.get_local_timezone (l_location_id, l_office_id)
            WHEN FALSE
            THEN
               p_time_zone
         END;
      l_min_date :=
         CASE p_min_date IS NULL
            WHEN TRUE
            THEN
               DATE '1700-01-01'
            WHEN FALSE
            THEN
               cwms_util.change_timezone (p_min_date, l_time_zone, 'UTC')
         END;
      l_max_date :=
         CASE p_max_date IS NULL
            WHEN TRUE
            THEN
               DATE '2100-01-01'
            WHEN FALSE
            THEN
               cwms_util.change_timezone (p_max_date, l_time_zone, 'UTC')
         END;

      -----------------------
      -- perform the query --
      -----------------------
      FOR rec IN (  SELECT table_name, start_date, end_date
                      FROM at_ts_table_properties
                  ORDER BY start_date)
      LOOP
         CONTINUE WHEN    rec.start_date > l_max_date
                       OR rec.end_date < l_min_date;

         BEGIN
            EXECUTE IMMEDIATE
               'select min(value),
                       max(value)
                  from '||rec.table_name||'
                 where ts_code = :1
                   and date_time between :2 and :3'
               INTO l_temp_min, l_temp_max
               USING l_ts_code, l_min_date, l_max_date;

            IF l_min_value IS NULL OR l_temp_min < l_min_value
            THEN
               l_min_value := l_temp_min;
            END IF;

            IF l_max_value IS NULL OR l_temp_max > l_max_value
            THEN
               l_max_value := l_temp_max;
            END IF;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
         END;
      END LOOP;

      IF l_min_value IS NOT NULL
      THEN
         p_min_value := cwms_util.convert_units (l_min_value, l_unit, p_unit);
      END IF;

      IF l_max_value IS NOT NULL
      THEN
         p_max_value := cwms_util.convert_units (l_max_value, l_unit, p_unit);
      END IF;
   END get_value_extents;

   PROCEDURE get_value_extents (
      p_min_value           OUT BINARY_DOUBLE,
      p_max_value           OUT BINARY_DOUBLE,
      p_min_value_date      OUT DATE,
      p_max_value_date      OUT DATE,
      p_ts_id            IN     VARCHAR2,
      p_unit             IN     VARCHAR2,
      p_min_date         IN     DATE DEFAULT NULL,
      p_max_date         IN     DATE DEFAULT NULL,
      p_time_zone        IN     VARCHAR2 DEFAULT NULL,
      p_office_id        IN     VARCHAR2 DEFAULT NULL)
   IS
      l_min_value        BINARY_DOUBLE;
      l_max_value        BINARY_DOUBLE;
      l_temp_min         BINARY_DOUBLE;
      l_temp_max         BINARY_DOUBLE;
      l_min_value_date   DATE;
      l_max_value_date   DATE;
      l_temp_min_date    DATE;
      l_temp_max_date    DATE;
      l_office_id        VARCHAR2 (16);
      l_unit             VARCHAR2 (16);
      l_time_zone        VARCHAR2 (28);
      l_min_date         DATE;
      l_max_date         DATE;
      l_ts_code          NUMBER (10);
      l_parts            str_tab_t;
      l_location_id      VARCHAR2 (49);
      l_parameter_id     VARCHAR2 (49);
   BEGIN
      ----------------------------
      -- set values from inputs --
      ----------------------------
      l_office_id := cwms_util.get_db_office_id (p_office_id);
      l_ts_code := cwms_ts.get_ts_code (p_ts_id, l_office_id);
      l_parts := cwms_util.split_text (p_ts_id, '.');
      l_location_id := l_parts (1);
      l_parameter_id := l_parts (2);
      l_unit := cwms_util.get_default_units (l_parameter_id);
      l_time_zone :=
         CASE p_time_zone IS NULL
            WHEN TRUE
            THEN
               cwms_loc.get_local_timezone (l_location_id, l_office_id)
            WHEN FALSE
            THEN
               p_time_zone
         END;
      l_min_date :=
         CASE p_min_date IS NULL
            WHEN TRUE
            THEN
               DATE '1700-01-01'
            WHEN FALSE
            THEN
               cwms_util.change_timezone (p_min_date, l_time_zone, 'UTC')
         END;
      l_max_date :=
         CASE p_max_date IS NULL
            WHEN TRUE
            THEN
               DATE '2100-01-01'
            WHEN FALSE
            THEN
               cwms_util.change_timezone (p_max_date, l_time_zone, 'UTC')
         END;

      -----------------------
      -- perform the query --
      -----------------------
      FOR rec IN (  SELECT table_name, start_date, end_date
                      FROM at_ts_table_properties
                  ORDER BY start_date)
      LOOP
         CONTINUE WHEN    rec.start_date > l_max_date
                       OR rec.end_date < l_min_date;

         BEGIN
            EXECUTE IMMEDIATE
               'select date_time,
                       value
                  from '||rec.table_name||'
                 where ts_code = :1
                   and date_time between :2 and :3
                   and value = (select min(value)
                                  from '||rec.table_name||'
                                 where ts_code = :4
                                   and date_time between :5 and :6
                               )
                   and rownum = 1'
               INTO l_temp_min_date, l_temp_min
               USING l_ts_code,
                     l_min_date,
                     l_max_date,
                     l_ts_code,
                     l_min_date,
                     l_max_date;

            IF l_min_value IS NULL OR l_temp_min < l_min_value
            THEN
               l_min_value_date := l_temp_min_date;
               l_min_value := l_temp_min;
            END IF;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
         END;

         BEGIN
            EXECUTE IMMEDIATE
               'select date_time,
                       value
                  from '||rec.table_name||'
                 where ts_code = :1
                   and date_time between :2 and :3
                   and value = (select max(value)
                                  from '||rec.table_name||'
                                 where ts_code = :4
                                   and date_time between :5 and :6
                               )
                   and rownum = 1'
               INTO l_temp_max_date, l_temp_max
               USING l_ts_code,
                     l_min_date,
                     l_max_date,
                     l_ts_code,
                     l_min_date,
                     l_max_date;

            IF l_max_value IS NULL OR l_temp_max > l_max_value
            THEN
               l_max_value_date := l_temp_max_date;
               l_max_value := l_temp_max;
            END IF;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
         END;
      END LOOP;

      IF l_min_value IS NOT NULL
      THEN
         p_min_value := cwms_util.convert_units (l_min_value, l_unit, p_unit);
         p_min_value_date :=
            cwms_util.change_timezone (l_min_value_date, 'UTC', l_time_zone);
      END IF;

      IF l_max_value IS NOT NULL
      THEN
         p_max_value := cwms_util.convert_units (l_max_value, l_unit, p_unit);
         p_max_value_date :=
            cwms_util.change_timezone (l_max_value_date, 'UTC', l_time_zone);
      END IF;
   END get_value_extents;

   FUNCTION get_values_in_range (p_ts_id       IN VARCHAR2,
                                 p_min_value   IN BINARY_DOUBLE,
                                 p_max_value   IN BINARY_DOUBLE,
                                 p_unit        IN VARCHAR2,
                                 p_min_date    IN DATE DEFAULT NULL,
                                 p_max_date    IN DATE DEFAULT NULL,
                                 p_time_zone   IN VARCHAR2 DEFAULT NULL,
                                 p_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN ztsv_array
   IS
   BEGIN
      RETURN get_values_in_range (time_series_range_t (p_office_id,
                                                       p_ts_id,
                                                       p_min_date,
                                                       p_max_date,
                                                       p_time_zone,
                                                       p_min_value,
                                                       p_max_value,
                                                       p_unit));
   END;

   FUNCTION get_values_in_range (p_criteria IN time_series_range_t)
      RETURN ztsv_array
   IS
      l_results         ztsv_array;
      l_table_results   ztsv_array;
      l_office_id       VARCHAR2 (16);
      l_unit            VARCHAR2 (16);
      l_time_zone       VARCHAR2 (28);
      l_min_value       BINARY_DOUBLE;
      l_max_value       BINARY_DOUBLE;
      l_min_date        DATE;
      l_max_date        DATE;
      l_ts_code         NUMBER (10);
      l_parts           str_tab_t;
      l_location_id     VARCHAR2 (49);
      l_parameter_id    VARCHAR2 (49);
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      ----------------------------
      -- set values from inputs --
      ----------------------------
      l_office_id := cwms_util.get_db_office_id (p_criteria.office_id);
      l_ts_code :=
         cwms_ts.get_ts_code (p_criteria.time_series_id, l_office_id);
      l_parts := cwms_util.split_text (p_criteria.time_series_id, '.');
      l_location_id := l_parts (1);
      l_parameter_id := l_parts (2);
      l_unit := cwms_util.get_default_units (l_parameter_id);
      l_min_value :=
         CASE p_criteria.minimum_value IS NULL
            WHEN TRUE
            THEN
               -binary_double_max_normal
            WHEN FALSE
            THEN
               cwms_util.convert_units (p_criteria.minimum_value,
                                        p_criteria.unit,
                                        l_unit)
         END;
      l_max_value :=
         CASE p_criteria.maximum_value IS NULL
            WHEN TRUE
            THEN
               binary_double_max_normal
            WHEN FALSE
            THEN
               cwms_util.convert_units (p_criteria.maximum_value,
                                        p_criteria.unit,
                                        l_unit)
         END;
      l_time_zone :=
         CASE p_criteria.time_zone IS NULL
            WHEN TRUE
            THEN
               cwms_loc.get_local_timezone (l_location_id, l_office_id)
            WHEN FALSE
            THEN
               p_criteria.time_zone
         END;
      l_min_date :=
         CASE p_criteria.start_time IS NULL
            WHEN TRUE
            THEN
               DATE '1700-01-01'
            WHEN FALSE
            THEN
               cwms_util.change_timezone (p_criteria.start_time,
                                          l_time_zone,
                                          'UTC')
         END;
      l_max_date :=
         CASE p_criteria.end_time IS NULL
            WHEN TRUE
            THEN
               DATE '2100-01-01'
            WHEN FALSE
            THEN
               cwms_util.change_timezone (p_criteria.end_time,
                                          l_time_zone,
                                          'UTC')
         END;

      -----------------------
      -- perform the query --
      -----------------------
      IF     p_criteria.minimum_value IS NULL
         AND p_criteria.maximum_value IS NULL
      THEN
         -----------------------------
         -- just call retrieve_ts() --
         -----------------------------
         DECLARE
            l_cursor      SYS_REFCURSOR;
            l_dates       date_table_type;
            l_values      double_tab_t;
            l_qualities   number_tab_t;
         BEGIN
            retrieve_ts (p_at_tsv_rc         => l_cursor,
                         p_cwms_ts_id        => p_criteria.time_series_id,
                         p_units             => l_unit,
                         p_start_time        => l_min_date,
                         p_end_time          => l_max_date,
                         p_time_zone         => 'UTC',
                         p_trim              => 'T',
                         p_start_inclusive   => 'T',
                         p_end_inclusive     => 'T',
                         p_previous          => 'F',
                         p_next              => 'F',
                         p_version_date      => NULL,
                         p_max_version       => 'T',
                         p_office_id         => l_office_id);

            FETCH l_cursor
            BULK COLLECT INTO l_dates, l_values, l_qualities;

            CLOSE l_cursor;

            IF l_dates IS NOT NULL AND l_dates.COUNT > 0
            THEN
               l_results := ztsv_array ();
               l_results.EXTEND (l_dates.COUNT);

               FOR i IN 1 .. l_dates.COUNT
               LOOP
                  l_results (i) :=
                     ztsv_type (
                        cwms_util.change_timezone (l_dates (i),
                                                   'UTC',
                                                   l_time_zone),
                        l_values (i),
                        l_qualities (i));
               END LOOP;
            END IF;
         END;
      ELSE
         ---------------------------------------
         -- find the values that are in range --
         ---------------------------------------
         FOR rec IN (  SELECT table_name, start_date, end_date
                         FROM at_ts_table_properties
                     ORDER BY start_date)
         LOOP
            CONTINUE WHEN    rec.start_date > l_max_date
                          OR rec.end_date < l_min_date;

            BEGIN
               EXECUTE IMMEDIATE
                  'select ztsv_type(date_time, value, quality_code)
                    from '||rec.table_name||'
                   where ts_code = :1
                     and date_time between :1 and :2
                     and value between :3 and :4'
                  BULK COLLECT INTO l_table_results
                  USING l_ts_code,
                        l_min_date,
                        l_max_date,
                        l_min_value,
                        l_max_value;

               IF l_results IS NULL
               THEN
                  l_results := ztsv_array ();
               END IF;

               l_results.EXTEND (l_table_results.COUNT);

               FOR i IN 1 .. l_table_results.COUNT
               LOOP
                  l_table_results (i).date_time :=
                     cwms_util.change_timezone (
                        l_table_results (i).date_time,
                        'UTC',
                        l_time_zone);
                  l_table_results (i).VALUE :=
                     cwms_util.convert_units (l_table_results (i).VALUE,
                                              l_unit,
                                              p_criteria.unit);
                  l_results (l_results.COUNT - l_table_results.COUNT + i) :=
                     l_table_results (i);
               END LOOP;

               l_table_results.delete;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;
            END;
         END LOOP;
      END IF;

      RETURN l_results;
   END get_values_in_range;

   FUNCTION get_values_in_range (p_criteria IN time_series_range_tab_t)
      RETURN ztsv_array_tab
   IS
      TYPE index_by_date_t IS TABLE OF INTEGER
                                 INDEX BY VARCHAR (12);

      TYPE index_by_date_tab_t IS TABLE OF index_by_date_t;

      c_date_fmt   CONSTANT VARCHAR2 (14) := 'yyyymmddhh24mi';
      l_criteria            time_series_range_tab_t := p_criteria;
      l_original_results    ztsv_array_tab := ztsv_array_tab ();
      l_results             ztsv_array_tab := ztsv_array_tab ();
      l_common_dates        index_by_date_t;
      l_individual_dates    index_by_date_tab_t := index_by_date_tab_t ();
      l_count               PLS_INTEGER;
      l_date                VARCHAR2 (12);
      l_dates               date_table_type := date_table_type ();
      l_min_date            DATE;
      l_max_date            DATE;
   BEGIN
      IF l_criteria IS NOT NULL
      THEN
         l_count := l_criteria.COUNT;
         l_individual_dates.EXTEND (l_count);
         l_original_results.EXTEND (l_count);
         l_results.EXTEND (l_count);

         ------------------------------------------------------
         -- get the data for each individual criteria object --
         ------------------------------------------------------
         FOR i IN 1 .. l_count
         LOOP
            IF l_min_date IS NOT NULL
            THEN
               l_criteria (i).start_time :=
                  GREATEST (l_criteria (i).start_time, l_min_date);
            END IF;

            IF l_max_date IS NOT NULL
            THEN
               l_criteria (i).start_time :=
                  LEAST (l_criteria (i).start_time, l_max_date);
            END IF;

            l_original_results (i) := get_values_in_range (l_criteria (i));

            IF     l_original_results (i) IS NOT NULL
               AND l_original_results (i).COUNT > 0
            THEN
               IF l_original_results (i) (1).date_time > l_min_date
               THEN
                  l_min_date := l_original_results (i) (1).date_time;
               END IF;

               IF l_original_results (i) (l_original_results (i).COUNT).date_time <
                     l_max_date
               THEN
                  l_max_date :=
                     l_original_results (i) (l_original_results (i).COUNT).date_time;
               END IF;

               FOR j IN 1 .. l_original_results (i).COUNT
               LOOP
                  l_date :=
                     TO_CHAR (l_original_results (i) (j).date_time,
                              c_date_fmt);
                  l_common_dates (l_date) := 0;
                  l_individual_dates (i) (l_date) := j;
               END LOOP;
            END IF;
         END LOOP;

         --------------------------------------------------------
         -- determine the times that are common to all results --
         --------------------------------------------------------
         FOR i IN 1 .. l_count
         LOOP
            EXIT WHEN l_common_dates.COUNT = 0;
            l_date := l_common_dates.LAST;

            LOOP
               EXIT WHEN l_date IS NULL;

               IF NOT l_individual_dates (i).EXISTS (l_date)
               THEN
                  l_common_dates.delete (l_date);
               END IF;

               l_date := l_common_dates.PRIOR (l_date);
            END LOOP;
         END LOOP;

         ------------------------------------------------
         -- build the result set from the common times --
         ------------------------------------------------
         IF l_common_dates.COUNT > 0
         THEN
            FOR i IN 1 .. l_count
            LOOP
               l_results (i) := ztsv_array ();
               l_date := l_common_dates.FIRST;

               LOOP
                  EXIT WHEN l_date IS NULL;
                  l_results (i).EXTEND;
                  l_results (i) (l_results (i).COUNT) :=
                     l_original_results (i) (l_individual_dates (i) (l_date));
                  l_date := l_common_dates.NEXT (l_date);
               END LOOP;
            END LOOP;
         END IF;
      END IF;

      RETURN l_results;
   END get_values_in_range;

   PROCEDURE trim_ts_deleted_times
   IS
      l_millis_count   NUMBER (14);
      l_millis_date    NUMBER (14);
      l_count          NUMBER;
      l_count2         NUMBER;
      l_max_count      NUMBER;
      l_max_days       NUMBER;
      l_office_id      VARCHAR2 (16) := cwms_util.user_office_id;
   BEGIN
      cwms_msg.log_db_message ('TRIM_TS_DELETED_TIMES',
                               cwms_msg.msg_level_basic,
                               'Start trimming AT_TS_DELETED_TIMES entries');
      ---------------------------------------
      -- get the count and date properties --
      ---------------------------------------
      l_max_count :=
         TO_NUMBER (cwms_properties.get_property (
                       'CWMSDB',
                       'ts_deleted.table.max_entries',
                       '1000000',
                       l_office_id));
      l_max_days :=
         TO_NUMBER (cwms_properties.get_property ('CWMSDB',
                                                  'ts_deleted.table.max_age',
                                                  '7',
                                                  l_office_id));

      -------------------------------------------
      -- determine the millis cutoff for count --
      -------------------------------------------
      SELECT COUNT (*) INTO l_count FROM at_ts_deleted_times;

      cwms_msg.log_db_message (
         'TRIM_TS_DELETED_TIMES',
         cwms_msg.msg_level_detailed,
         'AT_TS_DELETED_TIMES has ' || l_count || ' records.');

      IF l_count > l_max_count
      THEN
         SELECT deleted_time
           INTO l_millis_count
           FROM (  SELECT deleted_time, ROWNUM AS rn
                     FROM at_ts_deleted_times
                 ORDER BY deleted_time DESC)
          WHERE rn = TRUNC (l_max_count);
      END IF;

      ------------------------------------------
      -- determine the millis cutoff for date --
      ------------------------------------------
      l_millis_date :=
         cwms_util.to_millis (
              SYSTIMESTAMP AT TIME ZONE 'UTC'
            - NUMTODSINTERVAL (l_max_days, 'DAY'));

      --------------------
      -- trim the table --
      --------------------
      DELETE FROM at_ts_deleted_times
            WHERE deleted_time < GREATEST (l_millis_count, l_millis_date);

      SELECT COUNT (*) INTO l_count2 FROM at_ts_deleted_times;

      l_count := l_count - l_count2;
      cwms_msg.log_db_message (
         'TRIM_TS_DELETED_TIMES',
         cwms_msg.msg_level_detailed,
         'Deleted ' || l_count || ' records from AT_TS_DELETED_TIMES');

      cwms_msg.log_db_message ('TRIM_TS_DELETED_TIMES',
                               cwms_msg.msg_level_basic,
                               'Done trimming AT_TS_DELETED_TIMES entries');
   END trim_ts_deleted_times;

   PROCEDURE start_trim_ts_deleted_job
   IS
      l_count          BINARY_INTEGER;
      l_user_id        VARCHAR2 (30);
      l_job_id         VARCHAR2 (30) := 'TRIM_TS_DELETED_TIMES_JOB';
      l_run_interval   VARCHAR2 (8);
      l_comment        VARCHAR2 (256);

      FUNCTION job_count
         RETURN BINARY_INTEGER
      IS
      BEGIN
         SELECT COUNT (*)
           INTO l_count
           FROM sys.dba_scheduler_jobs
          WHERE job_name = l_job_id AND owner = l_user_id;

         RETURN l_count;
      END;
   BEGIN
      --------------------------------------
      -- make sure we're the correct user --
      --------------------------------------
      l_user_id := cwms_util.get_user_id;

      IF UPPER (l_user_id) != UPPER ('&cwms_schema')
      THEN
         DBMS_OUTPUT.put_line ('User ID = ' || l_user_id);
         DBMS_OUTPUT.put_line ('Must be : ' || '&cwms_schema');
         raise_application_error (
            -20999,
            'Must be &cwms_schema user to start job ' || l_job_id,
            TRUE);
      END IF;

      -------------------------------------------
      -- drop the job if it is already running --
      -------------------------------------------
      IF job_count > 0
      THEN
         DBMS_OUTPUT.put ('Dropping existing job ' || l_job_id || '...');
         DBMS_SCHEDULER.drop_job (l_job_id);

         --------------------------------
         -- verify that it was dropped --
         --------------------------------
         IF job_count = 0
         THEN
            DBMS_OUTPUT.put_line ('done.');
         ELSE
            DBMS_OUTPUT.put_line ('failed.');
         END IF;
      END IF;

      IF job_count = 0
      THEN
         BEGIN
            ---------------------
            -- restart the job --
            ---------------------
            cwms_properties.get_property (l_run_interval,
                                          l_comment,
                                          'CWMSDB',
                                          'ts_deleted.auto_trim.interval',
                                          '15',
                                          'CWMS');
            DBMS_SCHEDULER.create_job (
               job_name          => l_job_id,
               job_type          => 'stored_procedure',
               job_action        => 'cwms_ts.trim_ts_deleted_times',
               start_date        => NULL,
               repeat_interval   =>    'freq=minutely; interval='
                                    || l_run_interval,
               end_date          => NULL,
               job_class         => 'default_job_class',
               enabled           => TRUE,
               auto_drop         => FALSE,
               comments          => 'Trims at_ts_deleted_times to specified max entries and max age.');

            IF job_count = 1
            THEN
               DBMS_OUTPUT.put_line (
                     'Job '
                  || l_job_id
                  || ' successfully scheduled to execute every '
                  || l_run_interval
                  || ' minutes.');
            ELSE
               cwms_err.raise ('ITEM_NOT_CREATED', 'job', l_job_id);
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               cwms_err.raise ('ITEM_NOT_CREATED',
                               'job',
                               l_job_id || ':' || SQLERRM);
         END;
      END IF;
   END start_trim_ts_deleted_job;

   FUNCTION get_associated_timeseries (
      p_location_id         IN VARCHAR2,
      p_association_type    IN VARCHAR2,
      p_usage_category_id   IN VARCHAR2,
      p_usage_id            IN VARCHAR2,
      p_office_id           IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   AS
      l_office_id   VARCHAR2 (16);
      l_tsid        VARCHAR2 (183);
   BEGIN
      l_office_id := cwms_util.get_db_office_id (p_office_id);

      ----------------------------------------------------------------------------
      -- retrieve the associated time series with specified or default location --
      ----------------------------------------------------------------------------
      BEGIN
         SELECT timeseries_id
           INTO l_tsid
           FROM (  SELECT timeseries_id
                     FROM cwms_v_ts_association
                    WHERE     UPPER (association_id) IN
                                 ('?GLOBAL?', UPPER (p_location_id))
                          AND association_type = UPPER (p_association_type)
                          AND UPPER (usage_category_id) =
                                 UPPER (p_usage_category_id)
                          AND UPPER (usage_id) = UPPER (p_usage_id)
                          AND office_id = l_office_id
                 ORDER BY association_id DESC -- '?GLOBAL?' sorts after actual location
                )
          WHERE ROWNUM < 2;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise (
               'ERROR',
               'No such time series association: '''
               || l_office_id
               || '/'
               || '?GLOBAL?/'
               || p_association_type
               || '/'
               || p_usage_category_id
               || '/'
               || p_usage_id
               || '''');
      END get_associated_timeseries;

      ---------------------------------------
      -- return the associated time series --
      ---------------------------------------
      RETURN REPLACE (l_tsid, '?GLOBAL?', p_location_id);
   END;

   procedure set_retrieve_unsigned_quality
   is
   begin
      cwms_util.set_session_info('UNSIGNED QUALITY', 'T');
   end set_retrieve_unsigned_quality;

   procedure set_retrieve_signed_quality
   is
   begin
      cwms_util.reset_session_info('UNSIGNED QUALITY');
   end set_retrieve_signed_quality;

   function normalize_quality(
      p_quality in number)
      return number
      result_cache
   is
      l_quality number;
   begin
      case cwms_util.get_session_info_txt('UNSIGNED QUALITY')
         when 'T' then
            if p_quality < 0 then
               l_quality := 4294967296 + p_quality;
            else
               l_quality := p_quality;
            end if;
         else
            if p_quality > 2147483647 then
               l_quality := p_quality - 4294967296;
            else
               l_quality := p_quality;
            end if;
      end case;
      return l_quality;
   end normalize_quality;

   procedure set_nulls_storage_policy_ofc(
      p_storage_policy in integer,
      p_office_id      in varchar2 default null)
   as
   begin
      ------------------
      -- sanity check --
      ------------------
      if p_storage_policy is not null and
         p_storage_policy not in (
            filter_out_null_values, 
            set_null_values_to_missing, 
            reject_ts_with_null_values)
      then
         cwms_err.raise(
            'ERROR',
            'P_STORAGE_POLICY must be one of FILTER_OUT_NULL_VALUES, SET_NULL_VALUES_TO_MISSING, or REJECT_TS_WITH_NULL_VALUES'); 
      end if;
      cwms_msg.log_db_message(
         'CWMS_TS.SET_NULLS_STORAGE_POLICY',
         cwms_msg.msg_level_normal,
         'Setting NULLs storage policy to '
         || case p_storage_policy is null
               when true then 'NULL'
               else case p_storage_policy
               	      when filter_out_null_values then 
               	         'FILTER_OUT_NULL_VALUES'
               	      when set_null_values_to_missing then
               	      	 'SET_NULL_VALUES_TO_MISSING'
               	      when reject_ts_with_null_values then
               	      	 'REJECT_TS_WITH_NULL_VALUES'
                    end
            end
         ||' for office '
         ||cwms_util.get_db_office_id(p_office_id));
      if p_storage_policy is null then
         cwms_properties.delete_property(
            p_category  => 'TIMESERIES', 
            p_id        => 'storage.nulls.office.'||cwms_util.get_db_office_code(p_office_id), 
            p_office_id => 'CWMS');
      else
         cwms_properties.set_property(
            p_category  => 'TIMESERIES', 
            p_id        => 'storage.nulls.office.'||cwms_util.get_db_office_code(p_office_id), 
            p_value     => p_storage_policy, 
            p_comment   => null, 
            p_office_id => 'CWMS');
      end if;   
   end set_nulls_storage_policy_ofc;
      
   procedure set_nulls_storage_policy_ts(
      p_storage_policy in integer,
      p_ts_id          in varchar2,
      p_office_id      in varchar2 default null)
   as
   begin
      ------------------
      -- sanity check --
      ------------------
      if p_storage_policy is not null and
         p_storage_policy not in (
            filter_out_null_values, 
            set_null_values_to_missing, 
            reject_ts_with_null_values)
      then
         cwms_err.raise(
            'ERROR',
            'P_STORAGE_POLICY must be one of FILTER_OUT_NULL_VALUES, SET_NULL_VALUES_TO_MISSING, or REJECT_TS_WITH_NULL_VALUES'); 
      end if;
      cwms_msg.log_db_message(
         'CWMS_TS.SET_NULLS_STORAGE_POLICY',
         cwms_msg.msg_level_normal,
         'Setting NULLs storage policy to '
         || case p_storage_policy is null
               when true then 'NULL'
               else case p_storage_policy
               	      when filter_out_null_values then 
               	         'FILTER_OUT_NULL_VALUES'
               	      when set_null_values_to_missing then
               	      	 'SET_NULL_VALUES_TO_MISSING'
               	      when reject_ts_with_null_values then
               	      	 'REJECT_TS_WITH_NULL_VALUES'
                    end
            end
         ||' for time seires '
         ||cwms_util.get_db_office_id(p_office_id)
         ||'/'
         ||p_ts_id
         ||' ('
         ||get_ts_code(p_ts_id, p_office_id)
         ||')');
      if p_storage_policy is null then
         cwms_properties.delete_property(
            p_category  => 'TIMESERIES', 
            p_id        => 'storage.nulls.tscode.'||get_ts_code(p_ts_id, p_office_id), 
            p_office_id => 'CWMS');
      else
         cwms_properties.set_property(
            p_category  => 'TIMESERIES', 
            p_id        => 'storage.nulls.tscode.'||get_ts_code(p_ts_id, p_office_id), 
            p_value     => p_storage_policy, 
            p_comment   => null, 
            p_office_id => 'CWMS');

      end if;   
   end set_nulls_storage_policy_ts;
      
   function get_nulls_storage_policy_ofc(
      p_office_id in varchar2 default null)
      return integer
   as
   begin
      return cwms_properties.get_property(
         p_category  => 'TIMESERIES', 
         p_id        => 'storage.nulls.office.'||cwms_util.get_db_office_code(p_office_id), 
         p_default   => null, 
         p_office_id => 'CWMS');
   end get_nulls_storage_policy_ofc;                  
      
   function get_nulls_storage_policy_ts(
      p_ts_id     in varchar2,
      p_office_id in varchar2 default null)
      return integer
   as
   begin
      return cwms_properties.get_property(
         p_category  => 'TIMESERIES', 
         p_id        => 'storage.nulls.tscode.'||get_ts_code(p_ts_id, p_office_id), 
         p_default   => null, 
         p_office_id => 'CWMS');
   end get_nulls_storage_policy_ts;
      
   function get_nulls_storage_policy(
      p_ts_code in integer)
      return integer
   as
      l_policy      integer; 
      l_office_code integer;
   begin
      l_policy := cwms_properties.get_property(
         p_category  => 'TIMESERIES', 
         p_id        => 'storage.nulls.tscode.'||p_ts_code, 
         p_default   => null, 
         p_office_id => 'CWMS');
      if l_policy is null then
         select bl.db_office_code
           into l_office_code 
           from at_cwms_ts_spec ts,
                at_physical_location pl,
                at_base_location bl
          where ts.ts_code = p_ts_code
            and pl.location_code = ts.location_code
            and bl.base_location_code = pl.base_location_code;
         l_policy := cwms_properties.get_property(
            p_category  => 'TIMESERIES', 
            p_id        => 'storage.nulls.office.'||l_office_code, 
            p_default   => null, 
            p_office_id => 'CWMS');
         if l_policy is null then
            l_policy := filter_out_null_values;
         end if;
      end if;
      return l_policy;
   end get_nulls_storage_policy;

         
END cwms_ts;                                                --end package body
/

SHOW ERRORS;
COMMIT;

prompt update for package body cwms_text


create or replace package body cwms_text
as
   function group_times(p_times_1 in date_table_type, p_times_2 in date_table_type)
      return date2_tab_t
   is
      l_times   date2_tab_t := date2_tab_t();
   begin
      l_times.extend(p_times_1.count);

      for i in 1 .. p_times_1.count loop
         l_times(i) := date2_t(p_times_1(i), p_times_2(i));
      end loop;

      return l_times;
   end group_times;

   function group_times(p_cursor in sys_refcursor)
      return date2_tab_t
   is
      l_times_1   date_table_type;
      l_times_2   date_table_type;
   begin
      fetch p_cursor
      bulk collect into l_times_1, l_times_2;

      close p_cursor;

      return group_times(l_times_1, l_times_2);
   end group_times; 

   function get_media_type_code(p_type_or_ext in varchar2, p_office_code in number)
      return number
   is
      l_media_type_code   number(10);
   begin
      if p_type_or_ext is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TYPE_OR_EXT');
      end if;

      if instr(p_type_or_ext, '/') > 0 then
         -----------------------
         -- check media types --
         -----------------------
         begin
            select media_type_code
              into l_media_type_code
              from cwms_media_type
             where media_type_id = p_type_or_ext;
         exception
            when no_data_found then
               begin
                  select media_type_code
                    into l_media_type_code
                    from cwms_media_type
                   where upper(media_type_id) = upper(p_type_or_ext);
               exception
                  when no_data_found then
                     null;
               end;
         end;
      else
         ---------------------------
         -- check file extensions --
         ---------------------------
         begin
            select media_type_code
              into l_media_type_code
              from at_file_extension
             where office_code in (p_office_code, cwms_util.db_office_code_all)
               and file_ext = substr(
                                 p_type_or_ext,
                                 instr(
                                    p_type_or_ext,
                                    '.',
                                    -1,
                                    1)
                                 + 1);
         exception
            when no_data_found then
               begin
                  select media_type_code
                    into l_media_type_code
                    from at_file_extension
                   where office_code in (p_office_code, cwms_util.db_office_code_all)
                     and upper(file_ext) = upper(substr(
                                                    p_type_or_ext,
                                                    instr(
                                                       p_type_or_ext,
                                                       '.',
                                                       -1,
                                                       1)
                                                    + 1));
               exception
                  when no_data_found then
                     null;
               end;
         end;
      end if;

      if l_media_type_code is null then
         cwms_err.raise('ERROR', 'No media type associated with "' || p_type_or_ext || '"');
      end if;

      return l_media_type_code;
   end get_media_type_code;
   
   --
   -- store binary with optional description
   -- 
   procedure store_binary(
      p_binary_code       out number, -- the code for use in foreign keys
      p_binary            in     blob, -- the binary, unlimited length
      p_id                in     varchar2, -- identifier with which to retrieve binary (256 chars max)
      p_media_type_or_ext in     varchar2, -- the MIME media type or file extension 
      p_description       in     varchar2 default null, -- description, defaults to null
      p_fail_if_exists    in     varchar2 default 'T', -- flag specifying whether to fail if p_id already exists
      p_ignore_nulls      in     varchar2 default 'T', -- flag specifying whether to ignore null parameters on update
      p_office_id         in     varchar2 default null) -- office id, defaults current user's office
   is
      l_rec            at_blob%rowtype;
      l_id             varchar2(256) := upper(p_id);
      l_office_code    number := cwms_util.get_office_code(p_office_id);
      l_fail_if_exists boolean := cwms_util.return_true_or_false(p_fail_if_exists);
      l_ignore_nulls   boolean := cwms_util.return_true_or_false(p_ignore_nulls);
      l_exists         boolean;
   begin
      cwms_util.check_office_permission(p_office_id);
      begin
         select *
           into l_rec
           from at_blob
          where office_code in (l_office_code, cwms_util.db_office_code_all)
            and id = l_id;
         l_exists := true;            
      exception           
         when no_data_found then
            l_exists := false;
      end;
      if l_exists then
         if l_fail_if_exists then
            cwms_err.raise('ITEM_ALREADY_EXISTS', 'Binary ID', p_id);
         else
            --
            -- update the record
            --
            if l_ignore_nulls then
               l_rec.value := case p_binary is null 
                                 when true then l_rec.value 
                                 else p_binary 
                              end;
               l_rec.description := nvl(p_description, l_rec.description);
               l_rec.media_type_code := case p_media_type_or_ext is null                               
                                           when true then l_rec.media_type_code
                                           else get_media_type_code(p_media_type_or_ext, l_office_code)
                                        end;
            else               
               l_rec.value := p_binary;
               l_rec.description := p_description;
               l_rec.media_type_code := get_media_type_code(p_media_type_or_ext, l_office_code);
            end if;
            update at_blob
               set row = l_rec;
         end if;
      else
         -- 
         -- insert the record
         --
         l_rec.blob_code := cwms_seq.nextval;
         l_rec.office_code := l_office_code;
         l_rec.value := p_binary;
         l_rec.description := p_description;
         l_rec.media_type_code := get_media_type_code(p_media_type_or_ext, l_office_code);
         insert into at_blob values l_rec;
      end if;
      p_binary_code := l_rec.blob_code;                          
   end store_binary;      

   --
   -- store text with optional description
   --
   procedure store_text(
      p_text_code         out number, -- the code for use in foreign keys
      p_text           in     clob, -- the text, unlimited length
      p_id             in     varchar2, -- identifier with which to retrieve text (256 chars max)
      p_description    in     varchar2 default null, -- description, defaults to null
      p_fail_if_exists in     varchar2 default 'T', -- flag specifying whether to fail if p_id already exists
      p_office_id      in     varchar2 default null) -- office id, defaults current user's office
   is
      l_id                 varchar2(256) := upper(p_id);
      l_fail_if_exists     boolean := cwms_util.return_true_or_false(p_fail_if_exists);
      l_count              binary_integer;
      l_office_code        number := cwms_util.get_office_code(p_office_id);
      l_cwms_office_code   number := cwms_util.get_office_code('CWMS');
      l_rowid              urowid;
   begin
      cwms_util.check_office_permission(p_office_id);
      select count(*)
        into l_count
        from at_clob
       where office_code in (l_office_code, l_cwms_office_code) and id = l_id;

      if l_count = 0 then
         insert into at_clob
              values (
                        cwms_seq.nextval,
                        l_office_code,
                        l_id,
                        p_description,
                        p_text)
           returning clob_code
                into p_text_code;
      else
         if l_fail_if_exists then
            cwms_err.raise('ITEM_ALREADY_EXISTS', 'Text ID', p_id);
         end if;

            update at_clob
               set description = p_description, value = p_text
             where office_code = l_office_code and id = l_id
         returning rowid, clob_code
              into l_rowid, p_text_code;

         if l_rowid is null then
            cwms_err.raise('ERROR', 'Cannot update text owned by the CWMS Office ID.');
         end if;
      end if;
   end store_text;

   --
   -- store text with optional description
   --
   function store_text(
      p_text           in clob, -- the text, unlimited length
      p_id             in varchar2, -- identifier with which to retrieve text (256 chars max)
      p_description    in varchar2 default null, -- description, defaults to null
      p_fail_if_exists in varchar2 default 'T', -- flag specifying whether to fail if p_id already exists
      p_office_id      in varchar2 default null) -- office id, defaults current user's office
      return number -- the code for use in foreign keys
   is
      l_text_code   number;
   begin
      store_text(
         p_text_code      => l_text_code,
         p_text           => p_text,
         p_id             => p_id,
         p_description    => p_description,
         p_fail_if_exists => p_fail_if_exists,
         p_office_id      => p_office_id);

      return l_text_code;
   end store_text;

   --
   -- store text with optional description
   --
   procedure store_text(
      p_text_code         out number, -- the code for use in foreign keys
      p_text           in     varchar2, -- the text, limited to varchar2 max size
      p_id             in     varchar2, -- identifier with which to retrieve text (256 chars max)
      p_description    in     varchar2 default null, -- description, defaults to null
      p_fail_if_exists in     varchar2 default 'T', -- flag specifying whether to fail if p_id already exists
      p_office_id      in     varchar2 default null) -- office id, defaults current user's office
   is
      l_text   clob;
   begin
      dbms_lob.createtemporary(l_text, true);
      dbms_lob.open(l_text, dbms_lob.lob_readwrite);
      dbms_lob.writeappend(l_text, length(p_text), p_text);
      dbms_lob.close(l_text);
      store_text(
         p_text_code      => p_text_code,
         p_text           => l_text,
         p_id             => p_id,
         p_description    => p_description,
         p_fail_if_exists => p_fail_if_exists,
         p_office_id      => p_office_id);
   end store_text;

   --
   -- store text with optional description
   --
   function store_text(
      p_text           in varchar2, -- the text, limited to varchar2 max size
      p_id             in varchar2, -- identifier with which to retrieve text (256 chars max)
      p_description    in varchar2 default null, -- description, defaults to null
      p_fail_if_exists in varchar2 default 'T', -- flag specifying whether to fail if p_id already exists
      p_office_id      in varchar2 default null) -- office id, defaults current user's office
      return number -- the code for use in foreign keys
   is
      l_text_code   number;
   begin
      store_text(
         p_text_code      => l_text_code,
         p_text           => p_text,
         p_id             => p_id,
         p_description    => p_description,
         p_fail_if_exists => p_fail_if_exists,
         p_office_id      => p_office_id);

      return l_text_code;
   end store_text;
   
   --
   -- retrieve binary only
   --
   procedure retrieve_binary(
      p_binary       out blob, -- the binary, unlimited length
      p_id        in     varchar2, -- identifier used to store binary (256 chars max)
      p_office_id in     varchar2 default null) -- office id, defaults current user's office
   is
      l_description     at_blob.description%type;
      l_media_type      cwms_media_type.media_type_id%type;
      l_file_extensions varchar2(256);
   begin                              
      retrieve_binary2(
         p_binary,
         l_description,
         l_media_type,
         l_file_extensions,
         p_id,
         p_office_id);
   end retrieve_binary;

   --
   -- retrieve binary only
   --
   function retrieve_binary(
      p_id        in varchar2, -- identifier used to store binary (256 chars max)
      p_office_id in varchar2 default null) -- office id, defaults current user's office
      return blob
   is
      l_binary blob;
   begin            
      retrieve_binary(l_binary, p_id, p_office_id);
      return l_binary;
   end retrieve_binary;

   --
   -- Retrieve binary and associated information
   --
   procedure retrieve_binary2(
      p_binary             out blob, -- the binary, unlimited length
      p_description        out varchar2, -- the description
      p_media_type         out varchar2, -- the MIME media type
      p_file_extensions    out varchar2, -- comma-separated list of file extensions, if any
      p_id              in     varchar2, -- identifier used to store binary (256 chars max)
      p_office_id       in     varchar2 default null) -- office id, defaults current user's office
   is
      l_rec             at_blob%rowtype;
      l_description     at_blob.description%type;
      l_media_type      cwms_media_type.media_type_id%type;
      l_office_code     number(10) := cwms_util.get_office_code(p_office_id); 
      l_file_extensions str_tab_t := str_tab_t();
   begin
      begin
         select *
           into l_rec
           from at_blob
          where office_code in (l_office_code, cwms_util.db_office_code_all)
            and id = upper(p_id);
      exception
         when no_data_found then
            cwms_err.raise(
               'ITEM_DOES_NOT_EXIST',
               case p_office_id is null
                  when true then p_id
                  else p_office_id||'/'||p_id
               end);
      end;
      select media_type_id
        into p_media_type
        from cwms_media_type
       where media_type_code = l_rec.media_type_code;
       
      for rec in 
         (  select file_ext
              from at_file_extension
             where office_code in (l_office_code, cwms_util.db_office_code_all)
               and media_type_code = l_rec.media_type_code
             order by file_ext
         )
      loop
         l_file_extensions.extend;
         l_file_extensions(l_file_extensions.count) := rec.file_ext;
      end loop;
      p_file_extensions := cwms_util.join_text(l_file_extensions, ',');       
   end retrieve_binary2;

   --
   -- retrieve text only
   --
   procedure retrieve_text(p_text out clob, -- the text, unlimited length
                                           p_id in varchar2, -- identifier used to store text (256 chars max)
                                                            p_office_id in varchar2 default null) -- office id, defaults current user's office
   is
      l_id                 varchar2(256) := upper(p_id);
      l_office_code        number := cwms_util.get_office_code(p_office_id);
      l_cwms_office_code   number := cwms_util.get_office_code('CWMS');
   begin
      select value
        into p_text
        from at_clob
       where office_code in (l_office_code, l_cwms_office_code) and id = l_id;
   end retrieve_text;

   --
   -- retrieve text only
   --
   function retrieve_text(p_id in varchar2, -- identifier used to store text (256 chars max)
                                           p_office_id in varchar2 default null) -- office id, defaults current user's office
      return clob -- the text, unlimited length
   is
      l_text   clob;
   begin
      retrieve_text(p_text => l_text, p_id => p_id, p_office_id => p_office_id);
      return l_text;
   end retrieve_text;

   --
   -- retrieve text and description
   --
   procedure retrieve_text2(
      p_text           out clob, -- the text, unlimited length
      p_description    out varchar2, -- the description
      p_id          in     varchar2, -- identifier used to store text (256 chars max)
      p_office_id   in     varchar2 default null) -- office id, defaults current user's office
   is
      l_id                 varchar2(256) := upper(p_id);
      l_office_code        number := cwms_util.get_office_code(p_office_id);
      l_cwms_office_code   number := cwms_util.get_office_code('CWMS');
   begin
      select value, description
        into p_text, p_description
        from at_clob
       where office_code in (l_office_code, l_cwms_office_code) and id = l_id;
   end retrieve_text2;

   --
   -- update text and/or description
   --
   procedure update_text(
      p_text         in clob, -- the text, unlimited length
      p_id           in varchar2, -- identifier with which to retrieve text (256 chars max)
      p_description  in varchar2 default null, -- description, defaults to null
      p_ignore_nulls in varchar2 default 'T', -- flag specifying null inputs leave current values unchanged
      p_office_id    in varchar2 default null) -- office id, defaults current user's office
   is
      l_id                 varchar2(256) := upper(p_id);
      l_office_code        number := cwms_util.get_office_code(p_office_id);
      l_cwms_office_code   number := cwms_util.get_office_code('CWMS');
      l_ignore_nulls       boolean := cwms_util.return_true_or_false(p_ignore_nulls);
   begin
      cwms_util.check_office_permission(p_office_id);
      if l_ignore_nulls then
         if p_text is null then
            if p_description is not null then
               update at_clob
                  set description = p_description
                where office_code in (l_office_code, l_cwms_office_code) and id = l_id;
            end if;
         elsif p_description is null then
            update at_clob
               set value = p_text
             where office_code in (l_office_code, l_cwms_office_code) and id = l_id;
         else
            update at_clob
               set value = p_text, description = p_description
             where office_code in (l_office_code, l_cwms_office_code) and id = l_id;
         end if;
      else
         update at_clob
            set value = p_text, description = p_description
          where office_code in (l_office_code, l_cwms_office_code) and id = l_id;
      end if;
   end update_text;

   --
   -- append to text
   --
   procedure append_text(
      p_new_text  in out nocopy clob, -- the text to append, unlimited length
      p_id        in varchar2, -- identifier of text to append to (256 chars max)
      p_office_id in varchar2 default null) -- office id, defaults current user's office
   is
      l_existing_text   clob;
      l_code            number(10);
      l_office_code     number(10);
   begin
      begin
         l_code := cwms_text.get_text_code(p_id, p_office_id);

         select office_code, value
           into l_office_code, l_existing_text
           from at_clob
          where clob_code = l_code;

         cwms_util.append(l_existing_text, p_new_text);

         update at_clob
            set value = l_existing_text
          where clob_code = l_code;
      exception
         when no_data_found then
            store_text(
               p_text_code      => l_code,
               p_text           => p_new_text,
               p_id             => p_id,
               p_description    => null,
               p_fail_if_exists => 'T',
               p_office_id      => p_office_id);
      end;
   end append_text;

   --
   -- append to text
   --
   procedure append_text(
      p_new_text  in varchar2, -- the text to append, limited to varchar2 max size
      p_id        in varchar2, -- identifier of text to append to (256 chars max)
      p_office_id in varchar2 default null) -- office id, defaults current user's office
   is
      l_existing_text   clob;
      l_code            number(10);
      l_office_code     number(10);
   begin
      begin
         l_code := cwms_text.get_text_code(p_id, p_office_id);

         select office_code, value
           into l_office_code, l_existing_text
           from at_clob
          where clob_code = l_code;

         if l_office_code = cwms_util.db_office_code_all then
            cwms_err.raise('ERROR', 'Cannot update text owned by the CWMS Office ID.');
         end if;

         cwms_util.append(l_existing_text, p_new_text);

         update at_clob
            set value = l_existing_text
          where clob_code = l_code;
      exception
         when no_data_found then
            dbms_lob.createtemporary(l_existing_text, true);
            dbms_lob.open(l_existing_text, dbms_lob.lob_readwrite);
            dbms_lob.writeappend(l_existing_text, length(p_new_text), p_new_text);
            dbms_lob.close(l_existing_text);
            store_text(
               p_text_code      => l_code,
               p_text           => l_existing_text,
               p_id             => p_id,
               p_description    => null,
               p_fail_if_exists => 'T',
               p_office_id      => p_office_id);
      end;
   end append_text;

   --
   -- delete binary
   --
   procedure delete_binary(
      p_id        in varchar2, -- identifier used to store binary (256 chars max)
      p_office_id in varchar2 default null) -- office id, defaults current user's office
   is
      l_id            varchar2(256) := upper(p_id);
      l_office_code   number := cwms_util.get_office_code(p_office_id);
   begin
      cwms_util.check_office_permission(p_office_id);
      delete 
        from at_blob
       where office_code = l_office_code and id = l_id;
   end delete_binary;

   --
   -- delete text
   --
   procedure delete_text(
      p_id        in varchar2, -- identifier used to store text (256 chars max)
      p_office_id in varchar2 default null) -- office id, defaults current user's office
   is
      l_id            varchar2(256) := upper(p_id);
      l_office_code   number := cwms_util.get_office_code(p_office_id);
   begin
      cwms_util.check_office_permission(p_office_id);
      delete 
        from at_clob
       where office_code = l_office_code and id = l_id;
   end delete_text;

   --
   -- get matching ids in a cursor
   --
   procedure get_matching_ids(
      p_ids                  in out sys_refcursor, -- cursor of the matching office ids, text ids, and optionally descriptions
      p_id_masks             in     varchar2 default '%', -- delimited list of id masks, defaults to all ids
      p_include_descriptions in     varchar2 default 'F', -- flag specifying whether to retrieve descriptions also
      p_office_id_masks      in     varchar2 default null, -- delimited list of office id masks, defaults to user's office
      p_delimiter            in     varchar2 default ',') -- delimiter for masks, defaults to comma
   is
      type id_collection is table of boolean
                               index by varchar2(256);

      l_include_descriptions   boolean := cwms_util.return_true_or_false(p_include_descriptions);
      l_office_id_masks        varchar2(256) := nvl(p_office_id_masks, cwms_util.user_office_id);
      l_office_id_mask_tab     str_tab_t;
      l_id_mask_tab            str_tab_t;
      l_ids                    id_collection;
      l_office_id_bind_str     varchar2(32767);
      l_id_bind_str            varchar2(32767);
      l_query_str              varchar2(32767);
      l_office_id              varchar2(16);
      l_id                     varchar2(256);
      l_cwms_matched           boolean := false;
      l_id_mask                varchar2(256);
   begin
      ------------------------------------
      -- build office ids bind variable --
      ------------------------------------
      l_office_id_mask_tab := cwms_util.split_text(l_office_id_masks, p_delimiter);

      for i in 1 .. l_office_id_mask_tab.count loop
         l_id_mask := cwms_util.normalize_wildcards(upper(l_office_id_mask_tab(i)), true);
         for rec in (select office_id
                       from cwms_office
                      where office_id like l_id_mask) loop
            if not l_ids.exists(rec.office_id) then
               l_ids(rec.office_id) := true;
            end if;
         end loop;
      end loop;

      l_office_id          := l_ids.first;

      loop
         if l_office_id = 'CWMS' then
            l_cwms_matched := true;
         end if;

         l_office_id_bind_str := l_office_id_bind_str || '''' || l_office_id || '''';
         l_office_id          := l_ids.next(l_office_id);
         exit when l_office_id is null;
         l_office_id_bind_str := l_office_id_bind_str || ',';
      end loop;

      l_ids.delete;

      if not l_cwms_matched then
         l_office_id_bind_str := l_office_id_bind_str || ',' || '''CWMS''';
      end if;

      -----------------------------
      -- build ids bind variable --
      -----------------------------
      l_id_mask_tab        := cwms_util.split_text(p_id_masks, p_delimiter);

      for i in 1 .. l_id_mask_tab.count loop
         l_id_mask := cwms_util.normalize_wildcards(upper(l_id_mask_tab(i)), true);
         for rec in (select id
                       from at_clob
                      where id like l_id_mask) loop
            if not l_ids.exists(rec.id) then
               l_ids(rec.id) := true;
            end if;
         end loop;
      end loop;

      l_id                 := l_ids.first;

      loop
         l_id_bind_str := l_id_bind_str || '''' || l_id || '''';
         l_id          := l_ids.next(l_id);
         exit when l_id is null;
         l_id_bind_str := l_id_bind_str || ',';
      end loop;

      l_ids.delete;

      ----------------------------
      -- build the query string --
      ----------------------------
      if l_include_descriptions then
         l_query_str := 
            'select o.office_id,
                    c.id,
                    c.description
               from cwms_office o,
                    at_clob c
              where o.office_id in (:office_ids)
                and c.office_code = o.office_code
                and c.id in (:ids)';
      else
         l_query_str := 
            'select o.office_id,
                    c.id
               from cwms_office o,
                    at_clob c
              where o.office_id in (:office_ids)
                and c.office_code = o.office_code
                and c.id in (:ids)';
      end if;

      l_query_str := replace(l_query_str, ':office_ids', l_office_id_bind_str);
      l_query_str := replace(l_query_str, ':ids', l_id_bind_str);
      cwms_util.check_dynamic_sql(l_query_str);
      -----------------------
      -- perform the query --
      -----------------------
      open p_ids for l_query_str;
   end get_matching_ids;

   --
   -- get matching ids in a delimited clob
   --
   procedure get_matching_ids(
      p_ids                     out clob, -- delimited clob of the matching office ids, text ids, and optionally descriptions
      p_id_masks             in     varchar2 default '%', -- comma-separated list of id masks, defaults to all ids
      p_include_descriptions in     varchar2 default 'F', -- flag specifying whether to retrieve descriptions also
      p_office_id_masks      in     varchar2 default null, -- delimited list of office id masks, defaults to user's office
      p_delimiter            in     varchar2 default ',') -- delimiter for masks, defaults to comma
   is
      type rec1_t is record(
         office_id   varchar2(16),
         id          varchar2(256));

      type rec2_t is record(
         office_id     varchar2(16),
         id            varchar2(256),
         description   varchar2(256));

      l_include_descriptions   boolean := cwms_util.return_true_or_false(p_include_descriptions);
      l_rec1                   rec1_t;
      l_rec2                   rec2_t;
      l_cursor                 sys_refcursor;
      l_ids                    clob;
      l_first                  boolean := true;

      procedure write_clob(p1 varchar2, p2 varchar2)
      is
         l_data   varchar2(32767);
      begin
         if l_first then
            l_data  := p1 || cwms_util.field_separator || p2;
            l_first := false;
         else
            l_data := cwms_util.record_separator || p1 || cwms_util.field_separator || p2;
         end if;

         dbms_lob.writeappend(l_ids, length(l_data), l_data);
      end;

      procedure write_clob(p1 varchar2, p2 varchar2, p3 varchar2)
      is
         l_data   varchar2(32767);
      begin
         if l_first then
            l_data  := p1 || cwms_util.field_separator || p2 || cwms_util.field_separator || p3;
            l_first := false;
         else
            l_data := cwms_util.record_separator || p1 || cwms_util.field_separator || p2 || cwms_util.field_separator || p3;
         end if;

         dbms_lob.writeappend(l_ids, length(l_data), l_data);
      end;
   begin
      get_matching_ids(
         l_cursor,
         p_id_masks,
         p_include_descriptions,
         p_office_id_masks,
         p_delimiter);

      dbms_lob.createtemporary(l_ids, true);
      dbms_lob.open(l_ids, dbms_lob.lob_readwrite);

      loop
         if l_include_descriptions then
            fetch l_cursor into l_rec2;

            exit when l_cursor%notfound;
            write_clob(l_rec2.office_id, l_rec2.id, l_rec2.description);
         else
            fetch l_cursor into l_rec1;

            exit when l_cursor%notfound;
            write_clob(l_rec1.office_id, l_rec1.id);
         end if;
      end loop;

      dbms_lob.close(l_ids);
      p_ids := l_ids;
   end get_matching_ids;

   --
   -- get code for id
   --
   procedure get_text_code(
      p_text_code out number, -- the code for use in foreign keys
      p_id        in varchar2, -- identifier with which to retrieve text (256 chars max)
      p_office_id in varchar2 default null) -- office id, defaults current user's office
   is
      l_office_code        number := cwms_util.get_office_code(p_office_id);
      l_cwms_office_code   number := cwms_util.get_office_code('CWMS');
   begin
      select clob_code
        into p_text_code
        from at_clob
       where office_code in (l_office_code, l_cwms_office_code) and id = upper(p_id);
   end get_text_code;

   --
   -- get code for id
   --
   function get_text_code(
      p_id        in varchar2, -- identifier with which to retrieve text (256 chars max)
      p_office_id in varchar2 default null) -- office id, defaults current user's office
      return number -- the code for use in foreign keys
   is
      l_text_code   number;
   begin
      get_text_code(l_text_code, p_id, p_office_id);
      return l_text_code;
   end get_text_code;

   -------------------------
   -- store standard text --
   -------------------------
   procedure store_std_text(
      p_std_text_id    in varchar2,
      p_std_text       in clob default null,
      p_fail_if_exists in varchar2 default 'T',
      p_office_id      in varchar2 default null)
   is
      l_office_code      number(10);
      l_clob_code        number(10);
      l_office_id        varchar2(16);
      l_std_text_id      varchar2(16);
      l_clob             clob;
      l_exists           boolean;
      l_fail_if_exists   boolean;
      l_rec              at_std_text%rowtype;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_std_text_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_STD_TEXT_ID');
      end if;

      l_std_text_id    := upper(trim(p_std_text_id));
      l_fail_if_exists := cwms_util.return_true_or_false(p_fail_if_exists);
      l_office_code    := cwms_util.get_office_code(p_office_id);

      select office_id
        into l_office_id
        from cwms_office
       where office_code = l_office_code;

      if cwms_util.get_db_office_code(null) != cwms_util.db_office_code_all and l_office_id != cwms_util.user_office_id then
         cwms_err.raise(
            'ERROR',
            'Cannot set standard text for office ('
            || l_office_id
            || ') that is not your default office ('
            || cwms_util.user_office_id
            || ')');
      end if;

      ---------------------------------
      -- determine if already exists --
      ---------------------------------
      begin
         select *
           into l_rec
           from at_std_text
          where office_code in (l_office_code, cwms_util.db_office_code_all) and std_text_id = l_std_text_id;

         l_exists := true;
      exception
         when no_data_found then
            l_exists := false;
      end;

      if l_exists then
         if l_rec.office_code = cwms_util.db_office_code_all and l_office_code != cwms_util.db_office_code_all then
            cwms_err.raise(
               'ERROR',
               'Cannot store standard text for office '
               || l_office_id
               || '; Identifier '
               || l_rec.std_text_id
               || ' is already used by CWMS office');
         end if;

         if l_fail_if_exists then
            cwms_err.raise('ITEM_ALREADY_EXISTS', 'CWMS standard text', l_rec.std_text_id);
         end if;

         ------------------------------
         -- update the standard text --
         ------------------------------
         l_clob_code       := l_rec.clob_code;

         if l_clob_code is null then
            if p_std_text is not null then
               ----------------------
               -- store a new clob --
               ----------------------
               l_rec.clob_code      :=
                  store_text(
                     p_text           => p_std_text,
                     p_id             => '/Standard Text/' || l_std_text_id,
                     p_description    => 'Actual text for standard text identifier ' || l_std_text_id,
                     p_fail_if_exists => 'F',
                     p_office_id      => l_office_id);
            end if;
         else
            if p_std_text is null then
               ------------------------------
               -- delete the existing clob --
               ------------------------------
               delete from at_clob
                     where clob_code = l_clob_code;
            else
               -------------------------------------------
               -- update the existing clob if necessary --
               -------------------------------------------
               select value
                 into l_clob
                 from at_clob
                where clob_code = l_clob_code;

               if dbms_lob.compare(p_std_text, l_clob) != 0 then
                  update at_clob
                     set value = p_std_text
                   where clob_code = l_clob_code;
               end if;
            end if;
         end if;

         -----------------------------------
         -- update the at_std_text record --
         -----------------------------------
         l_rec.std_text_id := l_std_text_id; -- to change case if necessary

         update at_std_text
            set row = l_rec;
      else
         ------------------------------
         -- create new standard text --
         ------------------------------
         if p_std_text is not null then
            ----------------------
            -- store a new clob --
            ----------------------
            l_rec.clob_code      :=
               store_text(
                  p_text           => p_std_text,
                  p_id             => '/Standard Text/' || l_std_text_id,
                  p_description    => 'Actual text for standard text identifier ' || l_std_text_id,
                  p_fail_if_exists => 'F',
                  p_office_id      => l_office_id);
         end if;

         ---------------------------------------
         -- create the new at_std_text record --
         ---------------------------------------
         l_rec.std_text_code := cwms_seq.nextval;
         l_rec.office_code   := l_office_code;
         l_rec.std_text_id   := l_std_text_id;

         insert into at_std_text
              values l_rec;
      end if;
   end store_std_text;

   procedure retrieve_std_text(
      p_std_text    out clob, 
      p_std_text_id in  varchar2, 
      p_office_id   in  varchar2 default null)
   is
   begin
      p_std_text := retrieve_std_text_f(p_std_text_id, p_office_id);
   end retrieve_std_text;

   function retrieve_std_text_f(
      p_std_text_id in varchar2, 
      p_office_id   in varchar2 default null)
      return clob
   is
      l_std_text      clob;
      l_office_code   number(10);
      l_clob_code     number(10);
      l_office_id     varchar2(16);
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_std_text_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_STD_TEXT_ID');
      end if;

      l_office_code := cwms_util.get_office_code(p_office_id);

      -----------------------
      -- get the clob code --
      -----------------------
      begin
         select clob_code
           into l_clob_code
           from at_std_text
          where office_code in (l_office_code, cwms_util.db_office_code_all) and std_text_id = upper(p_std_text_id);
      exception
         when no_data_found then
            select office_id
              into l_office_id
              from cwms_office
             where office_code = l_office_code;

            cwms_err.raise('ITEM_DOES_NOT_EXIST', 'CWMS standard text for office ' || l_office_id, p_std_text_id);
      end;

      ------------------
      -- get the clob --
      ------------------
      if l_clob_code is not null then
         select value
           into l_std_text
           from at_clob
          where clob_code = l_clob_code;
      end if;

      return l_std_text;
   end retrieve_std_text_f;

   procedure delete_std_text(
      p_std_text_id   in varchar2,
      p_delete_action in varchar2 default cwms_util.delete_key,
      p_office_id     in varchar2 default null)
   is
      l_office_code   number(10);
      l_std_text_code number(10);
      l_delete_key    boolean := false;
      l_delete_data   boolean := false;
   begin
      cwms_util.check_office_permission(p_office_id);
      l_office_code := cwms_util.get_db_office_code(p_office_id);
      case upper(trim(p_delete_action))
      when cwms_util.delete_key then
         l_delete_key := true;
      when cwms_util.delete_data then
         l_delete_data := true;
      when cwms_util.delete_all then
         l_delete_key  := true;
         l_delete_data := true;
      else
         cwms_err.raise('INVALID_ITEM', p_delete_action, 'delete action');
      end case;
      
      select std_text_code
        into l_std_text_code
        from at_std_text
       where upper(std_text_id) = upper(trim(p_std_text_id))
         and office_code = l_office_code;
         
      if l_delete_data then
         delete
           from at_tsv_std_text
          where std_text_code = l_std_text_code;    
      end if;
      
      if l_delete_key then
         delete
           from at_std_text
          where std_text_code = l_std_text_code; 
      end if;
      
   end delete_std_text;

   procedure cat_std_text(
      p_cursor              out sys_refcursor,
      p_std_text_id_mask in     varchar2 default '*',
      p_office_id_mask   in     varchar2 default null)
   is
      l_std_text_id_mask varchar2(32);
      l_office_id_mask   varchar2(32);
   begin
      l_std_text_id_mask := cwms_util.normalize_wildcards(upper(trim(p_std_text_id_mask)));
      l_office_id_mask   := cwms_util.normalize_wildcards(upper(trim(p_office_id_mask)));
      open p_cursor for
         select a.office_id,
                a.std_text_id,
                b.value as std_text
           from (select o.office_id,
                        s.std_text_id,
                        s.clob_code
                   from at_std_text s,
                        cwms_office o
                  where o.office_id like l_office_id_mask escape '\'
                    and s.office_code = o.office_code
                    and s.std_text_id like l_office_id_mask escape '\'
                ) a
                left outer join
                (select clob_code,
                        value
                   from at_clob     
                ) b on b.clob_code = a.clob_code;         
   end cat_std_text;

   function cat_std_text_f(
      p_std_text_id_mask in varchar2 default '*', 
      p_office_id_mask   in varchar2 default null)
      return sys_refcursor
   is
      l_cursor sys_refcursor;
   begin
      cat_std_text(
         l_cursor,
         p_std_text_id_mask,
         p_office_id_mask);
         
      return l_cursor;
   end cat_std_text_f;

   procedure store_ts_std_text(
      p_ts_code             in number,
      p_date_time_utc       in date,
      p_version_date_utc    in date,
      p_std_text_code       in number,
      p_data_entry_date_utc in timestamp,
      p_attribute           in number)
   is
      l_rec       at_tsv_std_text%rowtype;
      l_office_id varchar2(16);
   begin
      select db_office_id
        into l_office_id
        from at_cwms_ts_id
       where ts_code = p_ts_code; 
      cwms_util.check_office_permission(l_office_id);
      l_rec.ts_code         := p_ts_code;
      l_rec.date_time       := p_date_time_utc;
      l_rec.version_date    := nvl(p_version_date_utc, cast(p_data_entry_date_utc as date));
      l_rec.std_text_code   := p_std_text_code;
      l_rec.data_entry_date := p_data_entry_date_utc;
      l_rec.attribute       := p_attribute;

      ----------------------------------
      -- see if record already exists --
      ----------------------------------
      select *
        into l_rec
        from at_tsv_std_text
       where ts_code = l_rec.ts_code
         and date_time = l_rec.date_time
         and version_date = l_rec.version_date
         and std_text_code = l_rec.std_text_code;

      ------------------------------------------------
      -- record exists, update it only if necessary --
      ------------------------------------------------
      if l_rec.attribute != p_attribute then
         l_rec.attribute := p_attribute;

         update at_tsv_std_text
            set row = l_rec;
      end if;
   exception
      when no_data_found then
         -------------------------------------
         -- record doesn't exist; create it --
         -------------------------------------
         insert into at_tsv_std_text
              values l_rec;
   end store_ts_std_text;

   procedure store_ts_std_text(
      p_ts_code           in integer,
      p_std_text_code     in integer,
      p_date_times_utc    in date_table_type,
      p_version_dates_utc in date_table_type,
      p_version_date_utc  in date,
      p_max_version       in boolean,
      p_replace_all       in boolean,
      p_attribute         in number)
   is
      l_date_times           date_table_type;
      l_version_dates        date_table_type;
      l_regular_times        date_table_type;
      l_cursor               sys_refcursor;
      l_is_versioned_str     varchar2(1);
      l_is_versioned         boolean;
      l_off_interval_count   integer;
      l_store_date           timestamp := sys_extract_utc(systimestamp);
      l_office_id            varchar2(16);
   begin
      select db_office_id
        into l_office_id
        from at_cwms_ts_id
       where ts_code = p_ts_code; 
      cwms_util.check_office_permission(l_office_id);
      if p_version_dates_utc is null then
         ------------------------------------------------------------
         -- need to validate date/times and retrieve version dates --
         ------------------------------------------------------------
         cwms_ts.is_ts_versioned(l_is_versioned_str, p_ts_code);
         l_is_versioned := cwms_util.return_true_or_false(l_is_versioned_str);

         ------------------------------------------------------
         -- get valid times for regular interval time series --
         ------------------------------------------------------
         begin
            l_regular_times      :=
               cwms_ts.get_times_for_time_window(
                  p_date_times_utc(1),
                  p_date_times_utc(p_date_times_utc.count),
                  p_ts_code,
                  'UTC');
         exception
            when others then
               case
                  when instr(sqlerrm, 'irregular') > 0 then
                     null;
                  when instr(sqlerrm, 'undefined') > 0 then
                     cwms_err.raise(
                        'ERROR',
                        'Cannot set time series text for regular time series with undefined interval offset.');
                  else
                     raise;
               end case;
         end;

         if l_regular_times is not null then
            ---------------------------------------------------------
            -- verify valid times for regular interval time series --
            ---------------------------------------------------------
            select count(*)
              into l_off_interval_count
              from (select column_value from table(p_date_times_utc)
                    minus
                    select column_value from table(l_regular_times));

            if l_off_interval_count > 0 then
               cwms_err.raise(
                  'ERROR',
                  'Times include ' || l_off_interval_count || ' invalid time(s) for specified time series.');
            end if;
         end if;

         l_cursor       :=
            cwms_ts.retrieve_existing_times_f(
               p_ts_code          => p_ts_code,
               p_start_time_utc   => null,
               p_end_time_utc     => null,
               p_date_times_utc   => p_date_times_utc,
               p_version_date_utc => p_version_date_utc,
               p_max_version      => p_max_version);

         loop
            fetch l_cursor
            bulk collect into l_date_times, l_version_dates
            limit 50000;

            exit when l_date_times.count = 0;

            for i in 1 .. l_date_times.count loop
               ------------------------------------------------
               -- delete existing standard text if necessary --
               ------------------------------------------------
               if p_replace_all then
                  begin
                     delete from at_tsv_std_text
                           where ts_code = p_ts_code and date_time = l_date_times(i) and version_date = l_version_dates(i);
                  exception
                     when no_data_found then
                        null;
                  end;
               end if;

               -----------------------------------------------------
               -- store the standard text for existing date_times --
               -----------------------------------------------------
               store_ts_std_text(
                  p_ts_code,
                  l_date_times(i),
                  l_version_dates(i),
                  p_std_text_code,
                  l_store_date,
                  p_attribute);
            end loop;
         end loop;

         close l_cursor;

         ---------------------------------------------------------
         -- store the standard text for non-existing date_times --
         ---------------------------------------------------------
         l_cursor       := null;
         l_date_times.delete;

         loop
            if l_cursor is null then
               open l_cursor for
                  select column_value
                    from table(p_date_times_utc)
                   where column_value not in (select date_time
                                                from cwms_v_tsv
                                               where ts_code = p_ts_code);
            else
               l_date_times.delete;
            end if;

            fetch l_cursor
            bulk collect into l_date_times
            limit 50000;

            exit when l_date_times.count = 0;

            for i in 1 .. l_date_times.count loop
               store_ts_std_text(
                  p_ts_code,
                  l_date_times(i),
                  case p_version_date_utc is null
                     when true then case l_is_versioned when true then null else cwms_util.non_versioned end
                     else p_version_date_utc
                  end,
                  p_std_text_code,
                  l_store_date,
                  p_attribute);
            end loop;
         end loop;

         close l_cursor;
      else
         -----------------------------------------
         -- valid dates/times already retrieved --
         -----------------------------------------
         for i in 1 .. p_date_times_utc.count loop
            store_ts_std_text(
               p_ts_code,
               p_date_times_utc(i),
               p_version_dates_utc(i),
               p_std_text_code,
               l_store_date,
               p_attribute);
         end loop;
      end if;
   end store_ts_std_text;

   procedure store_ts_std_text(
      p_tsid         in varchar2,
      p_std_text_id  in varchar2,
      p_start_time   in date,
      p_end_time     in date default null,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_existing     in varchar2 default 'T',
      p_non_existing in varchar2 default 'F',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_std_text_code      number(10);
      l_start_time_utc     date;
      l_end_time_utc       date := sysdate;
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_existing           boolean;
      l_non_existing       boolean;
      l_is_versioned       boolean;
      l_is_regular         boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
      l_version_id         varchar2(32);
      l_cursor             sys_refcursor;
      l_store_date         timestamp := cast(systimestamp at time zone 'UTC' as timestamp);
      l_date_times         date_table_type;
      l_version_dates      date_table_type;
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_std_text_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_STD_TEXT_ID');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      if p_version_date = cwms_util.all_version_dates then
         cwms_err.raise('ERROR', 'Cannot specify all version dates in this call.');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_max_version    := cwms_util.return_true_or_false(p_max_version);
      l_existing       := cwms_util.return_true_or_false(p_existing);
      l_non_existing   := cwms_util.return_true_or_false(p_non_existing);
      l_replace_all    := cwms_util.return_true_or_false(p_replace_all);
      l_office_id      := cwms_util.get_db_office_id(p_office_id);

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      l_tsid           := cwms_ts.get_ts_id(p_tsid, l_office_code);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is not null then
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      l_is_regular     := cwms_ts.get_ts_interval(l_tsid) > 0;

      if l_is_regular and not l_existing and not l_non_existing then
         return;
      end if;

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            ----------------------------------------------------------------
            -- time series doesn't exist - abort on irregular time series --
            ----------------------------------------------------------------
            if not l_is_regular then
               cwms_err.raise(
                  'ERROR',
                  'Cannot use this version of STORE_TS_STD_TEXT to store text to a non-existent irregular time series');
            end if;

            ----------------------------------------------------------------------------------------
            -- don't create regular time series if we're not going to store to non-existing times --
            ----------------------------------------------------------------------------------------
            if not l_non_existing then
               return;
            end if;

            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the start time --
            -----------------------------------------------------------------------------------------
            cwms_ts.create_ts_code(
               p_ts_code    => l_ts_code,
               p_office_id  => l_office_id,
               p_cwms_ts_id => l_tsid,
               p_utc_offset => cwms_ts.get_utc_interval_offset(l_start_time_utc, cwms_ts.get_ts_interval(l_tsid)));
      end;

      l_is_versioned   := cwms_util.return_true_or_false(cwms_ts.is_tsid_versioned_f(l_tsid, l_office_id));

      begin
         select std_text_code
           into l_std_text_code
           from at_std_text
          where office_code in (l_office_code, cwms_util.db_office_code_all) and std_text_id = upper(trim(p_std_text_id));
      exception
         when no_data_found then
            cwms_err.raise('ITEM_DOES_NOT_EXIST', 'CWMS standard text for office ' || l_office_id, p_std_text_id);
      end;

      ------------------------
      -- get the date/times --
      ------------------------
      if l_is_regular then
         -------------------------
         -- regular time series --
         -------------------------
         if l_non_existing then
            if l_existing then
               ----------------------------------------------
               -- store to existing and non-existing times --
               ----------------------------------------------
               l_date_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
            else
               --------------------------------------
               -- store to non-existing times only --
               --------------------------------------
               declare
                  l_regular_times    date_table_type;
                  l_existing_times   date_table_type;
               begin
                  l_regular_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
                  l_cursor        :=
                     cwms_ts.retrieve_existing_times_f(
                        l_ts_code,
                        l_start_time_utc,
                        l_end_time_utc,
                        null,
                        l_version_date_utc,
                        l_max_version);

                  fetch l_cursor
                  bulk collect into l_existing_times, l_version_dates;

                  close l_cursor;

                    select column_value
                      bulk collect into l_date_times
                      from (select column_value from table(l_regular_times)
                            minus
                            select column_value from table(l_existing_times))
                  order by column_value;
               end;
            end if;
         else
            ----------------------------------
            -- store to existing times only --
            ----------------------------------
            l_cursor      :=
               cwms_ts.retrieve_existing_times_f(
                  l_ts_code,
                  l_start_time_utc,
                  l_end_time_utc,
                  null,
                  l_version_date_utc,
                  l_max_version);

            fetch l_cursor
            bulk collect into l_date_times, l_version_dates;

            close l_cursor;
         end if;
      else
         ---------------------------
         -- irregular time series --
         ---------------------------
         l_cursor      :=
            cwms_ts.retrieve_existing_times_f(
               l_ts_code,
               l_start_time_utc,
               l_end_time_utc,
               null,
               l_version_date_utc,
               l_max_version);

         fetch l_cursor
         bulk collect into l_date_times, l_version_dates;

         close l_cursor;
      end if;

      --------------------
      -- store the text --
      --------------------
      store_ts_std_text(
         l_ts_code,
         l_std_text_code,
         l_date_times,
         l_version_dates,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_std_text;

   procedure store_ts_std_text(
      p_tsid         in varchar2,
      p_std_text_id  in varchar2,
      p_times        in date_table_type,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_std_text_id        varchar2(16);
      l_std_text_code      number(10);
      l_times_utc          date_table_type := date_table_type();
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_is_versioned       boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
   begin
      cwms_util.check_office_permission(p_office_id);
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_std_text_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_STD_TEXT_ID');
      end if;

      if p_times is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TIMES');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id   := cwms_util.get_db_office_id(p_office_id);
      l_tsid        := cwms_ts.get_ts_id(p_tsid, l_office_id);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_std_text_id := trim(upper(p_std_text_id));
      l_replace_all := cwms_util.return_true_or_false(p_replace_all);
      l_max_version := cwms_util.return_true_or_false(p_max_version);

      begin
         select std_text_code
           into l_std_text_code
           from at_std_text
          where office_code in (l_office_code, cwms_util.db_office_code_all) and std_text_id = l_std_text_id;
      exception
         when no_data_found then
            cwms_err.raise('ITEM_DOES_NOT_EXIST', 'CWMS standard text for office ' || l_office_id, p_std_text_id);
      end;

      l_times_utc.extend(p_times.count);

      for i in 1 .. p_times.count loop
         l_times_utc(i) := cwms_util.change_timezone(p_times(i), l_time_zone, 'UTC');
      end loop;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the first time --
            -----------------------------------------------------------------------------------------
            if cwms_ts.get_ts_interval(l_tsid) > 0 then
               cwms_ts.create_ts_code(
                  p_ts_code    => l_ts_code,
                  p_office_id  => l_office_id,
                  p_cwms_ts_id => l_tsid,
                  p_utc_offset => cwms_ts.get_utc_interval_offset(l_times_utc(1), cwms_ts.get_ts_interval(l_tsid)));
            else
               cwms_ts.create_ts_code(p_ts_code => l_ts_code, p_office_id => l_office_id, p_cwms_ts_id => l_tsid);
            end if;
      end;

      --------------------
      -- store the text --
      --------------------
      store_ts_std_text(
         l_ts_code,
         l_std_text_code,
         l_times_utc,
         null,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_std_text;

   procedure retrieve_ts_std_text(
      p_cursor              out sys_refcursor,
      p_tsid             in     varchar2,
      p_std_text_id_mask in     varchar2,
      p_start_time       in     date,
      p_end_time         in     date default null,
      p_version_date     in     date default null,
      p_time_zone        in     varchar2 default null,
      p_max_version      in     varchar2 default 'T',
      p_retrieve_text    in     varchar2 default 'T',
      p_min_attribute    in     number default null,
      p_max_attribute    in     number default null,
      p_office_id        in     varchar2 default null)
   is
   begin
      p_cursor      :=
         retrieve_ts_std_text_f(
            p_tsid,
            p_std_text_id_mask,
            p_start_time,
            p_end_time,
            p_version_date,
            p_time_zone,
            p_max_version,
            p_retrieve_text,
            p_min_attribute,
            p_max_attribute,
            p_office_id);
   end retrieve_ts_std_text;

   function retrieve_ts_std_text_f(
      p_tsid             in varchar2,
      p_std_text_id_mask in varchar2,
      p_start_time       in date,
      p_end_time         in date default null,
      p_version_date     in date default null,
      p_time_zone        in varchar2 default null,
      p_max_version      in varchar2 default 'T',
      p_retrieve_text    in varchar2 default 'T',
      p_min_attribute    in number default null,
      p_max_attribute    in number default null,
      p_office_id        in varchar2 default null)
      return sys_refcursor
   is
      l_office_id            varchar2(16);
      l_tsid                 varchar2(183);
      l_std_text_id_mask     varchar2(256);
      l_start_time_utc       date;
      l_end_time_utc         date;
      l_version_date_utc     date;
      l_time_zone            varchar2(28);
      l_ts_code              number(10);
      l_cursor               sys_refcursor;
      l_date_time_versions   date2_tab_t;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_std_text_id_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_STD_TEXT_ID_MASK');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id        := cwms_util.get_db_office_id(p_office_id);
      l_tsid             := cwms_ts.get_ts_id(p_tsid, l_office_id);
      l_ts_code          := cwms_ts.get_ts_code(l_tsid, l_office_id);
      l_std_text_id_mask := cwms_util.normalize_wildcards(p_std_text_id_mask);
      l_time_zone        :=
         nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      l_start_time_utc   := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is null then
         l_end_time_utc := l_start_time_utc;
      else
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      -----------------------------------------
      -- get the existing times and versions --
      -----------------------------------------
      l_date_time_versions      :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        p_ts_code          => l_ts_code,
                        p_start_time_utc   => l_start_time_utc,
                        p_end_time_utc     => l_end_time_utc,
                        p_date_times_utc   => null,
                        p_version_date_utc => l_version_date_utc,
                        p_max_version      => cwms_util.return_true_or_false(p_max_version)));

      ------------------
      -- get the text --
      ------------------
      if cwms_util.return_true_or_false(p_retrieve_text) then
         -------------------
         -- with the clob --
         -------------------
         open l_cursor for
              select cwms_util.change_timezone(d.date_1, 'UTC', l_time_zone) as date_time,
                     cwms_util.change_timezone(d.date_2, 'UTC', case 
                                                                when d.date_2 = cwms_util.non_versioned then 'UTC' 
                                                                else l_time_zone 
                                                                end) as version_date,
                     cwms_util.change_timezone(t.data_entry_date, 'UTC', l_time_zone) as data_entry_date,
                     s.std_text_id,
                     t.attribute,
                     c.value as std_text
                from table(l_date_time_versions) d,
                     at_tsv_std_text t,
                     at_std_text s,
                     at_clob c
               where t.ts_code = l_ts_code
                 and t.date_time = d.date_1
                 and t.version_date = d.date_2
                 and t.std_text_code = s.std_text_code
                 and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
                   or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
                 and upper(s.std_text_id) like upper(l_std_text_id_mask) escape '\'
                 and c.clob_code = s.clob_code
            order by d.date_1,
                     d.date_2,
                     t.attribute,
                     t.data_entry_date;
      else
         ----------------------
         -- without the clob --
         ----------------------
         open l_cursor for
              select cwms_util.change_timezone(d.date_1, 'UTC', l_time_zone) as date_time,
                     cwms_util.change_timezone(d.date_2, 'UTC', case 
                                                                when d.date_2 = cwms_util.non_versioned then 'UTC' 
                                                                else l_time_zone 
                                                                end) as version_date,
                     cwms_util.change_timezone(t.data_entry_date, 'UTC', l_time_zone) as data_entry_date,
                     s.std_text_id,
                     t.attribute
                from table(l_date_time_versions) d, at_tsv_std_text t, at_std_text s
               where t.ts_code = l_ts_code
                 and t.date_time = d.date_1
                 and t.version_date = d.date_2
                 and t.std_text_code = s.std_text_code
                 and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
                   or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
                 and upper(s.std_text_id) like upper(l_std_text_id_mask) escape '\'
            order by d.date_1,
                     d.date_2,
                     t.attribute,
                     t.data_entry_date;
      end if;

      return l_cursor;
   end retrieve_ts_std_text_f;

   function get_ts_std_text_count(
      p_tsid             in varchar2,
      p_std_text_id_mask in varchar2,
      p_start_time       in date,
      p_end_time         in date default null,
      p_date_times       in date_table_type default null,
      p_version_date     in date default null,
      p_time_zone        in varchar2 default null,
      p_max_version      in varchar2 default 'T',
      p_min_attribute    in number default null,
      p_max_attribute    in number default null,
      p_office_id        in varchar2 default null)
      return pls_integer
   is
      l_office_id          varchar2(16);
      l_tsid               varchar2(183);
      l_std_text_id_mask   varchar2(16);
      l_start_time_utc     date;
      l_end_time_utc       date;
      l_date_times_utc     date_table_type;
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_max_version        boolean;
      l_office_code        number(10);
      l_ts_code            number(10);
      l_times_utc          date2_tab_t;
      l_count              pls_integer;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_std_text_id_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_STD_TEXT_ID_MASK');
      end if;

      if p_start_time is null and p_date_times is null then
         cwms_err.raise('ERROR', 'One of P_START_TIME or P_DATE_TIMES must be non-NULL');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_max_version      := cwms_util.return_true_or_false(p_max_version);
      l_std_text_id_mask := cwms_util.normalize_wildcards(p_std_text_id_mask);
      l_office_id        := cwms_util.get_db_office_id(p_office_id);

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      l_tsid             := cwms_ts.get_ts_id(p_tsid, l_office_code);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      if p_start_time is not null then
         l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');
      end if;

      if p_end_time is not null then
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_date_times is not null then
         l_date_times_utc := date_table_type();
         l_date_times_utc.extend(p_date_times.count);

         for i in 1 .. p_date_times.count loop
            l_date_times_utc(i) := cwms_util.change_timezone(p_date_times(i), l_time_zone, 'UTC');
         end loop;
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      l_ts_code          := cwms_ts.get_ts_code(l_tsid, l_office_code);

      l_times_utc        :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        l_ts_code,
                        l_start_time_utc,
                        l_end_time_utc,
                        l_date_times_utc,
                        l_version_date_utc,
                        l_max_version,
                        cwms_util.ts_std_text));

      select count(*)
        into l_count
        from at_tsv_std_text t, at_std_text s, table(l_times_utc) d
       where t.ts_code = l_ts_code
         and t.date_time = d.date_1
         and t.version_date = d.date_2
         and t.std_text_code = s.std_text_code
         and upper(s.std_text_id) like upper(l_std_text_id_mask) escape '\'
         and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
           or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute));

      l_times_utc.delete;
      return l_count;
   end get_ts_std_text_count;

   procedure delete_ts_std_text(
      p_tsid             in varchar2,
      p_std_text_id_mask in varchar2,
      p_start_time       in date,
      p_end_time         in date default null,
      p_version_date     in date default null,
      p_time_zone        in varchar2 default null,
      p_max_version      in varchar2 default 'T',
      p_min_attribute    in number default null,
      p_max_attribute    in number default null,
      p_office_id        in varchar2 default null)
   is
      l_office_id            varchar2(16);
      l_tsid                 varchar2(183);
      l_std_text_id_mask     varchar2(256);
      l_start_time_utc       date;
      l_end_time_utc         date;
      l_version_date_utc     date;
      l_time_zone            varchar2(28);
      l_ts_code              number(10);
      l_date_time_versions   date2_tab_t := date2_tab_t();
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_std_text_id_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_STD_TEXT_ID_MASK');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id        := cwms_util.get_db_office_id(p_office_id);
      l_tsid             := cwms_ts.get_ts_id(p_tsid, l_office_id);
      l_ts_code          := cwms_ts.get_ts_code(l_tsid, l_office_id);
      l_std_text_id_mask := cwms_util.normalize_wildcards(p_std_text_id_mask);
      l_time_zone        :=
         nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      l_start_time_utc   := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is null then
         l_end_time_utc := l_start_time_utc;
      else
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      -----------------------------------------
      -- get the existing times and versions --
      -----------------------------------------
      l_date_time_versions      :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        p_ts_code          => l_ts_code,
                        p_start_time_utc   => l_start_time_utc,
                        p_end_time_utc     => l_end_time_utc,
                        p_date_times_utc   => null,
                        p_version_date_utc => l_version_date_utc,
                        p_max_version      => cwms_util.return_true_or_false(p_max_version)));

      delete from at_tsv_std_text
            where rowid in
                     (select t.rowid
                        from table(l_date_time_versions) d, at_tsv_std_text t, at_std_text s
                       where t.ts_code = l_ts_code
                         and t.date_time = d.date_1
                         and t.version_date = d.date_2
                         and t.std_text_code = s.std_text_code
                         and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
                           or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
                         and upper(s.std_text_id) like upper(l_std_text_id_mask) escape '\');

      l_date_time_versions.delete;
   end delete_ts_std_text;

   procedure store_ts_text(
      p_ts_code             in number,
      p_date_time_utc       in date,
      p_version_date_utc    in date,
      p_clob_code           in number,
      p_data_entry_date_utc in timestamp,
      p_attribute           in number)
   is
      l_rec       at_tsv_text%rowtype;
      l_office_id varchar2(16);
   begin
      select db_office_id
        into l_office_id
        from at_cwms_ts_id
       where ts_code = p_ts_code; 
      cwms_util.check_office_permission(l_office_id);
      l_rec.ts_code         := p_ts_code;
      l_rec.date_time       := p_date_time_utc;
      l_rec.version_date    := nvl(p_version_date_utc, cast(p_data_entry_date_utc as date));
      l_rec.clob_code       := p_clob_code;
      l_rec.data_entry_date := p_data_entry_date_utc;
      l_rec.attribute       := p_attribute;

      ----------------------------------
      -- see if record already exists --
      ----------------------------------
      select *
        into l_rec
        from at_tsv_text
       where ts_code = l_rec.ts_code
         and date_time = l_rec.date_time
         and version_date = l_rec.version_date
         and clob_code = l_rec.clob_code;

      ------------------------------------------------
      -- record exists, update it only if necessary --
      ------------------------------------------------
      if l_rec.attribute != p_attribute then
         l_rec.attribute := p_attribute;

         update at_tsv_text
            set row = l_rec;
      end if;
   exception
      when no_data_found then
         -------------------------------------
         -- record doesn't exist; create it --
         -------------------------------------
         insert into at_tsv_text
              values l_rec;
   end store_ts_text;

   procedure store_ts_text(
      p_ts_code           in integer,
      p_clob_code         in integer,
      p_date_times_utc    in date_table_type,
      p_version_dates_utc in date_table_type,
      p_version_date_utc  in date,
      p_max_version       in boolean,
      p_replace_all       in boolean,
      p_attribute         in number)
   is
      l_date_times           date_table_type;
      l_version_dates        date_table_type;
      l_regular_times        date_table_type;
      l_cursor               sys_refcursor;
      l_is_versioned_str     varchar2(1);
      l_is_versioned         boolean;
      l_off_interval_count   integer;
      l_store_date           timestamp := sys_extract_utc(systimestamp);
      l_office_id            varchar2(16);
   begin
      select db_office_id
        into l_office_id
        from at_cwms_ts_id
       where ts_code = p_ts_code; 
      cwms_util.check_office_permission(l_office_id);
      if p_version_dates_utc is null then
         ------------------------------------------------------------
         -- need to validate date/times and retrieve version dates --
         ------------------------------------------------------------
         cwms_ts.is_ts_versioned(l_is_versioned_str, p_ts_code);
         l_is_versioned := cwms_util.return_true_or_false(l_is_versioned_str);

         ------------------------------------------------------
         -- get valid times for regular interval time series --
         ------------------------------------------------------
         begin
            l_regular_times      :=
               cwms_ts.get_times_for_time_window(
                  p_date_times_utc(1),
                  p_date_times_utc(p_date_times_utc.count),
                  p_ts_code,
                  'UTC');
         exception
            when others then
               case
                  when instr(sqlerrm, 'irregular') > 0 then
                     null;
                  when instr(sqlerrm, 'undefined') > 0 then
                     cwms_err.raise(
                        'ERROR',
                        'Cannot set time series text for regular time series with undefined interval offset.');
                  else
                     raise;
               end case;
         end;

         if l_regular_times is not null then
            ---------------------------------------------------------
            -- verify valid times for regular interval time series --
            ---------------------------------------------------------
            select count(*)
              into l_off_interval_count
              from (select column_value from table(p_date_times_utc)
                    minus
                    select column_value from table(l_regular_times));

            if l_off_interval_count > 0 then
               cwms_err.raise(
                  'ERROR',
                  'Times include ' || l_off_interval_count || ' invalid time(s) for specified time series.');
            end if;
         end if;

         l_cursor       :=
            cwms_ts.retrieve_existing_times_f(
               p_ts_code          => p_ts_code,
               p_start_time_utc   => null,
               p_end_time_utc     => null,
               p_date_times_utc   => p_date_times_utc,
               p_version_date_utc => p_version_date_utc,
               p_max_version      => p_max_version);

         loop
            fetch l_cursor
            bulk collect into l_date_times, l_version_dates
            limit 50000;

            exit when l_date_times.count = 0;

            for i in 1 .. l_date_times.count loop
               ---------------------------------------
               -- delete existing text if necessary --
               ---------------------------------------
               if p_replace_all then
                  begin
                     delete from at_tsv_text
                           where ts_code = p_ts_code and date_time = l_date_times(i) and version_date = l_version_dates(i);
                  exception
                     when no_data_found then
                        null;
                  end;
               end if;

               --------------------------------------------
               -- store the text for existing date_times --
               --------------------------------------------
               store_ts_text(
                  p_ts_code,
                  l_date_times(i),
                  l_version_dates(i),
                  p_clob_code,
                  l_store_date,
                  p_attribute);
            end loop;
         end loop;

         close l_cursor;

         ------------------------------------------------
         -- store the text for non-existing date_times --
         ------------------------------------------------
         l_cursor       := null;
         l_date_times.delete;

         loop
            if l_cursor is null then
               open l_cursor for
                  select column_value
                    from table(p_date_times_utc)
                   where column_value not in (select date_time
                                                from cwms_v_tsv
                                               where ts_code = p_ts_code);
            else
               l_date_times.delete;
            end if;

            fetch l_cursor
            bulk collect into l_date_times
            limit 50000;

            exit when l_date_times.count = 0;

            for i in 1 .. l_date_times.count loop
               store_ts_text(
                  p_ts_code,
                  l_date_times(i),
                  case p_version_date_utc is null
                     when true then case l_is_versioned when true then null else cwms_util.non_versioned end
                     else p_version_date_utc
                  end,
                  p_clob_code,
                  l_store_date,
                  p_attribute);
            end loop;
         end loop;

         close l_cursor;
      else
         -----------------------------------------
         -- valid dates/times already retrieved --
         -----------------------------------------
         for i in 1 .. p_date_times_utc.count loop
            ---------------------------------------
            -- delete existing text if necessary --
            ---------------------------------------
            if p_replace_all then
               begin
                  delete from at_tsv_text
                        where ts_code = p_ts_code and date_time = p_date_times_utc(i) and version_date = p_version_dates_utc(i);
               exception
                  when no_data_found then
                     null;
               end;
            end if;
            store_ts_text(
               p_ts_code,
               p_date_times_utc(i),
               p_version_dates_utc(i),
               p_clob_code,
               l_store_date,
               p_attribute);
         end loop;
      end if;
   end store_ts_text;

   procedure store_ts_text(
      p_tsid         in varchar2,
      p_text         in clob,
      p_start_time   in date,
      p_end_time     in date default null,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_existing     in varchar2 default 'T',
      p_non_existing in varchar2 default 'F',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_clob_code          number(10);
      l_start_time_utc     date;
      l_end_time_utc       date := sysdate;
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_existing           boolean;
      l_non_existing       boolean;
      l_is_versioned       boolean;
      l_is_regular         boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
      l_version_id         varchar2(32);
      l_cursor             sys_refcursor;
      l_store_date         timestamp := cast(systimestamp at time zone 'UTC' as timestamp);
      l_date_times         date_table_type;
      l_version_dates      date_table_type;
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_text is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TEXT');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      if p_version_date = cwms_util.all_version_dates then
         cwms_err.raise('ERROR', 'Cannot specify all version dates in this call.');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_max_version    := cwms_util.return_true_or_false(p_max_version);
      l_existing       := cwms_util.return_true_or_false(p_existing);
      l_non_existing   := cwms_util.return_true_or_false(p_non_existing);
      l_replace_all    := cwms_util.return_true_or_false(p_replace_all);
      l_office_id      := cwms_util.get_db_office_id(p_office_id);

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      l_tsid           := cwms_ts.get_ts_id(p_tsid, l_office_code);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is not null then
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      l_is_regular     := cwms_ts.get_ts_interval(l_tsid) > 0;

      if l_is_regular and not l_existing and not l_non_existing then
         return;
      end if;

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            ----------------------------------------------------------------
            -- time series doesn't exist - abort on irregular time series --
            ----------------------------------------------------------------
            if not l_is_regular then
               cwms_err.raise(
                  'ERROR',
                  'Cannot use this version of STORE_TS_TEXT to store text to a non-existent irregular time series');
            end if;

            ----------------------------------------------------------------------------------------
            -- don't create regular time series if we're not going to store to non-existing times --
            ----------------------------------------------------------------------------------------
            if not l_non_existing then
               return;
            end if;

            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the start time --
            -----------------------------------------------------------------------------------------
            cwms_ts.create_ts_code(
               p_ts_code    => l_ts_code,
               p_office_id  => l_office_id,
               p_cwms_ts_id => l_tsid,
               p_utc_offset => cwms_ts.get_utc_interval_offset(l_start_time_utc, cwms_ts.get_ts_interval(l_tsid)));
      end;

      l_is_versioned   := cwms_util.return_true_or_false(cwms_ts.is_tsid_versioned_f(l_tsid, l_office_id));

      l_clob_code      := cwms_seq.nextval;

      insert into at_clob
           values (
                     l_clob_code,
                     l_office_code,
                     '/TIME SERIES TEXT/' || l_clob_code,
                     null,
                     p_text);

      ------------------------
      -- get the date/times --
      ------------------------
      if l_is_regular then
         -------------------------
         -- regular time series --
         -------------------------
         if l_non_existing then
            if l_existing then
               ----------------------------------------------
               -- store to existing and non-existing times --
               ----------------------------------------------
               l_date_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
            else
               --------------------------------------
               -- store to non-existing times only --
               --------------------------------------
               declare
                  l_regular_times    date_table_type;
                  l_existing_times   date_table_type;
               begin
                  l_regular_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
                  l_cursor        :=
                     cwms_ts.retrieve_existing_times_f(
                        l_ts_code,
                        l_start_time_utc,
                        l_end_time_utc,
                        null,
                        l_version_date_utc,
                        l_max_version);

                  fetch l_cursor
                  bulk collect into l_existing_times, l_version_dates;

                  close l_cursor;

                    select column_value
                      bulk collect into l_date_times
                      from (select column_value from table(l_regular_times)
                            minus
                            select column_value from table(l_existing_times))
                  order by column_value;
               end;
            end if;
         else
            ----------------------------------
            -- store to existing times only --
            ----------------------------------
            l_cursor      :=
               cwms_ts.retrieve_existing_times_f(
                  l_ts_code,
                  l_start_time_utc,
                  l_end_time_utc,
                  null,
                  l_version_date_utc,
                  l_max_version);

            fetch l_cursor
            bulk collect into l_date_times, l_version_dates;

            close l_cursor;
         end if;
      else
         ---------------------------
         -- irregular time series --
         ---------------------------
         l_cursor      :=
            cwms_ts.retrieve_existing_times_f(
               l_ts_code,
               l_start_time_utc,
               l_end_time_utc,
               null,
               l_version_date_utc,
               l_max_version);

         fetch l_cursor
         bulk collect into l_date_times, l_version_dates;

         close l_cursor;
      end if;

      --------------------
      -- store the text --
      --------------------
      store_ts_text(
         l_ts_code,
         l_clob_code,
         l_date_times,
         l_version_dates,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_text;

   procedure store_ts_text(
      p_tsid         in varchar2,
      p_text         in clob,
      p_times        in date_table_type,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_clob_code          number(10);
      l_times_utc          date_table_type := date_table_type();
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_is_versioned       boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
   begin
      cwms_util.check_office_permission(p_office_id);
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_text is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TEXT');
      end if;

      if p_times is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TIMES');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id   := cwms_util.get_db_office_id(p_office_id);
      l_office_code := cwms_util.get_db_office_code(l_office_id);
      l_tsid        := cwms_ts.get_ts_id(p_tsid, l_office_id);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_replace_all := cwms_util.return_true_or_false(p_replace_all);
      l_max_version := cwms_util.return_true_or_false(p_max_version);

      l_clob_code   := cwms_seq.nextval;

      insert into at_clob
           values (
                     l_clob_code,
                     l_office_code,
                     '/TIME SERIES TEXT/' || l_clob_code,
                     null,
                     p_text);

      l_times_utc.extend(p_times.count);

      for i in 1 .. p_times.count loop
         l_times_utc(i) := cwms_util.change_timezone(p_times(i), l_time_zone, 'UTC');
      end loop;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the first time --
            -----------------------------------------------------------------------------------------
            if cwms_ts.get_ts_interval(l_tsid) > 0 then
               cwms_ts.create_ts_code(
                  p_ts_code    => l_ts_code,
                  p_office_id  => l_office_id,
                  p_cwms_ts_id => l_tsid,
                  p_utc_offset => cwms_ts.get_utc_interval_offset(l_times_utc(1), cwms_ts.get_ts_interval(l_tsid)));
            else
               cwms_ts.create_ts_code(p_ts_code => l_ts_code, p_office_id => l_office_id, p_cwms_ts_id => l_tsid);
            end if;
      end;

      --------------------
      -- store the text --
      --------------------
      store_ts_text(
         l_ts_code,
         l_clob_code,
         l_times_utc,
         null,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_text;

   procedure store_ts_text_id(
      p_tsid         in varchar2,
      p_text_id      in varchar2,
      p_start_time   in date,
      p_end_time     in date default null,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_existing     in varchar2 default 'T',
      p_non_existing in varchar2 default 'F',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_clob_code          number(10);
      l_start_time_utc     date;
      l_end_time_utc       date := sysdate;
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_existing           boolean;
      l_non_existing       boolean;
      l_is_versioned       boolean;
      l_is_regular         boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
      l_version_id         varchar2(32);
      l_cursor             sys_refcursor;
      l_store_date         timestamp := cast(systimestamp at time zone 'UTC' as timestamp);
      l_date_times         date_table_type;
      l_version_dates      date_table_type;
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_text_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TEXT_ID');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      if p_version_date = cwms_util.all_version_dates then
         cwms_err.raise('ERROR', 'Cannot specify all version dates in this call.');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_max_version    := cwms_util.return_true_or_false(p_max_version);
      l_existing       := cwms_util.return_true_or_false(p_existing);
      l_non_existing   := cwms_util.return_true_or_false(p_non_existing);
      l_replace_all    := cwms_util.return_true_or_false(p_replace_all);
      l_office_id      := cwms_util.get_db_office_id(p_office_id);

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      select clob_code
        into l_clob_code
        from at_clob
       where office_code = l_office_code and id = upper(trim(p_text_id));

      l_tsid           := cwms_ts.get_ts_id(p_tsid, l_office_code);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is not null then
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      l_is_regular     := cwms_ts.get_ts_interval(l_tsid) > 0;

      if l_is_regular and not l_existing and not l_non_existing then
         return;
      end if;

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            ----------------------------------------------------------------
            -- time series doesn't exist - abort on irregular time series --
            ----------------------------------------------------------------
            if not l_is_regular then
               cwms_err.raise(
                  'ERROR',
                  'Cannot use this version of STORE_TS_TEXT to store text to a non-existent irregular time series');
            end if;

            ----------------------------------------------------------------------------------------
            -- don't create regular time series if we're not going to store to non-existing times --
            ----------------------------------------------------------------------------------------
            if not l_non_existing then
               return;
            end if;

            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the start time --
            -----------------------------------------------------------------------------------------
            cwms_ts.create_ts_code(
               p_ts_code    => l_ts_code,
               p_office_id  => l_office_id,
               p_cwms_ts_id => l_tsid,
               p_utc_offset => cwms_ts.get_utc_interval_offset(l_start_time_utc, cwms_ts.get_ts_interval(l_tsid)));
      end;

      l_is_versioned   := cwms_util.return_true_or_false(cwms_ts.is_tsid_versioned_f(l_tsid, l_office_id));

      ------------------------
      -- get the date/times --
      ------------------------
      if l_is_regular then
         -------------------------
         -- regular time series --
         -------------------------
         if l_non_existing then
            if l_existing then
               ----------------------------------------------
               -- store to existing and non-existing times --
               ----------------------------------------------
               l_date_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
            else
               --------------------------------------
               -- store to non-existing times only --
               --------------------------------------
               declare
                  l_regular_times    date_table_type;
                  l_existing_times   date_table_type;
               begin
                  l_regular_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
                  l_cursor        :=
                     cwms_ts.retrieve_existing_times_f(
                        l_ts_code,
                        l_start_time_utc,
                        l_end_time_utc,
                        null,
                        l_version_date_utc,
                        l_max_version);

                  fetch l_cursor
                  bulk collect into l_existing_times, l_version_dates;

                  close l_cursor;

                    select column_value
                      bulk collect into l_date_times
                      from (select column_value from table(l_regular_times)
                            minus
                            select column_value from table(l_existing_times))
                  order by column_value;
               end;
            end if;
         else
            ----------------------------------
            -- store to existing times only --
            ----------------------------------
            l_cursor      :=
               cwms_ts.retrieve_existing_times_f(
                  l_ts_code,
                  l_start_time_utc,
                  l_end_time_utc,
                  null,
                  l_version_date_utc,
                  l_max_version);

            fetch l_cursor
            bulk collect into l_date_times, l_version_dates;

            close l_cursor;
         end if;
      else
         ---------------------------
         -- irregular time series --
         ---------------------------
         l_cursor      :=
            cwms_ts.retrieve_existing_times_f(
               l_ts_code,
               l_start_time_utc,
               l_end_time_utc,
               null,
               l_version_date_utc,
               l_max_version);

         fetch l_cursor
         bulk collect into l_date_times, l_version_dates;

         close l_cursor;
      end if;

      --------------------
      -- store the text --
      --------------------
      store_ts_text(
         l_ts_code,
         l_clob_code,
         l_date_times,
         l_version_dates,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_text_id;

   procedure store_ts_text_id(
      p_tsid         in varchar2,
      p_text_id      in varchar2,
      p_times        in date_table_type,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_clob_code          number(10);
      l_times_utc          date_table_type := date_table_type();
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_is_versioned       boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_text_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TEXT_ID');
      end if;

      if p_times is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TIMES');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id   := cwms_util.get_db_office_id(p_office_id);
      l_tsid        := cwms_ts.get_ts_id(p_tsid, l_office_id);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_replace_all := cwms_util.return_true_or_false(p_replace_all);
      l_max_version := cwms_util.return_true_or_false(p_max_version);

      l_times_utc.extend(p_times.count);

      for i in 1 .. p_times.count loop
         l_times_utc(i) := cwms_util.change_timezone(p_times(i), l_time_zone, 'UTC');
      end loop;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      select clob_code
        into l_clob_code
        from at_clob
       where office_code = l_office_code and id = upper(trim(p_text_id));

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the first time --
            -----------------------------------------------------------------------------------------
            if cwms_ts.get_ts_interval(l_tsid) > 0 then
               cwms_ts.create_ts_code(
                  p_ts_code    => l_ts_code,
                  p_office_id  => l_office_id,
                  p_cwms_ts_id => l_tsid,
                  p_utc_offset => cwms_ts.get_utc_interval_offset(l_times_utc(1), cwms_ts.get_ts_interval(l_tsid)));
            else
               cwms_ts.create_ts_code(p_ts_code => l_ts_code, p_office_id => l_office_id, p_cwms_ts_id => l_tsid);
            end if;
      end;

      --------------------
      -- store the text --
      --------------------
      store_ts_text(
         l_ts_code,
         l_clob_code,
         l_times_utc,
         null,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_text_id;

   procedure retrieve_ts_text(
      p_cursor           out sys_refcursor,
      p_tsid          in     varchar2,
      p_text_mask     in     varchar2,
      p_start_time    in     date,
      p_end_time      in     date default null,
      p_version_date  in     date default null,
      p_time_zone     in     varchar2 default null,
      p_max_version   in     varchar2 default 'T',
      p_min_attribute in     number default null,
      p_max_attribute in     number default null,
      p_office_id     in     varchar2 default null)
   is
   begin
      p_cursor      :=
         retrieve_ts_text_f(
            p_tsid,
            p_text_mask,
            p_start_time,
            p_end_time,
            p_version_date,
            p_time_zone,
            p_max_version,
            p_min_attribute,
            p_max_attribute,
            p_office_id);
   end retrieve_ts_text;

   function retrieve_ts_text_f(
      p_tsid          in varchar2,
      p_text_mask     in varchar2,
      p_start_time    in date,
      p_end_time      in date default null,
      p_version_date  in date default null,
      p_time_zone     in varchar2 default null,
      p_max_version   in varchar2 default 'T',
      p_min_attribute in number default null,
      p_max_attribute in number default null,
      p_office_id     in varchar2 default null)
      return sys_refcursor
   is
      l_office_id            varchar2(16);
      l_tsid                 varchar2(183);
      l_text_mask            varchar2(256);
      l_start_time_utc       date;
      l_end_time_utc         date;
      l_version_date_utc     date;
      l_time_zone            varchar2(28);
      l_ts_code              number(10);
      l_cursor               sys_refcursor;
      l_date_time_versions   date2_tab_t;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_text_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TEXT_MASK');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id      := cwms_util.get_db_office_id(p_office_id);
      l_tsid           := cwms_ts.get_ts_id(p_tsid, l_office_id);
      l_ts_code        := cwms_ts.get_ts_code(l_tsid, l_office_id);
      l_text_mask      := cwms_util.normalize_wildcards(p_text_mask);
      l_time_zone      := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is null then
         l_end_time_utc := l_start_time_utc;
      else
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      -----------------------------------------
      -- get the existing times and versions --
      -----------------------------------------
      l_date_time_versions      :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        p_ts_code          => l_ts_code,
                        p_start_time_utc   => l_start_time_utc,
                        p_end_time_utc     => l_end_time_utc,
                        p_date_times_utc   => null,
                        p_version_date_utc => l_version_date_utc,
                        p_max_version      => cwms_util.return_true_or_false(p_max_version)));

      ------------------
      -- get the text --
      ------------------
      open l_cursor for
           select cwms_util.change_timezone(d.date_1, 'UTC', l_time_zone) as date_time,
                  cwms_util.change_timezone(d.date_2, 'UTC', case 
                                                             when d.date_2 = cwms_util.non_versioned then 'UTC' 
                                                             else l_time_zone 
                                                             end) as version_date,
                  cwms_util.change_timezone(t.data_entry_date, 'UTC', l_time_zone) as data_entry_date,
                  c.id as text_id,
                  t.attribute,
                  c.value as text
             from table(l_date_time_versions) d, at_tsv_text t, at_clob c
            where t.ts_code = l_ts_code
              and t.date_time = d.date_1
              and t.version_date = d.date_2
              and t.clob_code = c.clob_code
              and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
                or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
              and upper(c.value) like upper(l_text_mask) escape '\'
         order by d.date_1,
                  d.date_2,
                  t.attribute,
                  t.data_entry_date;

      return l_cursor;
   end retrieve_ts_text_f;

   function get_ts_text_count(
      p_tsid          in varchar2,
      p_text_mask     in varchar2,
      p_start_time    in date,
      p_end_time      in date default null,
      p_date_times    in date_table_type default null,
      p_version_date  in date default null,
      p_time_zone     in varchar2 default null,
      p_max_version   in varchar2 default 'T',
      p_min_attribute in number default null,
      p_max_attribute in number default null,
      p_office_id     in varchar2 default null)
      return pls_integer
   is
      l_office_id          varchar2(16);
      l_tsid               varchar2(183);
      l_text_mask          varchar2(16);
      l_start_time_utc     date;
      l_end_time_utc       date;
      l_date_times_utc     date_table_type;
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_max_version        boolean;
      l_office_code        number(10);
      l_ts_code            number(10);
      l_times_utc          date2_tab_t;
      l_count              pls_integer;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_text_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TEXT_MASK');
      end if;

      if p_start_time is null and p_date_times is null then
         cwms_err.raise('ERROR', 'One of P_START_TIME or P_DATE_TIMES must be non-NULL');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_max_version := cwms_util.return_true_or_false(p_max_version);
      l_text_mask   := cwms_util.normalize_wildcards(p_text_mask);
      l_office_id   := cwms_util.get_db_office_id(p_office_id);

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      l_tsid        := cwms_ts.get_ts_id(p_tsid, l_office_code);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      if p_start_time is not null then
         l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');
      end if;

      if p_end_time is not null then
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_date_times is not null then
         l_date_times_utc := date_table_type();
         l_date_times_utc.extend(p_date_times.count);

         for i in 1 .. p_date_times.count loop
            l_date_times_utc(i) := cwms_util.change_timezone(p_date_times(i), l_time_zone, 'UTC');
         end loop;
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      l_ts_code     := cwms_ts.get_ts_code(l_tsid, l_office_code);

      l_times_utc      :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        l_ts_code,
                        l_start_time_utc,
                        l_end_time_utc,
                        l_date_times_utc,
                        l_version_date_utc,
                        l_max_version,
                        cwms_util.ts_text));

      select count(*)
        into l_count
        from at_tsv_text t, at_clob c, table(l_times_utc) d
       where t.ts_code = l_ts_code
         and t.date_time = d.date_1
         and t.version_date = d.date_2
         and t.clob_code = c.clob_code
         and upper(c.value) like upper(l_text_mask) escape '\'
         and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
           or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute));

      l_times_utc.delete;
      return l_count;
   end get_ts_text_count;

   procedure delete_ts_text(
      p_tsid          in varchar2,
      p_text_mask     in varchar2,
      p_start_time    in date,
      p_end_time      in date default null,
      p_version_date  in date default null,
      p_time_zone     in varchar2 default null,
      p_max_version   in varchar2 default 'T',
      p_min_attribute in number default null,
      p_max_attribute in number default null,
      p_office_id     in varchar2 default null)
   is
      l_office_id            varchar2(16);
      l_tsid                 varchar2(183);
      l_text_mask            varchar2(256);
      l_start_time_utc       date;
      l_end_time_utc         date;
      l_version_date_utc     date;
      l_time_zone            varchar2(28);
      l_ts_code              number(10);
      l_date_time_versions   date2_tab_t := date2_tab_t();
   begin
      cwms_util.check_office_permission(p_office_id);
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_text_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TEXT_MASK');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id      := cwms_util.get_db_office_id(p_office_id);
      l_tsid           := cwms_ts.get_ts_id(p_tsid, l_office_id);
      l_ts_code        := cwms_ts.get_ts_code(l_tsid, l_office_id);
      l_text_mask      := cwms_util.normalize_wildcards(p_text_mask);
      l_time_zone      := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is null then
         l_end_time_utc := l_start_time_utc;
      else
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      -----------------------------------------
      -- get the existing times and versions --
      -----------------------------------------
      l_date_time_versions      :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        p_ts_code          => l_ts_code,
                        p_start_time_utc   => l_start_time_utc,
                        p_end_time_utc     => l_end_time_utc,
                        p_date_times_utc   => null,
                        p_version_date_utc => l_version_date_utc,
                        p_max_version      => cwms_util.return_true_or_false(p_max_version)));

      delete from at_tsv_text
            where rowid in
                     (select t.rowid
                        from table(l_date_time_versions) d, at_tsv_text t, at_clob c
                       where t.ts_code = l_ts_code
                         and t.date_time = d.date_1
                         and t.version_date = d.date_2
                         and t.clob_code = c.clob_code
                         and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
                           or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
                         and upper(c.value) like upper(l_text_mask) escape '\');

      l_date_time_versions.delete;
   end delete_ts_text;

   procedure delete_ts_text(
      p_text_id       in varchar2,
      p_delete_action in varchar2 default cwms_util.delete_key,
      p_office_id     in varchar2)
   is
      l_office_code     number(10);
      l_clob_code       number(10);
      l_delete_action   varchar2(22);
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_text_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TEXT_ID');
      end if;

      if p_delete_action is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_DELETE_ACTION');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_delete_action      :=
         case
            when p_delete_action in (cwms_util.delete_key, cwms_util.delete_ts_id) then cwms_util.delete_key
            when p_delete_action in (cwms_util.delete_data, cwms_util.delete_ts_data) then cwms_util.delete_data
            when p_delete_action in (cwms_util.delete_all, cwms_util.delete_ts_cascade) then cwms_util.delete_all
            else null
         end;

      if l_delete_action is null then
         cwms_err.raise('INVALID_DELETE_ACTION');
      end if;

      l_office_code := cwms_util.get_db_office_code(p_office_id);

      select clob_code
        into l_clob_code
        from at_clob
       where office_code = l_office_code and upper(id) = upper(trim(p_text_id));

      if l_delete_action in (cwms_util.delete_data, cwms_util.delete_all) then
         delete from at_tsv_text
               where clob_code = l_clob_code;
      end if;

      if l_delete_action in (cwms_util.delete_key, cwms_util.delete_all) then
         delete from at_clob
               where clob_code = l_clob_code;
      end if;
   end delete_ts_text;

   procedure store_ts_binary(
      p_ts_code             in number,
      p_date_time_utc       in date,
      p_version_date_utc    in date,
      p_blob_code           in number,
      p_data_entry_date_utc in timestamp,
      p_attribute           in number)
   is
      l_rec       at_tsv_binary%rowtype;
      l_office_id varchar2(16);
   begin
      select db_office_id
        into l_office_id
        from at_cwms_ts_id
       where ts_code = p_ts_code; 
      cwms_util.check_office_permission(l_office_id);
      l_rec.ts_code         := p_ts_code;
      l_rec.date_time       := p_date_time_utc;
      l_rec.version_date    := nvl(p_version_date_utc, cast(p_data_entry_date_utc as date));
      l_rec.blob_code       := p_blob_code;
      l_rec.data_entry_date := p_data_entry_date_utc;
      l_rec.attribute       := p_attribute;

      ----------------------------------
      -- see if record already exists --
      ----------------------------------
      select *
        into l_rec
        from at_tsv_binary
       where ts_code = l_rec.ts_code
         and date_time = l_rec.date_time
         and version_date = l_rec.version_date
         and blob_code = l_rec.blob_code;

      ------------------------------------------------
      -- record exists, update it only if necessary --
      ------------------------------------------------
      if l_rec.attribute != p_attribute then
         l_rec.attribute := p_attribute;

         update at_tsv_binary
            set row = l_rec;
      end if;
   exception
      when no_data_found then
         -------------------------------------
         -- record doesn't exist; create it --
         -------------------------------------
         insert into at_tsv_binary
              values l_rec;
   end store_ts_binary;

   procedure store_ts_binary(
      p_ts_code           in integer,
      p_blob_code         in integer,
      p_date_times_utc    in date_table_type,
      p_version_dates_utc in date_table_type,
      p_version_date_utc  in date,
      p_max_version       in boolean,
      p_replace_all       in boolean,
      p_attribute         in number)
   is
      l_date_times           date_table_type;
      l_version_dates        date_table_type;
      l_regular_times        date_table_type;
      l_cursor               sys_refcursor;
      l_is_versioned_str     varchar2(1);
      l_is_versioned         boolean;
      l_off_interval_count   integer;
      l_store_date           timestamp := sys_extract_utc(systimestamp);
      l_office_id            varchar2(16);
   begin
      select db_office_id
        into l_office_id
        from at_cwms_ts_id
       where ts_code = p_ts_code; 
      cwms_util.check_office_permission(l_office_id);
      if p_version_dates_utc is null then
         ------------------------------------------------------------
         -- need to validate date/times and retrieve version dates --
         ------------------------------------------------------------
         cwms_ts.is_ts_versioned(l_is_versioned_str, p_ts_code);
         l_is_versioned := cwms_util.return_true_or_false(l_is_versioned_str);

         ------------------------------------------------------
         -- get valid times for regular interval time series --
         ------------------------------------------------------
         begin
            l_regular_times      :=
               cwms_ts.get_times_for_time_window(
                  p_date_times_utc(1),
                  p_date_times_utc(p_date_times_utc.count),
                  p_ts_code,
                  'UTC');
         exception
            when others then
               case
                  when instr(sqlerrm, 'irregular') > 0 then
                     null;
                  when instr(sqlerrm, 'undefined') > 0 then
                     cwms_err.raise(
                        'ERROR',
                        'Cannot set time series binary data for regular time series with undefined interval offset.');
                  else
                     raise;
               end case;
         end;

         if l_regular_times is not null then
            ---------------------------------------------------------
            -- verify valid times for regular interval time series --
            ---------------------------------------------------------
            select count(*)
              into l_off_interval_count
              from (select column_value from table(p_date_times_utc)
                    minus
                    select column_value from table(l_regular_times));

            if l_off_interval_count > 0 then
               cwms_err.raise(
                  'ERROR',
                  'Times include ' || l_off_interval_count || ' invalid time(s) for specified time series.');
            end if;
         end if;

         l_cursor       :=
            cwms_ts.retrieve_existing_times_f(
               p_ts_code          => p_ts_code,
               p_start_time_utc   => null,
               p_end_time_utc     => null,
               p_date_times_utc   => p_date_times_utc,
               p_version_date_utc => p_version_date_utc,
               p_max_version      => p_max_version);

         loop
            fetch l_cursor
            bulk collect into l_date_times, l_version_dates
            limit 50000;

            exit when l_date_times.count = 0;

            for i in 1 .. l_date_times.count loop
               ----------------------------------------------
               -- delete existing binary data if necessary --
               ----------------------------------------------
               if p_replace_all then
                  begin
                     delete from at_tsv_binary
                           where ts_code = p_ts_code and date_time = l_date_times(i) and version_date = l_version_dates(i);
                  exception
                     when no_data_found then
                        null;
                  end;
               end if;

               ---------------------------------------------------
               -- store the binary data for existing date_times --
               ---------------------------------------------------
               store_ts_binary(
                  p_ts_code,
                  l_date_times(i),
                  l_version_dates(i),
                  p_blob_code,
                  l_store_date,
                  p_attribute);
            end loop;
         end loop;

         close l_cursor;

         -------------------------------------------------------
         -- store the binary data for non-existing date_times --
         -------------------------------------------------------
         l_cursor       := null;
         l_date_times.delete;

         loop
            if l_cursor is null then
               open l_cursor for
                  select column_value
                    from table(p_date_times_utc)
                   where column_value not in (select date_time
                                                from cwms_v_tsv
                                               where ts_code = p_ts_code);
            else
               l_date_times.delete;
            end if;

            fetch l_cursor
            bulk collect into l_date_times
            limit 50000;

            exit when l_date_times.count = 0;

            for i in 1 .. l_date_times.count loop
               store_ts_binary(
                  p_ts_code,
                  l_date_times(i),
                  case p_version_date_utc is null
                     when true then case l_is_versioned when true then null else cwms_util.non_versioned end
                     else p_version_date_utc
                  end,
                  p_blob_code,
                  l_store_date,
                  p_attribute);
            end loop;
         end loop;

         close l_cursor;
      else
         -----------------------------------------
         -- valid dates/times already retrieved --
         -----------------------------------------
         for i in 1 .. p_date_times_utc.count loop
            store_ts_binary(
               p_ts_code,
               p_date_times_utc(i),
               p_version_dates_utc(i),
               p_blob_code,
               l_store_date,
               p_attribute);
         end loop;
      end if;
   end store_ts_binary;

   procedure store_ts_binary(
      p_tsid         in varchar2,
      p_binary       in blob,
      p_binary_type  in varchar2,
      p_start_time   in date,
      p_end_time     in date default null,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_existing     in varchar2 default 'T',
      p_non_existing in varchar2 default 'F',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_blob_code          number(10);
      l_media_type_code    number(10);
      l_start_time_utc     date;
      l_end_time_utc       date := sysdate;
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_existing           boolean;
      l_non_existing       boolean;
      l_is_versioned       boolean;
      l_is_regular         boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
      l_version_id         varchar2(32);
      l_cursor             sys_refcursor;
      l_store_date         timestamp := cast(systimestamp at time zone 'UTC' as timestamp);
      l_date_times         date_table_type;
      l_version_dates      date_table_type;
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_binary is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY');
      end if;

      if p_binary_type is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY_TYPE');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      if p_version_date = cwms_util.all_version_dates then
         cwms_err.raise('ERROR', 'Cannot specify all version dates in this call.');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_max_version     := cwms_util.return_true_or_false(p_max_version);
      l_existing        := cwms_util.return_true_or_false(p_existing);
      l_non_existing    := cwms_util.return_true_or_false(p_non_existing);
      l_replace_all     := cwms_util.return_true_or_false(p_replace_all);
      l_office_id       := cwms_util.get_db_office_id(p_office_id);

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      l_media_type_code := get_media_type_code(p_binary_type, l_office_code);

      l_tsid            := cwms_ts.get_ts_id(p_tsid, l_office_code);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_start_time_utc  := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is not null then
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      l_is_regular      := cwms_ts.get_ts_interval(l_tsid) > 0;

      if l_is_regular and not l_existing and not l_non_existing then
         return;
      end if;

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            ----------------------------------------------------------------
            -- time series doesn't exist - abort on irregular time series --
            ----------------------------------------------------------------
            if not l_is_regular then
               cwms_err.raise(
                  'ERROR',
                  'Cannot use this version of STORE_TS_BINARY to store binary to a non-existent irregular time series');
            end if;

            ----------------------------------------------------------------------------------------
            -- don't create regular time series if we're not going to store to non-existing times --
            ----------------------------------------------------------------------------------------
            if not l_non_existing then
               return;
            end if;

            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the start time --
            -----------------------------------------------------------------------------------------
            cwms_ts.create_ts_code(
               p_ts_code    => l_ts_code,
               p_office_id  => l_office_id,
               p_cwms_ts_id => l_tsid,
               p_utc_offset => cwms_ts.get_utc_interval_offset(l_start_time_utc, cwms_ts.get_ts_interval(l_tsid)));
      end;

      l_is_versioned    := cwms_util.return_true_or_false(cwms_ts.is_tsid_versioned_f(l_tsid, l_office_id));

      l_blob_code       := cwms_seq.nextval;

      insert into at_blob
           values (
                     l_blob_code,
                     l_office_code,
                     '/TIME SERIES BINARY/' || l_blob_code,
                     null,
                     l_media_type_code,
                     p_binary);

      ------------------------
      -- get the date/times --
      ------------------------
      if l_is_regular then
         -------------------------
         -- regular time series --
         -------------------------
         if l_non_existing then
            if l_existing then
               ----------------------------------------------
               -- store to existing and non-existing times --
               ----------------------------------------------
               l_date_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
            else
               --------------------------------------
               -- store to non-existing times only --
               --------------------------------------
               declare
                  l_regular_times    date_table_type;
                  l_existing_times   date_table_type;
               begin
                  l_regular_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
                  l_cursor        :=
                     cwms_ts.retrieve_existing_times_f(
                        l_ts_code,
                        l_start_time_utc,
                        l_end_time_utc,
                        null,
                        l_version_date_utc,
                        l_max_version);

                  fetch l_cursor
                  bulk collect into l_existing_times, l_version_dates;

                  close l_cursor;

                    select column_value
                      bulk collect into l_date_times
                      from (select column_value from table(l_regular_times)
                            minus
                            select column_value from table(l_existing_times))
                  order by column_value;
               end;
            end if;
         else
            ----------------------------------
            -- store to existing times only --
            ----------------------------------
            l_cursor      :=
               cwms_ts.retrieve_existing_times_f(
                  l_ts_code,
                  l_start_time_utc,
                  l_end_time_utc,
                  null,
                  l_version_date_utc,
                  l_max_version);

            fetch l_cursor
            bulk collect into l_date_times, l_version_dates;

            close l_cursor;
         end if;
      else
         ---------------------------
         -- irregular time series --
         ---------------------------
         l_cursor      :=
            cwms_ts.retrieve_existing_times_f(
               l_ts_code,
               l_start_time_utc,
               l_end_time_utc,
               null,
               l_version_date_utc,
               l_max_version);

         fetch l_cursor
         bulk collect into l_date_times, l_version_dates;

         close l_cursor;
      end if;

      ---------------------------
      -- store the binary data --
      ---------------------------
      store_ts_binary(
         l_ts_code,
         l_blob_code,
         l_date_times,
         l_version_dates,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_binary;

   procedure store_ts_binary(
      p_tsid         in varchar2,
      p_binary       in blob,
      p_binary_type  in varchar2,
      p_times        in date_table_type,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_blob_code          number(10);
      l_media_type_code    number(10);
      l_times_utc          date_table_type := date_table_type();
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_is_versioned       boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_binary is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY');
      end if;

      if p_binary_type is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY_TYPE');
      end if;

      if p_times is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TIMES');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id       := cwms_util.get_db_office_id(p_office_id);
      l_office_code     := cwms_util.get_db_office_code(l_office_id);
      l_media_type_code := get_media_type_code(p_binary_type, l_office_code);
      l_tsid            := cwms_ts.get_ts_id(p_tsid, l_office_id);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_replace_all     := cwms_util.return_true_or_false(p_replace_all);
      l_max_version     := cwms_util.return_true_or_false(p_max_version);

      l_blob_code       := cwms_seq.nextval;

      insert into at_blob
           values (
                     l_blob_code,
                     l_office_code,
                     '/TIME SERIES binary/' || l_blob_code,
                     null,
                     l_media_type_code,
                     p_binary);

      l_times_utc.extend(p_times.count);

      for i in 1 .. p_times.count loop
         l_times_utc(i) := cwms_util.change_timezone(p_times(i), l_time_zone, 'UTC');
      end loop;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the first time --
            -----------------------------------------------------------------------------------------
            if cwms_ts.get_ts_interval(l_tsid) > 0 then
               cwms_ts.create_ts_code(
                  p_ts_code    => l_ts_code,
                  p_office_id  => l_office_id,
                  p_cwms_ts_id => l_tsid,
                  p_utc_offset => cwms_ts.get_utc_interval_offset(l_times_utc(1), cwms_ts.get_ts_interval(l_tsid)));
            else
               cwms_ts.create_ts_code(p_ts_code => l_ts_code, p_office_id => l_office_id, p_cwms_ts_id => l_tsid);
            end if;
      end;

      --------------------
      -- store the binary --
      --------------------
      store_ts_binary(
         l_ts_code,
         l_blob_code,
         l_times_utc,
         null,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_binary;

   procedure store_ts_binary_id(
      p_tsid         in varchar2,
      p_binary_id    in varchar2,
      p_start_time   in date,
      p_end_time     in date default null,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_existing     in varchar2 default 'T',
      p_non_existing in varchar2 default 'F',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_blob_code          number(10);
      l_start_time_utc     date;
      l_end_time_utc       date := sysdate;
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_existing           boolean;
      l_non_existing       boolean;
      l_is_versioned       boolean;
      l_is_regular         boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
      l_version_id         varchar2(32);
      l_cursor             sys_refcursor;
      l_store_date         timestamp := cast(systimestamp at time zone 'UTC' as timestamp);
      l_date_times         date_table_type;
      l_version_dates      date_table_type;
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_binary_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY_ID');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      if p_version_date = cwms_util.all_version_dates then
         cwms_err.raise('ERROR', 'Cannot specify all version dates in this call.');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_max_version    := cwms_util.return_true_or_false(p_max_version);
      l_existing       := cwms_util.return_true_or_false(p_existing);
      l_non_existing   := cwms_util.return_true_or_false(p_non_existing);
      l_replace_all    := cwms_util.return_true_or_false(p_replace_all);
      l_office_id      := cwms_util.get_db_office_id(p_office_id);

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      select blob_code
        into l_blob_code
        from at_blob
       where office_code = l_office_code and id = upper(trim(p_binary_id));

      l_tsid           := cwms_ts.get_ts_id(p_tsid, l_office_code);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is not null then
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      l_is_regular     := cwms_ts.get_ts_interval(l_tsid) > 0;

      if l_is_regular and not l_existing and not l_non_existing then
         return;
      end if;

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            ----------------------------------------------------------------
            -- time series doesn't exist - abort on irregular time series --
            ----------------------------------------------------------------
            if not l_is_regular then
               cwms_err.raise(
                  'ERROR',
                  'Cannot use this version of STORE_TS_BINARY to store binary to a non-existent irregular time series');
            end if;

            ----------------------------------------------------------------------------------------
            -- don't create regular time series if we're not going to store to non-existing times --
            ----------------------------------------------------------------------------------------
            if not l_non_existing then
               return;
            end if;

            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the start time --
            -----------------------------------------------------------------------------------------
            cwms_ts.create_ts_code(
               p_ts_code    => l_ts_code,
               p_office_id  => l_office_id,
               p_cwms_ts_id => l_tsid,
               p_utc_offset => cwms_ts.get_utc_interval_offset(l_start_time_utc, cwms_ts.get_ts_interval(l_tsid)));
      end;

      l_is_versioned   := cwms_util.return_true_or_false(cwms_ts.is_tsid_versioned_f(l_tsid, l_office_id));

      ------------------------
      -- get the date/times --
      ------------------------
      if l_is_regular then
         -------------------------
         -- regular time series --
         -------------------------
         if l_non_existing then
            if l_existing then
               ----------------------------------------------
               -- store to existing and non-existing times --
               ----------------------------------------------
               l_date_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
            else
               --------------------------------------
               -- store to non-existing times only --
               --------------------------------------
               declare
                  l_regular_times    date_table_type;
                  l_existing_times   date_table_type;
               begin
                  l_regular_times := cwms_ts.get_times_for_time_window(l_start_time_utc, l_end_time_utc, l_ts_code);
                  l_cursor        :=
                     cwms_ts.retrieve_existing_times_f(
                        l_ts_code,
                        l_start_time_utc,
                        l_end_time_utc,
                        null,
                        l_version_date_utc,
                        l_max_version);

                  fetch l_cursor
                  bulk collect into l_existing_times, l_version_dates;

                  close l_cursor;

                    select column_value
                      bulk collect into l_date_times
                      from (select column_value from table(l_regular_times)
                            minus
                            select column_value from table(l_existing_times))
                  order by column_value;
               end;
            end if;
         else
            ----------------------------------
            -- store to existing times only --
            ----------------------------------
            l_cursor      :=
               cwms_ts.retrieve_existing_times_f(
                  l_ts_code,
                  l_start_time_utc,
                  l_end_time_utc,
                  null,
                  l_version_date_utc,
                  l_max_version);

            fetch l_cursor
            bulk collect into l_date_times, l_version_dates;

            close l_cursor;
         end if;
      else
         ---------------------------
         -- irregular time series --
         ---------------------------
         l_cursor      :=
            cwms_ts.retrieve_existing_times_f(
               l_ts_code,
               l_start_time_utc,
               l_end_time_utc,
               null,
               l_version_date_utc,
               l_max_version);

         fetch l_cursor
         bulk collect into l_date_times, l_version_dates;

         close l_cursor;
      end if;

      --------------------
      -- store the binary --
      --------------------
      store_ts_binary(
         l_ts_code,
         l_blob_code,
         l_date_times,
         l_version_dates,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_binary_id;

   procedure store_ts_binary_id(
      p_tsid         in varchar2,
      p_binary_id    in varchar2,
      p_times        in date_table_type,
      p_version_date in date default null,
      p_time_zone    in varchar2 default null,
      p_max_version  in varchar2 default 'T',
      p_replace_all  in varchar2 default 'F',
      p_attribute    in number default null,
      p_office_id    in varchar2 default null)
   is
      ts_id_not_found      exception;
      pragma exception_init(ts_id_not_found, -20001);
      l_tsid               varchar2(183);
      l_ts_code            number(10);
      l_blob_code          number(10);
      l_times_utc          date_table_type := date_table_type();
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_replace_all        boolean;
      l_max_version        boolean;
      l_is_versioned       boolean;
      l_office_id          varchar2(16);
      l_office_code        number(10);
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_binary_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY_ID');
      end if;

      if p_times is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TIMES');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id   := cwms_util.get_db_office_id(p_office_id);
      l_tsid        := cwms_ts.get_ts_id(p_tsid, l_office_id);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      l_replace_all := cwms_util.return_true_or_false(p_replace_all);
      l_max_version := cwms_util.return_true_or_false(p_max_version);

      l_times_utc.extend(p_times.count);

      for i in 1 .. p_times.count loop
         l_times_utc(i) := cwms_util.change_timezone(p_times(i), l_time_zone, 'UTC');
      end loop;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      select blob_code
        into l_blob_code
        from at_blob
       where office_code = l_office_code and id = upper(trim(p_binary_id));

      begin
         l_ts_code := cwms_ts.get_ts_code(l_tsid, l_office_code);
      exception
         when ts_id_not_found then
            -----------------------------------------------------------------------------------------
            -- create the regular time series with the interval offset defined from the first time --
            -----------------------------------------------------------------------------------------
            if cwms_ts.get_ts_interval(l_tsid) > 0 then
               cwms_ts.create_ts_code(
                  p_ts_code    => l_ts_code,
                  p_office_id  => l_office_id,
                  p_cwms_ts_id => l_tsid,
                  p_utc_offset => cwms_ts.get_utc_interval_offset(l_times_utc(1), cwms_ts.get_ts_interval(l_tsid)));
            else
               cwms_ts.create_ts_code(p_ts_code => l_ts_code, p_office_id => l_office_id, p_cwms_ts_id => l_tsid);
            end if;
      end;

      --------------------
      -- store the binary --
      --------------------
      store_ts_binary(
         l_ts_code,
         l_blob_code,
         l_times_utc,
         null,
         l_version_date_utc,
         l_max_version,
         l_replace_all,
         p_attribute);
   end store_ts_binary_id;

   procedure retrieve_ts_binary(
      p_cursor              out sys_refcursor,
      p_tsid             in     varchar2,
      p_binary_type_mask in     varchar2,
      p_start_time       in     date,
      p_end_time         in     date default null,
      p_version_date     in     date default null,
      p_time_zone        in     varchar2 default null,
      p_max_version      in     varchar2 default 'T',
      p_retrieve_binary  in     varchar2 default 'T',
      p_min_attribute    in     number default null,
      p_max_attribute    in     number default null,
      p_office_id        in     varchar2 default null)
   is
   begin
      p_cursor      :=
         retrieve_ts_binary_f(
            p_tsid,
            p_binary_type_mask,
            p_start_time,
            p_end_time,
            p_version_date,
            p_time_zone,
            p_max_version,
            p_retrieve_binary,
            p_min_attribute,
            p_max_attribute,
            p_office_id);
   end retrieve_ts_binary;

   function retrieve_ts_binary_f(
      p_tsid             in varchar2,
      p_binary_type_mask in varchar2,
      p_start_time       in date,
      p_end_time         in date default null,
      p_version_date     in date default null,
      p_time_zone        in varchar2 default null,
      p_max_version      in varchar2 default 'T',
      p_retrieve_binary  in varchar2 default 'T',
      p_min_attribute    in number default null,
      p_max_attribute    in number default null,
      p_office_id        in varchar2 default null)
      return sys_refcursor
   is
      l_office_id            varchar2(16);
      l_tsid                 varchar2(183);
      l_binary_type_mask     varchar2(256);
      l_start_time_utc       date;
      l_end_time_utc         date;
      l_version_date_utc     date;
      l_time_zone            varchar2(28);
      l_ts_code              number(10);
      l_office_code          number(10);
      l_cursor               sys_refcursor;
      l_date_time_versions   date2_tab_t;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_binary_type_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY_TYPE_MASK');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id        := cwms_util.get_db_office_id(p_office_id);
      l_office_code      := cwms_util.get_db_office_code(l_office_id);
      l_tsid             := cwms_ts.get_ts_id(p_tsid, l_office_id);
      l_ts_code          := cwms_ts.get_ts_code(l_tsid, l_office_id);
      l_binary_type_mask := cwms_util.normalize_wildcards(p_binary_type_mask);
      l_time_zone        :=
         nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      l_start_time_utc   := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is null then
         l_end_time_utc := l_start_time_utc;
      else
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      -----------------------------------------
      -- get the existing times and versions --
      -----------------------------------------
      l_date_time_versions      :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        p_ts_code          => l_ts_code,
                        p_start_time_utc   => l_start_time_utc,
                        p_end_time_utc     => l_end_time_utc,
                        p_date_times_utc   => null,
                        p_version_date_utc => l_version_date_utc,
                        p_max_version      => cwms_util.return_true_or_false(p_max_version)));

      ------------------
      -- get the data --
      ------------------
      if cwms_util.return_true_or_false(p_retrieve_binary) then
         -------------------
         -- with the blob --
         -------------------
         open l_cursor for
              select cwms_util.change_timezone(d.date_1, 'UTC', l_time_zone) as date_time,
                     cwms_util.change_timezone(d.date_2, 'UTC', l_time_zone) as version_date,
                     cwms_util.change_timezone(t.data_entry_date, 'UTC', l_time_zone) as data_entry_date,
                     b.id,
                     t.attribute,
                     e.file_ext,
                     m.media_type_id,
                     b.value
                from table(l_date_time_versions) d,
                     at_tsv_binary t,
                     at_blob b,
                     cwms_media_type m,
                     at_file_extension e
               where t.ts_code = l_ts_code
                 and t.date_time = d.date_1
                 and t.version_date = d.date_2
                 and t.blob_code = b.blob_code
                 and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
                   or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
                 and b.media_type_code = m.media_type_code
                 and m.media_type_code in
                        (select media_type_code
                           from cwms_media_type
                          where upper(media_type_id) like upper(l_binary_type_mask) escape '\'
                         union
                         select media_type_code
                           from at_file_extension
                          where office_code in (l_office_code, cwms_util.db_office_code_all)
                            and upper(file_ext) like upper(l_binary_type_mask) escape '\')
            order by d.date_1,
                     d.date_2,
                     t.attribute,
                     t.data_entry_date;
      else
         ----------------------
         -- without the blob --
         ----------------------
         open l_cursor for
              select cwms_util.change_timezone(d.date_1, 'UTC', l_time_zone) as date_time,
                     cwms_util.change_timezone(d.date_2, 'UTC', l_time_zone) as version_date,
                     cwms_util.change_timezone(t.data_entry_date, 'UTC', l_time_zone) as data_entry_date,
                     b.id,
                     t.attribute,
                     e.file_ext,
                     m.media_type_id
                from table(l_date_time_versions) d,
                     at_tsv_binary t,
                     at_blob b,
                     cwms_media_type m,
                     at_file_extension e
               where t.ts_code = l_ts_code
                 and t.date_time = d.date_1
                 and t.version_date = d.date_2
                 and t.blob_code = b.blob_code
                 and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
                   or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
                 and b.media_type_code = m.media_type_code
                 and m.media_type_code in
                        (select media_type_code
                           from cwms_media_type
                          where upper(media_type_id) like upper(l_binary_type_mask) escape '\'
                         union
                         select media_type_code
                           from at_file_extension
                          where office_code in (l_office_code, cwms_util.db_office_code_all)
                            and upper(file_ext) like upper(l_binary_type_mask) escape '\')
            order by d.date_1,
                     d.date_2,
                     t.attribute,
                     t.data_entry_date;
      end if;

      return l_cursor;
   end retrieve_ts_binary_f;

   function get_ts_binary_count(
      p_tsid             in varchar2,
      p_binary_type_mask in varchar2,
      p_start_time       in date,
      p_end_time         in date default null,
      p_date_times       in date_table_type default null,
      p_version_date     in date default null,
      p_time_zone        in varchar2 default null,
      p_max_version      in varchar2 default 'T',
      p_min_attribute    in number default null,
      p_max_attribute    in number default null,
      p_office_id        in varchar2 default null)
      return pls_integer
   is
      l_office_id          varchar2(16);
      l_tsid               varchar2(183);
      l_binary_type_mask   varchar2(16);
      l_start_time_utc     date;
      l_end_time_utc       date;
      l_date_times_utc     date_table_type;
      l_version_date_utc   date;
      l_time_zone          varchar2(28);
      l_max_version        boolean;
      l_office_code        number(10);
      l_ts_code            number(10);
      l_times_utc          date2_tab_t;
      l_count              pls_integer;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_binary_type_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY_TYPE_MASK');
      end if;

      if p_start_time is null and p_date_times is null then
         cwms_err.raise('ERROR', 'One of P_START_TIME or P_DATE_TIMES must be non-NULL');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_max_version      := cwms_util.return_true_or_false(p_max_version);
      l_binary_type_mask := cwms_util.normalize_wildcards(p_binary_type_mask);
      l_office_id        := cwms_util.get_db_office_id(p_office_id);

      select office_code
        into l_office_code
        from cwms_office
       where office_id = l_office_id;

      l_tsid             := cwms_ts.get_ts_id(p_tsid, l_office_code);

      if l_tsid is null then
         l_tsid      := p_tsid;
         l_time_zone := nvl(p_time_zone, 'UTC');
      else
         l_time_zone := nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      end if;

      if p_start_time is not null then
         l_start_time_utc := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');
      end if;

      if p_end_time is not null then
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_date_times is not null then
         l_date_times_utc := date_table_type();
         l_date_times_utc.extend(p_date_times.count);

         for i in 1 .. p_date_times.count loop
            l_date_times_utc(i) := cwms_util.change_timezone(p_date_times(i), l_time_zone, 'UTC');
         end loop;
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      l_ts_code          := cwms_ts.get_ts_code(l_tsid, l_office_code);

      l_times_utc        :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        l_ts_code,
                        l_start_time_utc,
                        l_end_time_utc,
                        l_date_times_utc,
                        l_version_date_utc,
                        l_max_version,
                        cwms_util.ts_binary));

      select count(*)
        into l_count
        from table(l_times_utc) d,
             at_tsv_binary t,
             at_blob b,
             cwms_media_type m,
             at_file_extension e
       where t.ts_code = l_ts_code
         and t.date_time = d.date_1
         and t.version_date = d.date_2
         and t.blob_code = b.blob_code
         and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
           or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
         and b.media_type_code = m.media_type_code
         and m.media_type_code in
                (select media_type_code
                   from cwms_media_type
                  where upper(media_type_id) like upper(l_binary_type_mask) escape '\'
                 union
                 select media_type_code
                   from at_file_extension
                  where office_code in (l_office_code, cwms_util.db_office_code_all)
                    and upper(file_ext) like upper(l_binary_type_mask) escape '\');

      l_times_utc.delete;
      return l_count;
   end get_ts_binary_count;

   procedure delete_ts_binary(
      p_tsid             in varchar2,
      p_binary_type_mask in varchar2,
      p_start_time       in date,
      p_end_time         in date default null,
      p_version_date     in date default null,
      p_time_zone        in varchar2 default null,
      p_max_version      in varchar2 default 'T',
      p_min_attribute    in number default null,
      p_max_attribute    in number default null,
      p_office_id        in varchar2 default null)
   is
      l_office_id            varchar2(16);
      l_tsid                 varchar2(183);
      l_binary_type_mask     varchar2(256);
      l_start_time_utc       date;
      l_end_time_utc         date;
      l_version_date_utc     date;
      l_time_zone            varchar2(28);
      l_ts_code              number(10);
      l_office_code          number(10);
      l_date_time_versions   date2_tab_t := date2_tab_t();
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_tsid is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_TSID');
      end if;

      if p_binary_type_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY_TYPE_MASK');
      end if;

      if p_start_time is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_START_TIME');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_office_id        := cwms_util.get_db_office_id(p_office_id);
      l_office_code      := cwms_util.get_db_office_code(l_office_id);
      l_tsid             := cwms_ts.get_ts_id(p_tsid, l_office_id);
      l_ts_code          := cwms_ts.get_ts_code(l_tsid, l_office_id);
      l_binary_type_mask := cwms_util.normalize_wildcards(p_binary_type_mask);
      l_time_zone        :=
         nvl(p_time_zone, cwms_loc.get_local_timezone(substr(l_tsid, 1, instr(l_tsid, '.') - 1), l_office_id));
      l_start_time_utc   := cwms_util.change_timezone(p_start_time, l_time_zone, 'UTC');

      if p_end_time is null then
         l_end_time_utc := l_start_time_utc;
      else
         l_end_time_utc := cwms_util.change_timezone(p_end_time, l_time_zone, 'UTC');
      end if;

      if p_version_date is not null then
         l_version_date_utc := cwms_util.change_timezone(p_version_date, l_time_zone, 'UTC');
      end if;

      -----------------------------------------
      -- get the existing times and versions --
      -----------------------------------------
      l_date_time_versions      :=
         group_times(cwms_ts.retrieve_existing_times_f(
                        p_ts_code          => l_ts_code,
                        p_start_time_utc   => l_start_time_utc,
                        p_end_time_utc     => l_end_time_utc,
                        p_date_times_utc   => null,
                        p_version_date_utc => l_version_date_utc,
                        p_max_version      => cwms_util.return_true_or_false(p_max_version)));

      delete from at_tsv_binary
            where rowid in
                     (select t.rowid
                        from table(l_date_time_versions) d,
                             at_tsv_binary t,
                             at_blob b,
                             cwms_media_type m,
                             at_file_extension e
                       where t.ts_code = l_ts_code
                         and t.date_time = d.date_1
                         and t.version_date = d.date_2
                         and t.blob_code = b.blob_code
                         and ((p_min_attribute is null and p_max_attribute is null and t.attribute is null)
                           or t.attribute between nvl(p_min_attribute, t.attribute) and nvl(p_max_attribute, t.attribute))
                         and b.media_type_code = m.media_type_code
                         and m.media_type_code in
                                (select media_type_code
                                   from cwms_media_type
                                  where upper(media_type_id) like upper(l_binary_type_mask) escape '\'
                                 union
                                 select media_type_code
                                   from at_file_extension
                                  where office_code in (l_office_code, cwms_util.db_office_code_all)
                                    and upper(file_ext) like upper(l_binary_type_mask) escape '\'));

      l_date_time_versions.delete;
   end delete_ts_binary;

   procedure delete_ts_binary(
      p_binary_id     in varchar2,
      p_delete_action in varchar2 default cwms_util.delete_key,
      p_office_id     in varchar2 default null)
   is
      l_office_code     number(10);
      l_blob_code       number(10);
      l_delete_action   varchar2(22);
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_binary_id is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_BINARY_ID');
      end if;

      if p_delete_action is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_DELETE_ACTION');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_delete_action      :=
         case
            when p_delete_action in (cwms_util.delete_key, cwms_util.delete_ts_id) then cwms_util.delete_key
            when p_delete_action in (cwms_util.delete_data, cwms_util.delete_ts_data) then cwms_util.delete_data
            when p_delete_action in (cwms_util.delete_all, cwms_util.delete_ts_cascade) then cwms_util.delete_all
            else null
         end;

      if l_delete_action is null then
         cwms_err.raise('INVALID_DELETE_ACTION');
      end if;

      l_office_code := cwms_util.get_db_office_code(p_office_id);

      select blob_code
        into l_blob_code
        from at_blob
       where office_code = l_office_code and upper(id) = upper(trim(p_binary_id));

      if l_delete_action in (cwms_util.delete_data, cwms_util.delete_all) then
         delete from at_tsv_binary
               where blob_code = l_blob_code;
      end if;

      if l_delete_action in (cwms_util.delete_key, cwms_util.delete_all) then
         delete from at_blob
               where blob_code = l_blob_code;
      end if;
   end delete_ts_binary;

   procedure store_file_extension(
      p_file_extension in varchar2,
      p_media_type     in varchar2,
      p_fail_if_exists in varchar2 default 'T',
      p_office_id      in varchar2 default null)
   is
      l_file_extension    varchar2(16);
      l_office_code       number(10);
      l_media_type_code   number(10);
      l_rec               at_file_extension%rowtype;
      l_exists            boolean;
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_file_extension is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_FILE_EXTENSION');
      end if;

      if p_media_type is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_MEDIA_TYPE');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_file_extension      :=
         trim(substr(
                 l_file_extension,
                 instr(
                    l_file_extension,
                    '.',
                    -1,
                    1)));
      l_office_code := cwms_util.get_db_office_code(p_office_id);

      select media_type_code
        into l_media_type_code
        from cwms_media_type
       where upper(media_type_id) = upper(trim(p_media_type));

      ----------------------------------------------
      -- see if the file extension already exists --
      ----------------------------------------------
      begin
         select *
           into l_rec
           from at_file_extension
          where office_code in (l_office_code, cwms_util.db_office_code_all) and file_ext = l_file_extension;

         l_exists := true;
      exception
         when no_data_found then
            l_exists := false;
      end;

      if l_exists then
         if cwms_util.return_true_or_false(p_fail_if_exists) then
            cwms_err.raise('ITEM_ALREADY_EXISTS', 'File extension', l_file_extension);
         end if;

         if l_rec.media_type_code != l_media_type_code then
            -----------------------
            -- update the record --
            -----------------------
            if l_rec.office_code = cwms_util.db_office_code_all and l_office_code != cwms_util.db_office_code_all then
               cwms_err.raise('ERROR', 'Cannot update file extension for office CWMS');
            end if;

            l_rec.media_type_code := l_media_type_code;

            update at_file_extension
               set row = l_rec
             where office_code = l_rec.office_code and file_ext = l_rec.file_ext;
         end if;
      else
         -------------------------
         -- insert a new record --
         -------------------------
         l_rec.office_code     := l_office_code;
         l_rec.file_ext        := l_file_extension;
         l_rec.media_type_code := l_media_type_code;

         insert into at_file_extension
              values l_rec;
      end if;
   end store_file_extension;

   procedure delete_file_extension(
      p_file_extension in varchar2, 
      p_office_id      in varchar2 default null)
   is
      l_file_extension   varchar2(16);
      l_office_code      number(10);
      l_rec              at_file_extension%rowtype;
   begin
      -------------------
      -- sanity checks --
      -------------------
      cwms_util.check_office_permission(p_office_id);
      if p_file_extension is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_FILE_EXTENSION');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_file_extension      :=
         trim(substr(
                 l_file_extension,
                 instr(
                    l_file_extension,
                    '.',
                    -1,
                    1)));
      l_office_code := cwms_util.get_db_office_code(p_office_id);

      -----------------------
      -- delete the record --
      -----------------------
      select *
        into l_rec
        from at_file_extension
       where office_code in (l_office_code, cwms_util.db_office_code_all) and file_ext = l_file_extension;

      if l_rec.office_code = cwms_util.db_office_code_all and l_office_code != cwms_util.db_office_code_all then
         cwms_err.raise('ERROR', 'Cannot delete file extension for office CWMS');
      end if;

      delete from at_file_extension
            where office_code = l_rec.office_code and file_ext = l_rec.file_ext;
   end delete_file_extension;

   procedure cat_file_extensions(
      p_cursor                 out sys_refcursor,
      p_file_extension_mask in     varchar2 default '*',
      p_office_id_mask      in     varchar2 default null)
   is
   begin
      p_cursor := cat_file_extensions_f(p_file_extension_mask, p_office_id_mask);
   end cat_file_extensions;

   function cat_file_extensions_f(
      p_file_extension_mask in varchar2 default '*', 
      p_office_id_mask      in varchar2 default null)
      return sys_refcursor
   is
      l_file_extension_mask   varchar2(16);
      l_office_id_mask        varchar2(16);
      l_cursor                sys_refcursor;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_file_extension_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_FILE_EXTENSION_MASK');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_file_extension_mask := upper(trim(p_file_extension_mask));
      l_file_extension_mask      :=
         substr(
            l_file_extension_mask,
            instr(
               l_file_extension_mask,
               '.',
               -1,
               1)
            + 1);
      l_file_extension_mask := cwms_util.normalize_wildcards(l_file_extension_mask);

      if p_office_id_mask is null then
         l_office_id_mask := cwms_util.user_office_id;
      else
         l_office_id_mask := cwms_util.normalize_wildcards(p_office_id_mask);
      end if;

      ---------------------
      -- open the cursor --
      ---------------------
      open l_cursor for
           select o.office_id, e.file_ext as file_extension, m.media_type_id as media_type
             from at_file_extension e, cwms_media_type m, cwms_office o
            where (o.office_id like upper(l_office_id_mask) escape '\' or o.office_id = 'CWMS')
              and e.office_code = o.office_code
              and upper(e.file_ext) like l_file_extension_mask escape '\'
              and m.media_type_code = e.media_type_code
         order by o.office_id, e.file_ext, m.media_type_id;

      return l_cursor;
   end cat_file_extensions_f;

   procedure cat_media_types(
      p_cursor             out sys_refcursor,
      p_media_type_mask in     varchar2 default '*',
      p_office_id_mask  in     varchar2 default null)
   is
   begin
      p_cursor := cat_media_types_f(p_media_type_mask, p_office_id_mask);
   end cat_media_types;

   function cat_media_types_f(
      p_media_type_mask in varchar2 default '*', 
      p_office_id_mask  in varchar2 default null)
      return sys_refcursor
   is
      l_media_type_mask   varchar2(84);
      l_office_id_mask    varchar2(16);
      l_cursor            sys_refcursor;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_media_type_mask is null then
         cwms_err.raise('NULL_ARGUMENT', 'P_MEDIA_TYPE_MASK');
      end if;

      ----------------------------
      -- assign local variables --
      ----------------------------
      l_media_type_mask := cwms_util.normalize_wildcards(p_media_type_mask);

      if p_office_id_mask is null then
         l_office_id_mask := cwms_util.user_office_id;
      else
         l_office_id_mask := cwms_util.normalize_wildcards(p_office_id_mask);
      end if;

      ---------------------
      -- open the cursor --
      ---------------------
      open l_cursor for
           select distinct o.office_id, m.media_type_id as media_type, e.file_ext as file_extension
             from cwms_media_type m, at_file_extension e, cwms_office o
            where (o.office_id like upper(l_office_id_mask) escape '\' or o.office_id = 'CWMS')
              and e.office_code = o.office_code
              and e.media_type_code = m.media_type_code
              and upper(m.media_type_id) like upper(l_media_type_mask) escape '\'
         order by o.office_id, m.media_type_id, e.file_ext;

      return l_cursor;
   end cat_media_types_f;

   procedure store_text_filter(
      p_text_filter_id in varchar2,
      p_description    in varchar2,
      p_text_filter    in str_tab_t,
      p_fail_if_exists in varchar2 default 'T',
      p_uses_regex     in varchar2 default 'F',
      p_regex_flags    in varchar2 default null,
      p_office_id      in varchar2 default null)
   is      
      type filter_elements_t is table of at_text_filter_element%rowtype; 
      c_element_pattern1 constant varchar2(57) := '^\s*(i(n(c(l(u(de?)?)?)?)?)?|e(x(c(l(u(de?)?)?)?)?)?)\s*:';
      c_element_pattern2 constant varchar2(35) := '\s*:\s*f(l(a(gs?)?)?)?\s*=.*$';
      l_header_rec       at_text_filter%rowtype;
      l_elements         filter_elements_t;
      l_exists           boolean;
      l_fail_if_exists   boolean := cwms_util.is_true(p_fail_if_exists);
      l_is_regex         boolean := cwms_util.is_true(p_uses_regex);
      l_office_id        varchar2(16) := cwms_util.get_db_office_id(p_office_id);
      l_office_code      integer := cwms_util.get_db_office_code(l_office_id);
      l_parts            str_tab_t;
      l_pos              integer;
   begin
      cwms_util.check_office_permission(p_office_id);
      -------------------------------------------------
      -- get the existing header record if it exists --
      -------------------------------------------------
      l_header_rec.text_filter_id := trim(p_text_filter_id);
      begin
         select *
           into l_header_rec
           from at_text_filter
          where office_code in (l_office_code, cwms_util.db_office_code_all)
            and upper(text_filter_id) = upper(l_header_rec.text_filter_id);
         l_exists := true;            
      exception
         when no_data_found then l_exists := false; 
      end;
      if l_exists then
         if l_fail_if_exists then
            select office_id
              into l_office_id
              from cwms_office
             where office_code = l_header_rec.office_code; 
            cwms_err.raise(
               'ITEM_ALREADY_EXISTS',
               'Text filter',
               l_office_id||'/'||l_header_rec.text_filter_id);
         elsif l_header_rec.office_code = cwms_util.db_office_code_all and l_office_code != cwms_util.db_office_code_all then
            cwms_err.raise(
               'ERROR',
               'Cannot store text filter '
               ||l_office_id
               ||'/'
               ||l_header_rec.text_filter_id
               ||' because '
               ||'CWMS/'
               ||l_header_rec.text_filter_id
               ||' exists');
         end if;
         ------------------------------------------
         -- exists, delete the existing elements --
         ------------------------------------------
         delete 
           from at_text_filter_element
          where text_filter_code = l_header_rec.text_filter_code;
      else
         --------------------------------------------
         -- doesn't exist, prime header for insert --
         --------------------------------------------
         l_header_rec.text_filter_code := cwms_seq.nextval; 
         l_header_rec.office_code      := l_office_code;
      end if;
      ------------------------------------------------      
      -- finish setting header for update or insert --
      ------------------------------------------------
      l_header_rec.description := trim(p_description);      
      l_header_rec.is_regex := case l_is_regex when true then 'T' else 'F' end;
      l_header_rec.regex_flags := lower(trim(p_regex_flags));
      ---------------------------------      
      -- update or insert the header --
      ---------------------------------      
      if l_exists then
         update at_text_filter
            set row = l_header_rec
          where text_filter_code = l_header_rec.text_filter_code;  
      else
         insert
           into at_text_filter
         values l_header_rec;  
      end if;                                              
      
      if p_text_filter is not null then
         l_elements := filter_elements_t();
         for i in 1..p_text_filter.count loop
            l_elements.extend;
            l_elements(i).text_filter_code := l_header_rec.text_filter_code;
            l_elements(i).element_sequence := i;
            l_elements(i).regex_flags := l_header_rec.regex_flags; -- may be overwritten       
            l_pos := regexp_instr(p_text_filter(i), c_element_pattern1, 1, 1, 1, 'i'); 
            if l_pos = 0 then
               cwms_err.raise(
                  'ERROR',
                  'Filter element must be like (INCLUDE|EXCLUDE):<filter>[:FLAGS=<flags>]'
                  ||chr(10)
                  ||'<'||p_text_filter(i)||'>');
            end if;
            l_parts := str_tab_t(
               lower(trim(substr(p_text_filter(i), 1, l_pos-1))),
               substr(p_text_filter(i), l_pos));
            if substr(l_parts(1), 1, 1) = 'i' then
                  l_elements(i).include := 'T';
            else
                  l_elements(i).include := 'F';
            end if;
            l_pos := regexp_instr(l_parts(2), c_element_pattern2, 1, 1, 0, 'i');
            if l_pos = 0 then
               l_elements(i).filter_text := l_parts(2);
               l_elements(i).regex_flags := null;
            else   
               l_elements(i).filter_text := substr(l_parts(2), 1, l_pos - 1);
               l_parts(2) := regexp_replace(substr(l_parts(2), l_pos), '\s+', null, 1, 0);
               l_parts(2) := lower(trim(substr(l_parts(2), instr(l_parts(2), '=') + 1))); 
               if instr(l_parts(2), 'm') != 0 then
                  l_elements(i).regex_flags := l_elements(i).regex_flags || 'm';
               end if;
               if instr(l_parts(2), 'n') != 0 then
                  l_elements(i).regex_flags := l_elements(i).regex_flags || 'n';
               end if;
               if instr(l_parts(2), 'x') != 0 then
                  l_elements(i).regex_flags := l_elements(i).regex_flags || 'x';
               end if;
               if instr(l_parts(2), 'i') != 0 then
                  l_elements(i).regex_flags := l_elements(i).regex_flags || 'i';
               end if;
            end if;
         end loop;
         forall i in 1..l_elements.count
            insert into at_text_filter_element values l_elements(i);
      end if;
   end store_text_filter;      
      
   procedure retrieve_text_filter(
      p_text_filter    out str_tab_t,
      p_uses_regex     out varchar2,
      p_text_filter_id in  varchar2,
      p_office_id      in  varchar2 default null)
   is
      type filter_elements_t is table of at_text_filter_element%rowtype;
      l_office_code integer := cwms_util.get_db_office_code(p_office_id);
      l_header_rec  at_text_filter%rowtype;
      l_elements    filter_elements_t;
      l_text_filter str_tab_t;
   begin
      cwms_util.check_office_permission(p_office_id);
      l_header_rec.text_filter_id := trim(p_text_filter_id);
      begin
         select *
           into l_header_rec
           from at_text_filter
          where office_code in (l_office_code, cwms_util.db_office_code_all)
            and upper(text_filter_id) = upper(l_header_rec.text_filter_id);
      exception
         when no_data_found then 
            cwms_err.raise(
               'ITEM_DOES_NOT_EXIST',
               'Text filter',
               l_header_rec.text_filter_id);
      end;
      begin
         select *      
           bulk collect
           into l_elements
           from at_text_filter_element
          where text_filter_code = l_header_rec.text_filter_code
          order by element_sequence;
          
         l_text_filter := str_tab_t();
         l_text_filter.extend(l_elements.count);
         for i in 1..l_elements.count loop
            l_text_filter(i) := case l_elements(i).include when 'T' then 'include:' else 'exclude:' end;
            if l_elements(i).regex_flags is not null and length(l_elements(i).regex_flags) > 0 then
               l_text_filter(i) := l_text_filter(i)||'flags='||l_elements(i).regex_flags||':';
            elsif l_header_rec.regex_flags is not null and length(l_header_rec.regex_flags) > 0 then
               l_text_filter(i) := l_text_filter(i)||'flags='||l_header_rec.regex_flags||':';
            end if;
            l_text_filter(i) := l_text_filter(i)||l_elements(i).filter_text;
         end loop;            
      exception
         when no_data_found then null;
      end;
      p_text_filter := l_text_filter;
      p_uses_regex := l_header_rec.is_regex; 
   end retrieve_text_filter;               
                                      
   procedure delete_text_filter(
      p_text_filter_id in varchar2,
      p_office_id      in varchar2 default null)
   is      
      l_header_rec  at_text_filter%rowtype;
      l_office_id   varchar2(16) := cwms_util.get_db_office_id(p_office_id);
      l_office_code integer := cwms_util.get_db_office_code(l_office_id);
   begin                     
      cwms_util.check_office_permission(p_office_id);
      l_header_rec.text_filter_id := trim(p_text_filter_id);
      begin
         select *
           into l_header_rec
           from at_text_filter
          where office_code in (l_office_code, cwms_util.db_office_code_all)
            and upper(text_filter_id) = upper(l_header_rec.text_filter_id);
      exception
         when no_data_found then
            cwms_err.raise(
               'ITEM_DOES_NOT_EXIST',
               'Text filter',
               l_office_id||'/'||l_header_rec.text_filter_id); 
      end;
      if l_header_rec.office_code = cwms_util.db_office_code_all then
         if l_office_code != cwms_util.db_office_code_all then
            cwms_err.raise(
               'ERROR',
               'Text filter '
               ||l_header_rec.text_filter_id
               ||' is owned by CWMS - cannot delete.');
         end if;
      end if;
      delete 
        from at_text_filter_element
       where text_filter_code = l_header_rec.text_filter_code;
       
      delete 
        from at_text_filter
       where text_filter_code = l_header_rec.text_filter_code;
       
   end delete_text_filter;
                                      
   procedure rename_text_filter(
      p_old_text_filter_id in varchar2,
      p_new_text_filter_id in varchar2,
      p_office_id          in varchar2 default null)
   is      
      l_header_old  at_text_filter%rowtype;
      l_header_new at_text_filter%rowtype;
      l_office_id   varchar2(16) := cwms_util.get_db_office_id(p_office_id);
      l_office_code integer := cwms_util.get_db_office_code(l_office_id);
   begin                     
      cwms_util.check_office_permission(p_office_id);
      l_header_old.text_filter_id := trim(p_old_text_filter_id);
      begin
         select *
           into l_header_old
           from at_text_filter
          where office_code in (l_office_code, cwms_util.db_office_code_all)
            and upper(text_filter_id) = upper(l_header_old.text_filter_id);
      exception
         when no_data_found then
            cwms_err.raise(
               'ITEM_DOES_NOT_EXIST',
               'Text filter',
               l_office_id||'/'||l_header_old.text_filter_id); 
      end;
      l_header_new.text_filter_id := trim(p_new_text_filter_id);
      begin
         select *
           into l_header_new
           from at_text_filter
          where office_code in (l_office_code, cwms_util.db_office_code_all)
            and upper(text_filter_id) = upper(l_header_new.text_filter_id);
            
         cwms_err.raise(
            'ITEM_ALREADY_EXISTS',
            'Text filter',
            l_office_id||'/'||l_header_new.text_filter_id);           
      exception
         when no_data_found then null;
      end;
      
      update at_text_filter
         set text_filter_id = l_header_new.text_filter_id
       where text_filter_code = l_header_old.text_filter_code;         
       
   end rename_text_filter;
            
   function filter_text(
      p_text_filter_id in varchar2,
      p_values         in str_tab_t,
      p_office_id      in varchar2 default null)
      return str_tab_t
   is
      type filter_elements_t is table of at_text_filter_element%rowtype;
      l_office_id        varchar2(16) := cwms_util.get_db_office_id(p_office_id);
      l_office_code      integer := cwms_util.get_db_office_code(l_office_id);
      l_header_rec       at_text_filter%rowtype;
      l_elements         filter_elements_t;
      l_filters          str_tab_t;
      l_case_insensitive str_tab_t;
      l_is_regex         boolean;
      l_included str_tab_t := str_tab_t();
      l_excluded str_tab_t := str_tab_t();
      l_matched  str_tab_t := str_tab_t();
   begin
      l_header_rec.text_filter_id := trim(p_text_filter_id);
      begin
         select *
           into l_header_rec
           from at_text_filter
          where office_code in (l_office_code, cwms_util.db_office_code_all)
            and upper(text_filter_id) = upper(l_header_rec.text_filter_id);
      exception
         when no_data_found then
            cwms_err.raise(
               'ITEM_DOES_NOT_EXIST',
               'Text filter',
               l_office_id||'/'||l_header_rec.text_filter_id); 
      end;
      begin
         select *      
           bulk collect
           into l_elements
           from at_text_filter_element
          where text_filter_code = l_header_rec.text_filter_code
          order by element_sequence;
      exception
         when no_data_found then null;
      end;
      
      if p_values is not null and l_elements is not null then
         l_is_regex := l_header_rec.is_regex = 'T';
         if not l_is_regex then
            select cwms_util.normalize_wildcards(filter_text),
                   case
                   when regex_flags is null then 'F'
                   when instr(regex_flags, 'i') > 0 then 'T'
                   else 'F'
                   end
              bulk collect
              into l_filters,
                   l_case_insensitive
              from at_text_filter_element
             where text_filter_code = l_header_rec.text_filter_code
             order by element_sequence;
         end if;
         
         if l_elements(1).include = 'T' then
            l_excluded := p_values;
         else
            l_included := p_values;
         end if;
         for i in 1..l_elements.count loop
            if l_elements(i).include = 'T' then
               if l_is_regex then
                  if l_elements(i).regex_flags is not null then
                     select *
                       bulk collect
                       into l_matched
                       from table(l_excluded)
                      where regexp_like(column_value, l_elements(i).filter_text, l_elements(i).regex_flags); 
                  else
                     if l_header_rec.regex_flags is not null then
                        select *
                          bulk collect
                          into l_matched
                          from table(l_excluded)
                         where regexp_like(column_value, l_elements(i).filter_text, l_header_rec.regex_flags); 
                     else
                        select *
                          bulk collect
                          into l_matched
                          from table(l_excluded)
                         where regexp_like(column_value, l_elements(i).filter_text); 
                     end if;
                  end if;
               else
                  if l_case_insensitive(i) = 'T' or instr(l_header_rec.regex_flags, 'i') > 0 then
                     select *
                       bulk collect
                       into l_matched
                       from table(l_excluded)
                      where upper(column_value) like upper(l_filters(i)); 
                  else
                     select *
                       bulk collect
                       into l_matched
                       from table(l_excluded)
                      where column_value like l_filters(i); 
                  end if;
               end if;
               l_included := l_included multiset union all l_matched;
               l_excluded := l_excluded multiset except all l_matched;
            else
               if l_is_regex then
                  if l_elements(i).regex_flags is not null then
                     select *
                       bulk collect
                       into l_matched
                       from table(l_included)
                      where regexp_like(column_value, l_elements(i).filter_text, l_elements(i).regex_flags); 
                  else
                     if l_header_rec.regex_flags is not null then
                        select *
                          bulk collect
                          into l_matched
                          from table(l_included)
                         where regexp_like(column_value, l_elements(i).filter_text, l_header_rec.regex_flags); 
                     else
                        select *
                          bulk collect
                          into l_matched
                          from table(l_included)
                         where regexp_like(column_value, l_elements(i).filter_text); 
                     end if;
                  end if;
               else
                  if l_case_insensitive(i) = 'T' or instr(l_header_rec.regex_flags, 'i') > 0 then
                     select *
                       bulk collect
                       into l_matched
                       from table(l_included)
                      where upper(column_value) like upper(l_filters(i)); 
                  else
                     select *
                       bulk collect
                       into l_matched
                       from table(l_included)
                      where column_value like l_filters(i); 
                  end if;
               end if;
               l_included := l_included multiset except all l_matched;
               l_excluded := l_excluded multiset union all l_matched;
            end if;
         end loop;
      else 
         l_included := p_values;
      end if;
            
      return l_included;
   end filter_text;           
      
   function filter_text(
      p_text_filter_id in varchar2,
      p_value          in varchar2,
      p_office_id      in varchar2 default null)
      return varchar2
   is
      l_filtered str_tab_t;
   begin
      l_filtered := filter_text(p_text_filter_id, str_tab_t(p_value), p_office_id);
      return case l_filtered is null
                when true then null
                else l_filtered(0)
             end; 
   end filter_text;           
   
   function filter_text(
      p_filter in str_tab_t,
      p_values in str_tab_t,
      p_regex  in varchar2 default 'F')
      return str_tab_t
   is                      
      type filter_element_t is record(include boolean, flags varchar2(16), text varchar2(256));
      type filter_element_tab_t is table of filter_element_t;
      c_element_pattern1 constant varchar2(57) := '^\s*(i(n(c(l(u(de?)?)?)?)?)?|e(x(c(l(u(de?)?)?)?)?)?)\s*:';
      c_element_pattern2 constant varchar2(35) := '\s*:\s*f(l(a(gs?)?)?)?\s*=.*$';
      l_regex            boolean := cwms_util.is_true(p_regex);
      l_filter           filter_element_tab_t;
      l_pos              integer;
      l_case_insensitive str_tab_t;
      l_parts            str_tab_t;
      l_included         str_tab_t;
      l_excluded         str_tab_t;
      l_matched          str_tab_t;
   begin   
      if p_filter is null then
         l_included := p_values;
      else 
         ----------------------
         -- build the filter --
         ----------------------         
         l_filter := filter_element_tab_t();
         l_filter.extend(p_filter.count);
         for i in 1..p_filter.count loop
         
            l_pos := regexp_instr(p_filter(i), c_element_pattern1, 1, 1, 1, 'i'); 
            if l_pos = 0 then
               cwms_err.raise(
                  'ERROR',
                  'Filter element must be like (INCLUDE|EXCLUDE):<filter>[:FLAGS=<flags>]'
                  ||chr(10)
                  ||'<'||p_filter(i)||'>');
            end if;
            l_parts := str_tab_t(
               lower(trim(substr(p_filter(i), 1, l_pos-1))),
               substr(p_filter(i), l_pos));
            if substr(l_parts(1), 1, 1) = 'i' then
                  l_filter(i).include := true;
            else
                  l_filter(i).include := false;
            end if;

            l_pos := regexp_instr(l_parts(2), c_element_pattern2, 1, 1, 0, 'i');
            if l_pos = 0 then
               l_filter(i).text := l_parts(2);
               l_filter(i).flags := null;
            else   
               l_filter(i).text := substr(l_parts(2), 1, l_pos - 1);
               l_parts(2) := regexp_replace(substr(l_parts(2), l_pos), '\s+', null, 1, 0);
               l_parts(2) := lower(trim(substr(l_parts(2), instr(l_parts(2), '=') + 1))); 
               if instr(l_parts(2), 'm') != 0 then
                  l_filter(i).flags := l_filter(i).flags || 'm';
               end if;
               if instr(l_parts(2), 'n') != 0 then
                  l_filter(i).flags := l_filter(i).flags || 'n';
               end if;
               if instr(l_parts(2), 'x') != 0 then
                  l_filter(i).flags := l_filter(i).flags || 'x';
               end if;
               if instr(l_parts(2), 'i') != 0 then
                  l_filter(i).flags := l_filter(i).flags || 'i';
               end if;
            end if;
            if not l_regex then
               l_filter(i).text := cwms_util.normalize_wildcards(l_filter(i).text); 
            end if;
         end loop;
         ---------------------      
         -- filter the text --
         ---------------------
         if l_filter(1).include then
            l_included := str_tab_t();
            l_excluded := p_values;
         else
            l_included := p_values;
            l_excluded := p_values;
         end if;
         for i in 1..l_filter.count loop
            if l_filter(i).include then
               if l_regex then
                  if l_filter(i).flags is not null then
                     select *
                       bulk collect
                       into l_matched
                       from table(l_excluded)
                      where regexp_like(column_value, l_filter(i).text, l_filter(i).flags); 
                  else
                     select *
                       bulk collect
                       into l_matched
                       from table(l_excluded)
                      where regexp_like(column_value, l_filter(i).text); 
                  end if;
               else
                  if instr(l_filter(i).flags, 'i') > 0 then
                     select *
                       bulk collect
                       into l_matched
                       from table(l_excluded)
                      where upper(column_value) like upper(l_filter(i).text); 
                  else
                     select *
                       bulk collect
                       into l_matched
                       from table(l_excluded)
                      where column_value like l_filter(i).text; 
                  end if;
               end if;
               l_included := l_included multiset union all l_matched;
               l_excluded := l_excluded multiset except all l_matched;
            else
               if l_regex then
                  if l_filter(i).flags is not null then
                     select *
                       bulk collect
                       into l_matched
                       from table(l_included)
                      where regexp_like(column_value, l_filter(i).text, l_filter(i).flags); 
                  else
                     select *
                       bulk collect
                       into l_matched
                       from table(l_included)
                      where regexp_like(column_value, l_filter(i).text); 
                  end if;
               else
                  if instr(l_filter(i).flags, 'i') > 0 then
                     select *
                       bulk collect
                       into l_matched
                       from table(l_included)
                      where upper(column_value) like upper(l_filter(i).text); 
                  else
                     select *
                       bulk collect
                       into l_matched
                       from table(l_included)
                      where column_value like l_filter(i).text; 
                  end if;
               end if;
               l_included := l_included multiset except all l_matched;
               l_excluded := l_excluded multiset union all l_matched;
            end if;
         end loop;
      end if;
      return l_included;
   end filter_text;            
      
   function filter_text(
      p_filter in str_tab_t,
      p_value  in varchar2,
      p_regex  in varchar2 default 'F')
      return varchar2
   is
      l_filtered str_tab_t;
   begin
      l_filtered := filter_text(p_filter, str_tab_t(p_value), p_regex);
      return case l_filtered is null
                when true then null
                else l_filtered(0)
             end; 
    end filter_text;
end;
/

show errors;
commit;
prompt update for package spec cwms_util
set escape `;
create or replace package cwms_util
/**
 * Miscellaneous constants and procedures.
 *
 * @author Various
 * @since CWMS 2.0
 */
AS
   /**
    * Beginning of Unix epoch (01Jan1970 00:00:00 UTC) as a <code><big>DATE</big></code>.
    */
   l_epoch CONSTANT DATE
         := TO_DATE ('01Jan1970 00:00', 'ddmonyyyy hh24:mi') ;
   /**
    * Beginning of Sunday of the first full week of the Unix epoch (04Jan1970 00:00:00 UTC)
    * as a <code><big>DATE</big></code>.
    */
   l_epoch_wk_dy_1 CONSTANT DATE
         := TO_DATE ('04Jan1970 00:00', 'ddmonyyyy hh24:mi') ;
   /**
    * Store rule: Insert values at new times and replace any values at existing times, even
    * if incoming values are specified as missing
    */
   replace_all CONSTANT                      VARCHAR2 (16) := 'REPLACE ALL';
   /**
    * Store rule: Insert values at new times but do not replace any values at existing times
    */
   do_not_replace CONSTANT                   VARCHAR2 (16) := 'DO NOT REPLACE';
   /**
    * Store rule: Insert values at new times but do not replace any values at existing times
    * unless the existing values are specified as missing
    */
   replace_missing_values_only CONSTANT VARCHAR2 (32)
         := 'REPLACE MISSING VALUES ONLY' ;
   /**
    * Store rule: Insert values at new times and replace any values at existing times, unless
    * the incoming values are specified as missing
    */
   replace_with_non_missing CONSTANT VARCHAR2 (32)
         := 'REPLACE WITH NON MISSING' ;
   /**
    * Store rule: Delete all existing values in time window of incoming data and then
    * insert incoming data
    */
   delete_insert CONSTANT                    VARCHAR2 (16) := 'DELETE INSERT';
   /**
    * Delete action that specifies deletion of the specified identifier only; not
    * data dependent on the identifier is to be deleted.
    */
   delete_key CONSTANT                       VARCHAR2 (16) := 'DELETE KEY';
   /**
    * Delete action that specifies deletion of data dependent on the specified 
    * identifier only; the identifier itself is not to be deleted.
    */
   delete_data CONSTANT                      VARCHAR2 (22) := 'DELETE DATA';
   /**
    * Delete action that specifies deletion of specified identifier and all data
    * dependent on the specified identifier. 
    */
   delete_all CONSTANT                       VARCHAR2 (16) := 'DELETE ALL';
   /**
    * Delete action for time series equivalent to <code><big>delete_key</big></code>
    */       
   delete_ts_id CONSTANT                     VARCHAR2 (22) := 'DELETE TS ID';
   /**
    * Delete action for locations equivalent to <code><big>delete_key</big></code>
    */       
   delete_loc CONSTANT                       VARCHAR2 (22) := 'DELETE LOC';
   /**
    * Delete action for time series equivalent to <code><big>delete_data</big></code>
    */       
   delete_ts_data CONSTANT                   VARCHAR2 (22) := 'DELETE TS DATA';
   /**
    * Delete action for time series equivalent to <code><big>delete_all</big></code>
    */       
   delete_ts_cascade CONSTANT                VARCHAR2 (22) := 'DELETE TS CASCADE';
   /**
    * Delete action for locations equivalent to <code><big>delete_all</big></code>
    */       
   delete_loc_cascade CONSTANT               VARCHAR2 (22) := 'DELETE LOC CASCADE';
   /**
    * Cookie for specifying version date of non-versioned time series
    */       
   non_versioned CONSTANT                    DATE := DATE '1111-11-11';
   /**
    * Cookie for specifying all versions of a time series
    */
   all_version_dates CONSTANT                DATE := DATE '1010-10-10';
   /**
    * Cookie for specifying time series values
    */
   ts_values CONSTANT                        BINARY_INTEGER :=  1;
   /**
    * Cookie for specifying time series standard text
    */
   ts_std_text CONSTANT                      BINARY_INTEGER :=  2;
   /**
    * Cookie for specifying time series non-standard text
    */
   ts_text CONSTANT                          BINARY_INTEGER :=  4;
   /**
    * Cookie for specifying time series standard and non-standard text
    */
   ts_all_text CONSTANT                      BINARY_INTEGER :=  6;
   /**
    * Cookie for specifying time series binary objects
    */
   ts_binary CONSTANT                        BINARY_INTEGER :=  8;
   /**
    * Cookie for specifying all time series items except values
    */
   ts_all_non_values CONSTANT                BINARY_INTEGER := -2;
   /**
    * Cookie for specifying all time series items
    */
   ts_all CONSTANT                           BINARY_INTEGER := -1;
   /**
    * Cookie for specifying UTC Interval Offset for irregular time series
    */       
   utc_offset_irregular CONSTANT             NUMBER := -2147483648;
   /**
    * Cookie for specifying as-yet undefined UTC Interval Offset for regular time series 
    */       
   utc_offset_undefined CONSTANT             NUMBER := 2147483647;
   /**
    * Value indicating <code><big>TRUE</big></code> for routines that take numerical
    * representation of boolean values     
    */       
   true_num CONSTANT                         NUMBER := 1;
   /**
    * Value indicating <code><big>FALSE</big></code> for routines that take numerical
    * representation of boolean values     
    */       
   false_num CONSTANT                        NUMBER := 0;
   /**
    * Maximum length of the base portion of certain CWMS identifiers (location, parameter, etc...) 
    */       
   max_base_id_length CONSTANT               NUMBER := 16;
   /**
    * Maximum length of the sub portion of certain CWMS identifiers (location, parameter, etc...) 
    */       
   max_sub_id_length CONSTANT                NUMBER := 32;
   /**
    * Maximum total length of certain CWMS identifiers (location, parameter, etc...) 
    */       
   max_full_id_length CONSTANT NUMBER
         := max_base_id_length + max_sub_id_length + 1 ;
   /**
    * Code in CWMS_OFFICE table that represents the "CWMS" office (all offices) 
    */       
   db_office_code_all CONSTANT               NUMBER := 53;
   /**
    * Code in CWMS_INTERVAL table that represents irregular intervals
    * Commented out. User is_irregular_code function
    */
   --irregular_interval_code CONSTANT          NUMBER := 29;
   /**
    * Field separator used in text recordset representation (ASCII GS char)
    */       
   field_separator CONSTANT                  VARCHAR2 (1) := CHR (29);
   /**
    * Record separator used in text recordset representation (ASCII RS char)
    */       
   record_separator CONSTANT                 VARCHAR2 (1) := CHR (30);
   /**
    * Default escape character
    */       
   escape_char CONSTANT                      VARCHAR2 (1) := '\';
   /**
    * ODBC-style timestamp format for PL/SQL 
    */       
   odbc_ts_fmt constant varchar2(50) := '"{ts ''"yyyy-mm-dd hh24:mi:ss"''}"';
   /**
    * ODBC-style date format for PL/SQL 
    */       
   odbc_d_fmt  constant varchar2(50) := '"{d ''"yyyy-mm-dd"''}"';
   /**
    * Database privilige for retrieving data
    */       
   read_privilege CONSTANT                   NUMBER := 4;
   /**
    * Database privilege for storing data
    */       
   write_privilege CONSTANT                  NUMBER := 2;
   dba_users CONSTANT                        NUMBER := 1;
   dbi_users CONSTANT                        NUMBER := 2;
   data_exchange_mgr CONSTANT                NUMBER := 4;
   data_acquisition_mgr CONSTANT             NUMBER := 8;
   ts_creator CONSTANT                       NUMBER := 16;
   vt_mgr CONSTANT                           NUMBER := 32;
   all_users CONSTANT                        NUMBER := 64;
   /**
    * Beginning of Unix epoch (01Jan1970 00:00:00 UTC) as a <code><big>TIMESTAMP</big></code>.
    */
   epoch CONSTANT timestamp
         := STANDARD.TO_TIMESTAMP ('1970/01/01/ 00:00:00',
                                   'yyyy/mm/dd hh24:mi:ss');
   /**
    * Contains names of all constants that can be used with expression evaluation.
    */                                                             
   expression_constants str_tab_t := str_tab_t('E','PI');
   /**
    * Contains all mathematical operators that can be used with expression evaluation.
    */                                                             
   expression_operators str_tab_t := str_tab_t('+','-','*','/','//','%','^');
   /**
    * Contains names of all functions that can be used with expression evaluation.
    */                                                             
   expression_functions str_tab_t := str_tab_t(
      'ABS','ACOS','ASIN','ATAN','CEIL','COS','EXP','FLOOR',
      'INV','LN','LOG','NEG','ROUND','SIGN','SIN','SQRT','TAN','TRUNC');
   /**
    * Contains all valid logical comparision operators
    */   
   comparitors str_tab_t := str_tab_t('=','!=','<>','>','>=','<','<=','EQ','NE','GT','GE','LT','LE');
   /**
    * Contains all valid logical combination operators
    */   
   combinators str_tab_t := str_tab_t('AND', 'OR', 'XOR', 'NOT');   
   /**
    * Record type contained in <code><big>cat_unit_tab_t</big></code>, which is
    * returned by <code><big>get_valid_units_tab</big></code>    
    */             
   TYPE cat_unit_rec_t IS RECORD (unit_id VARCHAR2 (16));
   /**
    * Table type returned by <code><big>get_valid_units_tab</big></code>    
    */             
   TYPE cat_unit_tab_t IS TABLE OF cat_unit_rec_t;
   /**
     * Retrieves the nth delimited string.
     * <br>
     * Sequential delimiters in the source string result in null fields in the table,
     * except that if no delimiter is supplied, sequential whitespace characters are
     * treated as a single delimiter.
     * <br>
     * If no string can be found to satisfy the input parameters, the function return
     * <code><big>NULL</big></code>.
     *
     * @param p_text The text to be split.
     *
     * @param p_return_index Specifies 'n' (which delimited string to return).
     *
     * @param p_separator The separator string on which to split the text. If not
     *   specified or specified as <code><big>NULL</big></code>, the input text will be split
     *   on all whitespace occurrences.
     *
     * @param p_max_split Specifies the maximum number of splits to perform.  The
     *   maximum number of items returned will be one greater than this number. If
     *   not specified or specified as <code><big>NULL</big></code>, no maximum will be imposed
     *   and the input text will be split on every occurrence of the specified
     *   separator.
     *
     * @return The nth delimited string in the input string or <code><big>NULL</big></code>
     *   if no such string exists.
     */
   function split_text (p_text        in varchar2,
                p_return_index in integer ,
                        p_separator   IN VARCHAR2 DEFAULT NULL ,
                        p_max_split   in integer default null
                       )
      RETURN VARCHAR2;
   /**
     * Splits string into a table of strings using the specified delimiter.
     * If no delmiter is specified, the string is split around whitespace.
     * <br>
     * Sequential delimiters in the source string result in null fields in the table,
     * except that if no delimiter is supplied, sequential whitespace characters are
     * treated as a single delimiter.
     *
     * @param p_text The text to be split.
     *
     * @param p_separator The separator string on which to split the text. If not
     *   specified or specified as <code><big>NULL</big></code>, the input text will be split
     *   on all whitespace occurrences.
     *
     * @param p_max_split Specifies the maximum number of splits to perform.  The
     *   maximum number of items returned will be one greater than this number. If
     *   not specified or specified as <code><big>NULL</big></code>, no maximum will be imposed
     *   and the input text will be split on every occurrence of the specified
     *   separator.
     *
     * @return A table of strings.
     */
   FUNCTION split_text (p_text        IN VARCHAR2,
                        p_separator   IN VARCHAR2 DEFAULT NULL ,
                        p_max_split   IN INTEGER DEFAULT NULL
                       )
      RETURN str_tab_t result_cache;
   /**
     * Splits string into a table of strings using the specified delimiter.
     * If no delmiter is specified, the string is split around whitespace.
     * <br>
     * Sequential delimiters in the source string result in null fields in the table,
     * except that if no delimiter is supplied, sequential whitespace characters are
     * treated as a single delimiter.
     *
     * @param p_text The text to be split.
     *
     * @param p_separator The separator string on which to split the text. If not
     *   specified or specified as <code><big>NULL</big></code>, the input text will be split
     *   on all whitespace occurrences.
     *
     * @param p_max_split Specifies the maximum number of splits to perform.  The
     *   maximum number of items returned will be one greater than this number. If
     *   not specified or specified as <code><big>NULL</big></code>, no maximum will be imposed
     *   and the input text will be split on every occurrence of the specified
     *   separator.
     *
     * @return A table of strings.
     */
   FUNCTION split_text (p_text        IN CLOB,
                        p_separator   IN VARCHAR2 DEFAULT NULL ,
                        p_max_split   IN INTEGER DEFAULT NULL
                       )
      RETURN str_tab_t; 
   function split_text_regexp(
      p_text               in varchar2,
      p_separator          in varchar2,
      p_include_separators in varchar2 default 'F',
      p_match_parameter    in varchar2 default 'c',
      p_max_split          in integer default null)
      return str_tab_t;      
   /**
     * Joins a table of strings into a single string using the specified delimiter.
     * If no delimiter is supplied or is specified as <code><big>NULL</big></code>, the input
     * strings are simply concatenated together.
     * <p>
     * Null strings in the table result in adjacent delimiters in the returned string.
     *
     * @param p_text_tab A table of strings to be joined
     *
     * @param p_separator The string to insert between the strings in <code><big>p_tab_text</big></code>
     *
     * @return The joined string
     */
   FUNCTION join_text (p_text_tab    IN str_tab_t,
                       p_separator   IN VARCHAR2 DEFAULT NULL
                      )
      RETURN VARCHAR2;
   /**
     * Formats the XML in the CLOB to have one element tag per line, indented by
     * the specified string.  The input is overwritten with the output.
     *
     * @param p_xml_clob <code><big>input: </big></code> The XML instance to be formatted<br>
     *                   <code><big>output:</big></code> The formatted XML instance
     * @param p_indent The string to use for indentation
     */
   PROCEDURE format_xml (p_xml_clob   IN OUT NOCOPY CLOB,
                         p_indent     IN            VARCHAR2 DEFAULT CHR (9)
                        );
   /**
    * Parses a text recordset into a table of tables of strings. Records are delimited by the 
    * <code><big>record_separator</big></code> character. Fields are delmited by the 
    * <code><big>field_separator</big></code> character.
    * 
    * @param p_clob the delimeted recordset to parse
    * @return a table of tables of strings. Each record in the recordset becomes one
    *         outer row (table of fields) in the retured table, with fields within that 
    *         record becoming rows of the inner table.
    *         
    * @see record_separator
    * @see field_separator                                  
    */
   FUNCTION parse_clob_recordset (p_clob IN CLOB)
      RETURN str_tab_tab_t;
   /**
    * Parses a text recordset into a table of tables of strings. Records are delimited by the 
    * <code><big>record_separator</big></code> character. Fields are delmited by the 
    * <code><big>field_separator</big></code> character.
    * 
    * @param p_string the delimeted recordset to parse
    * @return a table of tables of strings. Each record in the recordset becomes one
    *         outer row (table of fields) in the retured table, with fields within that 
    *         record becoming rows of the inner table.
    *         
    * @see record_separator
    * @see field_separator                                  
    */
   FUNCTION parse_string_recordset (p_string IN VARCHAR2)
      RETURN str_tab_tab_t;
   TYPE ts_list
   IS
      TABLE OF VARCHAR2 (200)
         INDEX BY BINARY_INTEGER;
   /**
    * Retrieves the dms minutes portion of an angle specified in decimal degrees.
    * 
    * @param p_decimal_degrees the input angle
    *     
    * @return the minutes portion of the angle. Will always be an integer            
    */       
   FUNCTION min_dms (p_decimal_degrees IN NUMBER)
      RETURN NUMBER;
   /**
    * Retrieves the dms seconds portion of an angle specified in decimal degrees.
    * 
    * @param p_decimal_degrees the input angle        
    *     
    * @return the seconds portion of the angle. May have fractional portion            
    */       
   FUNCTION sec_dms (p_decimal_degrees IN NUMBER)
      RETURN NUMBER;
   /**
    * Retrieves the dm minutes portion of an angle specified in decimal degrees.
    * 
    * @param p_decimal_degrees the input angle        
    *     
    * @return the minutes portion of the angle. May have fractional portion            
    */       
   FUNCTION min_dm (p_decimal_degrees IN NUMBER)
      RETURN NUMBER;
   /**
    * Retrieves a time zone equivalent to the specified time zone.  This is used
    * specifically to filter out PST and CST time zones, which define DST,
    * which is unexpected for these zones.
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">p_timezone</th>
    *     <th class="descr">return value</th>
    *   </tr>
    *   <tr>
    *     <td class="descr">'PST'</td>
    *     <td class="descr">'Etc/GMT+8'</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'CST'</td>
    *     <td class="descr">'Etc/GMT+6'</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">other</td>
    *     <td class="descr">p_timezone, corrected for case</td>
    *   </tr>
    * </table>
    * @param p_timezone the specified time zone
    *
    * @return An equivalent time zone. Except for PST and CST this is just a
    *         case-corrected version of p_timezone.
    */
   FUNCTION get_timezone (p_timezone IN VARCHAR2)
      RETURN VARCHAR2;  
                      
   /**
     * Formats a date/time for use in XML
     *
     * @param p_local_time
     * @param p_local_tz
     *
     * @return the XML-formatted date/time 
     *
     */      
   FUNCTION get_xml_time(
      p_local_time in date,
      p_local_tz   in varchar2)
      RETURN VARCHAR2;      

   /**
    * Corrects times withing daylight savings time in time zones PST and CST.  These
    * time zones are not expected to observer DST, but erroneously do.  This function
    * corrects the affected times.
    *
    * @param p_time The input time that may need correction
    *
    * @return The time which has been corrected if necessary
    */
   FUNCTION fixup_timezone (p_time IN TIMESTAMP WITH TIME ZONE)
      RETURN TIMESTAMP WITH TIME ZONE;
   /**
    * Converts a specified<code><big>DATE</big></code> from a specified time zone
    * to UTC
    * 
    * @param p_in_date the date to convert to UTC
    * @param p_in_tz the time zone
    * 
    * @return an equivalent <code><big>DATE</big></code> in UTC                         
    */       
   FUNCTION date_from_tz_to_utc (p_in_date IN DATE, p_in_tz IN VARCHAR2)
      RETURN DATE;
   /**
    * Converts a specified<code><big>DATE</big></code> from one time zone to another
    *         
    * @param p_in_date the date to convert to UTC
    * @param p_from_tz the original time zone                
    * @param p_to_tz the desired time zone                
    * 
    * @return an equivalent <code><big>DATE</big></code> in the desired time zone                         
    */       
   FUNCTION change_timezone (
      p_in_date IN DATE, 
      p_from_tz IN VARCHAR2, 
      p_to_tz   IN VARCHAR2 default 'UTC')
      RETURN DATE result_cache;
   /**
    * Converts a specified<code><big>TIMESTAMP</big></code> from one time zone to another
    *
    * @param p_in_date the date to convert to UTC
    * @param p_from_tz the original time zone
    * @param p_to_tz the desired time zone
    *
    * @return an equivalent <code><big>DATE</big></code> in the desired time zone
    */
   FUNCTION change_timezone (
      p_in_date IN TIMESTAMP,
      p_from_tz IN VARCHAR2,
      p_to_tz   IN VARCHAR2 default 'UTC')
      RETURN TIMESTAMP result_cache;
   /**
    * Returns whether the upper case of the input is <code><big>'T'</big></code>
    * or <code><big>'TRUE'</big></code>
    *         
    * @param p_true_false 'Boolean' text input    
    */       
   FUNCTION is_true (p_true_false IN VARCHAR2)
      RETURN BOOLEAN result_cache;
   /**
    * Returns whether the upper case of the input is <code><big>'F'</big></code>
    * or <code><big>'FALSE'</big></code>    
    *         
    * @param p_true_false 'Boolean' text input
    * 
    * @return <code><big>TRUE</big></code> or <code><big>FALSE</big></code>            
    */       
   FUNCTION is_false (p_true_false IN VARCHAR2)
      RETURN BOOLEAN result_cache;
   /**
    * Returns a Boolean based on the input.
    * <ul>
    * <li><code><big>'T'    </big></code> - returns <code><big>TRUE</big></code></li>             
    * <li><code><big>'TRUE' </big></code> - returns <code><big>TRUE</big></code></li>             
    * <li><code><big>'F'    </big></code> - returns <code><big>FALSE</big></code></li>             
    * <li><code><big>'FALSE'</big></code> - returns <code><big>FALSE</big></code></li>
    * </ul>
    * 
    * @param p_true_false 'Boolean' text input    
    * @throws INVALID_T_F_FLAG if input is other than listed above.                         
    * 
    * @return <code><big>TRUE</big></code> or <code><big>FALSE</big></code>            
    */       
   FUNCTION return_true_or_false (p_true_false IN VARCHAR2)
      RETURN BOOLEAN result_cache;
   /**
    * Returns <code><big>'T'</big></code> or <code><big>'F'</big></code> text based on the input.
    * <ul>
    * <li><code><big>'T'    </big></code> - returns <code><big>'T'</big></code></li>             
    * <li><code><big>'TRUE' </big></code> - returns <code><big>'T'</big></code></li>             
    * <li><code><big>'F'    </big></code> - returns <code><big>'F'</big></code></li>             
    * <li><code><big>'FALSE'</big></code> - returns <code><big>'F'</big></code></li>
    * </ul>
    * 
    * @param p_true_false 'Boolean' text input    
    * @throws INVALID_T_F_FLAG if input is other than listed above.                         
    * 
    * @return <code><big>'T'</big></code> or <code><big>'F'</big></code>            
    */       
   FUNCTION return_t_or_f_flag (p_true_false IN VARCHAR2)
      RETURN VARCHAR2 result_cache;
   /**
    * Retrieves the base portion of a base-sub identifier
    * 
    * @param p_full_id the identifier to parse for the base portion
    *     
    * @return the base portion of the identifier            
    */       
   FUNCTION get_base_id (p_full_id IN VARCHAR2)
      RETURN VARCHAR2 result_cache;
   /**
    * Retrieves the (possibly null) sub portion of a base-sub identifier
    * 
    * @param p_full_id the identifier to parse for the sub portion        
    *     
    * @return the (possibly null) sub portion of the identifier            
    */       
   FUNCTION get_sub_id (p_full_id IN VARCHAR2)
      RETURN VARCHAR2 result_cache;
   /**
    * Retrieves the base parameter code of a full parameter identifier
    * 
    * @param p_param_id the identifier for which to return the base parameter code
    * @param p_is_full_id flag specifying whether <code><big>p_param_id</big></code> is a full id or base id
    *     
    * @return the base parameter code            
    */       
   FUNCTION get_base_param_code (
      p_param_id   IN VARCHAR2, 
      p_is_full_id IN VARCHAR2 DEFAULT 'F')
      return number result_cache;
   /**
    * Retrieves the interval minutes of a time series
    * 
    * @param p_cwms_ts_code the code of the time series as presented in TS_CODE
    *        column of the CWMS_V_TS_ID view
    *        
    * @return the interval minutes of the time series                    
    */       
   FUNCTION get_ts_interval (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER result_cache;
   /**
    * Creates a full identifier from base and sub identifier portions
    * 
    * @param p_base_id the base portion of the identifier
    * @param p_sub_id the (possibly null) portion of the identifier
    * 
    * @return the full identifier. If the sub portion of the identifier is <code><big>NULL</big></code>
    *         the full identifier will be the same as the base portion.  Otherwise
    *         the full identifier will be the base portion followed by a hyphen character
    *         ('-') followed by the sub portion.                                
    */       
   FUNCTION concat_base_sub_id (p_base_id IN VARCHAR2, p_sub_id IN VARCHAR2)
      RETURN VARCHAR2 result_cache;
   /**
    * Creates a fill time series identifier from the portions. The base parameter,
    * parameter type, interval, and duration portions are verified in the process.
    * 
    * @param p_base_location_id the base portion of the location portion
    * @param p_sub_location_id the sub portion of the location portion                
    * @param p_base_parameter_id the base portion of the parameter portion. This portion is verified
    * @param p_sub_parameter_id the sub portion of the parameter portion
    * @param p_parameter_type_id the parameter type portion. This portion is verified
    * @param p_interval_id the interval portion. This portion is verified
    * @param p_duration_id the duration portion. This portion is verified
    * @param p_version_id the version portion                                
    * 
    * @return the full time series identifier
    * 
    * @throws NO_DATA_FOUND if any of the verified portions are invalid
    * @throws ERROR if the parameter type portion is "Inst" and the duration portion
    *         is not "0"                        
    */       
   FUNCTION concat_ts_id (p_base_location_id    IN VARCHAR2,
                          p_sub_location_id     IN VARCHAR2,
                          p_base_parameter_id   IN VARCHAR2,
                          p_sub_parameter_id    IN VARCHAR2,
                          p_parameter_type_id   IN VARCHAR2,
                          p_interval_id         IN VARCHAR2,
                          p_duration_id         IN VARCHAR2,
                          p_version_id          IN VARCHAR2
                         )
      RETURN VARCHAR2;
   /**
    * Returns the primary office id of user calling the function
    */       
   FUNCTION user_office_id
      RETURN VARCHAR2;
   /**
    * Returns the primary office code of user calling the function
    */       
   FUNCTION user_office_code
      RETURN NUMBER;
   /**
    * Returns the office code of specified or default office identifier
    * 
    * @param p_office_id the office identifier for which to find the code. If
    *        <code><big>NULL</big></code> the calling user's office is used
    *        
    * @return the office code of the specified or default office identifier
    *
    * @throws INVALID_OFFICE_ID if the specified office identifier is invalid                             
    */       
   FUNCTION get_office_code (p_office_id IN VARCHAR2 DEFAULT NULL )
      RETURN NUMBER;
   /**
    * Returns the specified or default office identifier
    * 
    * @param p_office_id the office identifier. If <code><big>NULL</big></code>
    *        the calling user's office identifier is returned. Otherwise this 
    *        parameter is returned                
    *
    * @throws INVALID_OFFICE_ID if the specified office identifier is invalid
    */       
   FUNCTION get_db_office_id (p_db_office_id IN VARCHAR2 DEFAULT NULL )
      RETURN VARCHAR2;
   /**
    * Retrieves the location identifier base on a location code.
    * 
    * @param p_location_code the location code for which to retrieve the location
    *        identifier
    * @param p_prepend_office specifies whether the location identifer will be
    *        prepended with the location's office identifier and '/'
    *        <ul>
    *        <li><code><big>'T'</big></code> - format = `&lt;office_id`&gt;/`&lt;location_id`&gt;</li>        
    *        <li><code><big>'F'</big></code> - format = `&lt;location_id`&gt;</li>
    *        </ul>            
    *        
    * @return the location identifier with or without the office identifier prepended.
    */       
   FUNCTION get_location_id (
      p_location_code  IN NUMBER,
      p_prepend_office IN VARCHAR2 DEFAULT 'F')
      RETURN VARCHAR2;
   /**
    * Retrieves a parameter identifier based on a parameter code
    * 
    * @param p_parameter_code the parameter code for which to find the identifier
    * 
    * @return the paramter identifier associated with the specified code                
    */       
   FUNCTION get_parameter_id (p_parameter_code IN NUMBER)
      RETURN VARCHAR2 result_cache;
   /**
    * Retrieves a time zone code based on a time zone name
    * 
    * @param p_time_zone_name the time zone name for which to find the code
    * 
    * @return the time zone code associated with the time zone name                
    */       
   FUNCTION get_time_zone_code (p_time_zone_name IN VARCHAR2)
      RETURN NUMBER;
   /**
    * Retrieves a proper time zone name based on a time zone name or alias
    *
    * @param p_time_zone_name the time zone name or alias for which to find the proper name
    *
    * @return the proper time zone name associated with the time zone name or alias
    */
   FUNCTION get_time_zone_name (p_time_zone_name IN VARCHAR2)
      RETURN VARCHAR2;
   --------------------------------------------------------------------------------
   -- function get_tz_usage_code
   --
   FUNCTION get_tz_usage_code (p_tz_usage_id IN VARCHAR2)
      RETURN NUMBER;
   /**
    * Retrieves the schema item name. If the input is an actual schema item name
    * it will be returned.  If the input is a public synonym, the associated
    * schema item name will be returned         
    * 
    * @param p_synonym a public synonym or schema item name
    * 
    * @return the schema item name                
    */       
   FUNCTION get_real_name (p_synonym IN VARCHAR2)
      RETURN VARCHAR2;
   /**
    * Returns the office code of specified or default office identifier
    * 
    * @param p_office_id the office identifier for which to find the code. If
    *        <code><big>NULL</big></code> the calling user's office is used
    *        
    * @return the office code of the specified or default office identifier
    *
    * @throws INVALID_OFFICE_ID if the specified office identifier is invalid                             
    */       
   FUNCTION get_db_office_code (p_office_id IN VARCHAR2 DEFAULT NULL )
      RETURN NUMBER;
   /**
    * Returns the office id of specified office code
    *
    * @param p_db_office_code  the office code for which to find the id. 
    *
    * @return the office id of the specified code
    *
    */
   FUNCTION get_db_office_id_from_code (p_db_office_code IN NUMBER)
      RETURN VARCHAR2;
   /**
    * Replace glob wildcard chars (?,*) with SQL ones (_,%), using '\\' as an
    * escape character.
    * 
    * @param p_string the glob wildcarded string to convert a SQL LIKE string. If
    *        <code><big>NULL</big></code> the furnction returns '%'    
    * @param p_recognize_sql specifies whether SQL wildcars in the input will be
    *        recognized as wildcards                
    * <ul>
    * <li><code><big>TRUE </big></code> - SQL wildcards are retained as wildcards in the returned string</li>             
    * <li><code><big>FALSE</big></code> - SQL wildcards become literal characters in the returned string</li>
    * </ul>
    * <code>
    * <table border="1" cellspacing="0" cellpadding="5">
    *   <tr><td rowspan="3" align="center">Input String</td><td colspan="5" align="center">Output String</td></tr>
    *   <tr><td colspan="4" align="center">Recognize SQL Wildcards?</td><td rowspan="2">Different?</td></tr>
    *   <tr><td>No     </td><td>Comments </td><td>Yes</td><td>Comments</td></tr>            
    *   <tr><td>%      </td><td>\\%    </td><td>literal '%'                </td><td>%      </td><td>multi-wildcard    </td><td>Yes</td></tr>
    *   <tr><td>_      </td><td>\\_    </td><td>literal '_'                </td><td>_      </td><td>single-wildcard   </td><td>Yes</td></tr>
    *   <tr><td>*      </td><td>%      </td><td>multi-wildcard             </td><td>%      </td><td>multi-wildcard    </td><td>No </td></tr>
    *   <tr><td>?      </td><td>_      </td><td>single-wildcard            </td><td>_      </td><td>single-wildcard   </td><td>No </td></tr>
    *   <tr><td>\\%    </td><td>       </td><td>not allowed                </td><td>\\%    </td><td>literal '%'       </td><td>Yes</td></tr>
    *   <tr><td>\\_    </td><td>       </td><td>not allowed                </td><td>\\_    </td><td>literal '_'       </td><td>Yes</td></tr>
    *   <tr><td>\\*    </td><td>*      </td><td>literal '*'                </td><td>*      </td><td>literal '*'       </td><td>No </td></tr>
    *   <tr><td>\\?    </td><td>?      </td><td>literal '?'                </td><td>?      </td><td>literal '?'       </td><td>No </td></tr>
    *   <tr><td>\\\\\\%</td><td>\\\\\\%</td><td>literal '\\' + literal '%' </td><td>\\\\\\%</td><td>literal '\\' + mwc</td><td>Yes</td></tr>
    *   <tr><td>\\\\\\_</td><td>\\\\\\_</td><td>literal '\\' + literal '\\'</td><td>\\\\\\_</td><td>literal '\\' + swc</td><td>Yes</td></tr>
    *   <tr><td>\\\\\\*</td><td>\\\\\\%</td><td>literal '\\' + mwc         </td><td>\\\\\\%</td><td>literal '\\' + mwc</td><td>No </td></tr>
    *   <tr><td>\\\\\\?</td><td>\\\\\\_</td><td>literal '\\' + swc         </td><td>\\\\\\_</td><td>literal '\\' + swc</td><td>No </td></tr>
    * </table>        
    * </code>
    *           
    * @return a SQL LIKE string       
    * 
    * @throws ERROR if the input string ends in an odd number of '\\' characters
    * @throws ERROR if the input string contains '\\%' or '\\_' and <code><big>p_recognize_sql</big></code>
    *               is <code><big>FALSE</big></code>                       
    */       
   FUNCTION normalize_wildcards (p_string          IN VARCHAR2,
                                 p_recognize_sql      BOOLEAN DEFAULT FALSE
                                )
      RETURN VARCHAR2;
   /**
    * Replace SQL wildcard chars (_,%) with glob ones (?,*), using '\\' as an
    * escape character.
    * 
    * @param p_string the SQL wildcarded string to convert a glob pattern string. If
    *        <code><big>NULL</big></code> the furnction returns '*'    
    *           
    * @return a glob pattern string
    * 
    * @throws ERROR if the input string ends in an odd number of '\\' characters               
    */       
   FUNCTION denormalize_wildcards (p_string IN VARCHAR2)
      RETURN VARCHAR2;
   /**
    * Parses a time series identifier into its various parts.
    * 
    * @param p_base_location_id the base portion of the location portion
    * @param p_sub_location_id the sub portion of the location portion                
    * @param p_base_parameter_id the base portion of the parameter portion
    * @param p_sub_parameter_id the sub portion of the parameter portion
    * @param p_parameter_type_id the parameter type portion
    * @param p_interval_id the interval portion
    * @param p_duration_id the duration portion
    * @param p_version_id the version portion
    * @param p_cwms_ts_id the full time series identifier                                    
    */       
   PROCEDURE parse_ts_id (p_base_location_id       OUT VARCHAR2,
                          p_sub_location_id        OUT VARCHAR2,
                          p_base_parameter_id      OUT VARCHAR2,
                          p_sub_parameter_id       OUT VARCHAR2,
                          p_parameter_type_id      OUT VARCHAR2,
                          p_interval_id            OUT VARCHAR2,
                          p_duration_id            OUT VARCHAR2,
                          p_version_id             OUT VARCHAR2,
                          p_cwms_ts_id          IN     VARCHAR2
                         );
   /**
    * Generates a multipart predicate of LIKE clauses for a single column.  The
    * input is a shorthand notation of the predicate, the name of the column, and
    * whether to use uppercase matches.
    * <p>
    * <b>Patterns</b>    
    * This routine uses glob wildcard characters and not SQL wildcard characters
    * <ul>
    *   <li><code><big><b>*</b></big></code> - matches zero or more occurences of any character</li>                
    *   <li><code><big><b>?</b></big></code> - matches zero or one occurence of any character</li>
    * </ul>
    * To indicate a literal '*' or '?' in the pattern, precede it immediately with
    * the backslash character ('\\') to escape it (e.g., \\*  \\?)        
    * <p>
    * The shorthand input is comprised of one or more glob patterns separated by 
    * logical operators (AND, OR, NOT) and  If one of the patterns includes blank spaces, 
    * that pattern must be enclosed in double quotes (e.g. "*some pattern?"). To indicate
    * a literal '"' in the pattern, escape it as mentioned above (e.g., 'some\\"pattern')    
    * <p>                                        
    * <b>Logical Operators</b>
    * Logical operators may be specified as follows:
    * <ul>
    *   <li><code><big><b>AND</b></big></code>
    *     <ul>
    *       <li>may be specified explicitly by the word <code><big>'AND'</big></code></li>    
    *       <li>may be specified implicitly by the absence of the word <code><big>'OR'</big></code></li>    
    *     </ul>        
    *   </li>     
    *   <li><code><big><b>OR</b></big></code>
    *     <ul>
    *       <li>must be specified explicitly by the word <code><big>'OR'</big></code></li>    
    *     </ul>        
    *   </li>     
    *   <li><code><big><b>NOT</b></big></code>
    *     <ul>
    *       <li>may be specified explicitly by the word <code><big>'NOT'</big></code></li>    
    *       <li>may be specified explicitly by prepending the minus character ('-') to a pattern</li>    
    *     </ul>        
    *   </li>     
    * </ul>         
    * <p>                                        
    * <b>Examples</b>
    * <p>    
    * <code><table border="1" cellspacing="0" cellpadding="5">
    *   <tr><td colspan="2" align="center">p_search_column='COL', p_use_upper=TRUE</td></tr>     
    *   <tr><td>*abc* AND *123*</td><td>UPPER(COL) LIKE %ABC% AND UPPER(COL) LIKE %123%</td></tr>     
    *   <tr><td>*abc* AND NOT *123*</td><td>UPPER(COL) LIKE %ABC% AND UPPER(COL) NOT LIKE %123%</td></tr>     
    *   <tr><td>*abc* *123*</td><td>UPPER(COL) LIKE %ABC% AND UPPER(COL) LIKE %123%</td></tr>     
    *   <tr><td>*abc* -*123*</td><td>UPPER(COL) LIKE %ABC% AND UPPER(COL) NOT LIKE %123%</td></tr>     
    *   <tr><td>*abc* OR *123\\*</td><td>UPPER(COL) LIKE %ABC% OR UPPER(COL) LIKE %123*</td></tr>     
    *   <tr><td>*abc* OR -*123\\*</td><td>UPPER(COL) LIKE %ABC% OR UPPER(COL) NOT LIKE %123*</td></tr>     
    *   <tr><td>*abc* OR NOT *123\\*</td><td>UPPER(COL) LIKE %ABC% OR UPPER(COL) NOT LIKE %123*</td></tr>     
    * </table></code>
    * <p>            
    * <code><table border="1" cellspacing="0" cellpadding="5">
    *   <tr><td colspan="2" align="center">p_search_column='COL', p_use_upper=FALSE</td></tr>     
    *   <tr><td>*abc* AND *123*</td><td>COL LIKE %abc% AND COL LIKE %123%</td></tr>     
    *   <tr><td>*abc* AND NOT *123*</td><td>COL LIKE %abc% AND COL NOT LIKE %123%</td></tr>     
    *   <tr><td>*abc* *123*</td><td>COL LIKE %abc% AND COL LIKE %123%</td></tr>     
    *   <tr><td>*abc* -*123*</td><td>COL LIKE %abc% AND COL NOT LIKE %123%</td></tr>     
    *   <tr><td>*abc* OR *123\\*</td><td>COL LIKE %abc% OR COL LIKE %123*</td></tr>     
    *   <tr><td>*abc* OR -*123\\*</td><td>COL LIKE %abc% OR COL NOT LIKE %123*</td></tr>     
    *   <tr><td>*abc* OR NOT *123\\*</td><td>COL LIKE %abc% OR COL NOT LIKE %123*</td></tr>     
    * </table></code>        
    *          
    * @param p_search_patterns the shorthand notation as described above.  If <code><big>NULL</big></code>
    *        the generated predicate is COLUMN_NAME LIKE %
    * @param p_search_column the column name to use in the generated predicate
    * @param p_use_upper specifies whether the matching should be performed on
    *        uppercase versions of the input and column (specifies case insensitve
    *        matching)                                
    *
    * @return the generated predicate         
    */       
   FUNCTION parse_search_string (p_search_patterns   IN VARCHAR2,
                                 p_search_column     IN VARCHAR2,
                                 p_use_upper         IN BOOLEAN DEFAULT TRUE
                                )
      RETURN VARCHAR2;
   /**
    * Strips all leading and trailing whitespace and non-printable chars from a string.
    * 
    * @param p_text the string to strip
    * 
    * @return the input string with all leading and trailing whitespace non-printable chars removed                
    */          
   FUNCTION strip (p_text IN VARCHAR2)
      RETURN VARCHAR2;
   /**
    * Parses an ISO 8601 formatted time string into a <code><big>TIMESTAMP</big></code>
    * 
    * @param p_iso_str the time formatted according to ISO 8601 format. This is
    *        also essentially the W3C dateTime format used in XML
    *        
    * @return the <code><big>TIMESTAMP</big></code> equivalent of the input string                     
    */    
   FUNCTION TO_TIMESTAMP (p_iso_str IN VARCHAR2)
      RETURN timestamp;
   /**
    * Genrates the <code><big>TIMESTAMP</big></code> equivalent of a Java millisecond
    * value.  The Java millisecond value specifies the number of milliseconds since
    * the beginning of the UNIX epoch (01 Jan 1970 00:00:00 UTC)        
    * 
    * @param p_millis the Java millisecond value
    *        
    * @return the <code><big>TIMESTAMP</big></code> equivalent of the input value
    */             
   FUNCTION TO_TIMESTAMP (p_millis IN NUMBER)
      RETURN timestamp;
   /**
    * Genrates the Java millisecond equivalent of a <code><big>TIMESTAMP</big></code> 
    * value.  The Java millisecond value specifies the number of milliseconds since
    * the beginning of the UNIX epoch (01 Jan 1970 00:00:00 UTC)        
    * 
    * @param p_timestamp the <code><big>TIMESTAMP</big></code> value to convert
    *        
    * @return the Java millsecond value equivalent of the input
    */             
   FUNCTION to_millis (p_timestamp IN timestamp)
      RETURN NUMBER;
   /**
    * Genrates the Java millisecond value for the current time. The Java millisecond 
    * value specifies the number of milliseconds since the beginning of the UNIX epoch
    * (01 Jan 1970 00:00:00 UTC)        
    * 
    * @return the Java millsecond value representing the current time
    */             
   FUNCTION current_millis
      RETURN NUMBER;
   /**
    * Genrates the Java microsecond equivalent of a <code><big>TIMESTAMP</big></code>
    * value.  The Java microsecond value specifies the number of microseconds since
    * the beginning of the UNIX epoch (01 Jan 1970 00:00:00 UTC)
    *
    * @param p_timestamp the <code><big>TIMESTAMP</big></code> value to convert
    *
    * @return the Java millsecond value equivalent of the input
    */
   FUNCTION to_micros (p_timestamp IN timestamp)
      RETURN NUMBER;
   /**
    * Genrates the Java microsecond value for the current time. The Java microsecond
    * value specifies the number of microseconds since the beginning of the UNIX epoch
    * (01 Jan 1970 00:00:00 UTC)
    *
    * @return the Java millsecond value representing the current time
    */
   FUNCTION current_micros
      RETURN NUMBER;
   /**
    * Outputs a test string verifying that the call succeeded. Uses <code><big>dbms_output.put_line</big></code>
    * to output the test string
    */             
   PROCEDURE test;
   /**
    * Output a string with a maximum line length. Uses <code><big>dbms_output.put_line</big></code>
    * to output the lines
    * 
    * @param p_str the string to output
    * @param p_len the maximum line length. If <code><big>p_str</big></code> is 
    *        longer than this it will be broken into multiple lines                     
    */       
   PROCEDURE DUMP (p_str IN VARCHAR2, p_len IN PLS_INTEGER DEFAULT 80 );
   /**
    * Creates the partitioned timeseries table view
    */       
   PROCEDURE create_view;
   /**
    * Retrieves the office identifier and office long name for the current user
    * 
    * @param p_office_id the office identifier of the current user
    * @param p_office_long_name the office long name of the current user             
    */       
   PROCEDURE get_user_office_data (p_office_id          OUT VARCHAR2,
                                   p_office_long_name   OUT VARCHAR2);
   /**
    * Retrieves the actual unit identifier for a specified unit alias (or actual
    * unit) and office.
    * 
    * @param p_unit_or_alias an actual unit identifier or a unit alias for the 
    *        specified office.  If it is an actual unit identifier then this
    *        identifier is also returned.    
    * @param p_office_id the office for which to resolve the alias to an actual
    *        unit id.  If <code><big>NULL</big></code> the current user's office
    *        is used.
    *        
    * @return the actual unit identifier corresponding to the input                                            
    */       
   function get_unit_id(
      p_unit_or_alias in varchar2,
      p_office_id     in varchar2 default null)
      return varchar2;
      
   /**
    * Retrieves the unit identifier for a specified unit code
    * 
    * @param p_unit_code the unit code to retrieve the identifier for    
    *        
    * @return the unit identifier corresponding to the input                                            
    */       
   function get_unit_id2(
      p_unit_code in varchar2)
      return varchar2 result_cache;
      
   /**
    * Retrieves a cursor of all valid units in the database for an optionally
    * specified parameter.  The cursor has a single column named 'UNIT_ID'.
    * 
    * @param p_valid_units the cursor of valid units
    * @param p_parameter_id the parameter for which to return the set of valid
    *        units.  If <code><big>NULL</big></code> the cursor will contain all
    *        valid units in the database for any parameter.                     
    */       
   PROCEDURE get_valid_units (p_valid_units       OUT sys_refcursor,
                              p_parameter_id   IN     VARCHAR2 DEFAULT NULL
                             );

   /**
    * Retrieves a case-corrected unit identifier
    * 
    * @param p_unit_id the unit identifier to case correct
    * @param p_parameter_id the parameter for the unit.  If <code><big>NULL</big></code>
    *        then units for all parameters are considered.
    *            
    * @return the case corrected unit                             
    */       
    FUNCTION get_valid_unit_id (p_unit_id            IN VARCHAR2,
                                     p_parameter_id    IN VARCHAR2 DEFAULT NULL
                                    )
    RETURN VARCHAR2;
   /**
    * Retrieves a table of all valid units in the database for an optionally
    * specified parameter
    * 
    * @param p_parameter_id the parameter for which to return the set of valid
    *        units.  If <code><big>NULL</big></code> the cursor will contain all
    *        valid units in the database for any parameter.
    * @return a table of valid units. The table has a single column named 'UNIT_ID'                                 
    */       
   FUNCTION get_valid_units_tab (p_parameter_id IN VARCHAR2 DEFAULT NULL )
      RETURN cat_unit_tab_t
      PIPELINED;
   /**
    * Retrieves a unit code from a actual unit identifier or unit alias
    * 
    * @param p_unit_id the actual unit identifier or alias to retrieve the code for
    * @param p_abstract_param_id an abstract parameter identifier to use to narrow
    *        the search.  If <code><big>NULL</big></code> all units for all abstract
    *        parameters are searched.  CWMS abstract parameters are:
    *        <ul>
    *          <li>Angle                           </li>
    *          <li>Angular Speed                   </li>
    *          <li>Area                            </li>
    *          <li>Areal Volume Rate               </li>
    *          <li>Conductance                     </li>
    *          <li>Conductivity                    </li>
    *          <li>Count                           </li>
    *          <li>Currency                        </li>
    *          <li>Elapsed Time                    </li>
    *          <li>Electromotive Potential         </li>
    *          <li>Energy                          </li>
    *          <li>Force                           </li>
    *          <li>Hydrogen Ion Concentration Index</li>
    *          <li>Irradiance                      </li>
    *          <li>Irradiation                     </li>
    *          <li>Length                          </li>
    *          <li>Linear Speed                    </li>
    *          <li>Mass Concentration              </li>
    *          <li>None                            </li>
    *          <li>Phase Change Rate Index         </li>
    *          <li>Power                           </li>
    *          <li>Pressure                        </li>
    *          <li>Temperature                     </li>
    *          <li>Turbidity                       </li>
    *          <li>Volume                          </li>
    *          <li>Volume Rate                     </li>
    *        </ul>
    * @param p_db_office_id the office to use for searching for unit aliases.  If
    *        <code><big>NULL</big></code> the current user's office is used.
    *        
    * @return the unit code corresponding to the inputs
    * 
    * @throws INVALID_ITEM if no unit code can be found
    * @throws ERROR if the inputs match more than one unit code                                        
    */       
   FUNCTION get_unit_code (p_unit_id             IN VARCHAR2,
                           p_abstract_param_id   IN VARCHAR2 DEFAULT NULL ,
                           p_db_office_id        IN VARCHAR2 DEFAULT NULL
                          )
      RETURN NUMBER;
        /**
    * Retrieves the timeseries group code for a specified timeseries group
    *
    * @param p_ts_category_id the timeseries category identifier that the timeseries
    *        group belongs to
    * @param p_ts_group_id the timeseries group identifier
    * @param p_db_office_code the office to locate the group code for
    *
    * @return the timeseries group code for the inputs
    *
    * @throws ERROR if no timeseries group matches the inputs
    */
   FUNCTION get_ts_group_code (p_ts_category_id   IN VARCHAR2,
                                p_ts_group_id      IN VARCHAR2,
                                p_db_office_code    IN NUMBER
                               )
      RETURN NUMBER;
   /**
    * Retrieves the location group code for a specified location group
    * 
    * @param p_loc_category_id the location category identifier that the location
    *        group belongs to
    * @param p_loc_group_id the location group identifier
    * @param p_db_office_code the office to locate the group code for
    * 
    * @return the location group code for the inputs
    * 
    * @throws ERROR if no location group matches the inputs                                            
    */       
   FUNCTION get_loc_group_code (p_loc_category_id   IN VARCHAR2,
                                p_loc_group_id      IN VARCHAR2,
                                p_db_office_code    IN NUMBER
                               )
      RETURN NUMBER;
   /**
    * Retrieves the location group code for a specified location group
    * 
    * @param p_loc_category_id the location category identifier that the location
    *        group belongs to
    * @param p_loc_group_id the location group identifier
    * @param p_db_office_id the office to locate the group code for
    * 
    * @return the location group code for the inputs
    * 
    * @throws ERROR if no location group matches the inputs                                            
    */       
   FUNCTION get_loc_group_code (p_loc_category_id   IN VARCHAR2,
                                p_loc_group_id      IN VARCHAR2,
                                p_db_office_id      IN VARCHAR2
                               )
      RETURN NUMBER;
   /**
    * Returns the name of the current user
    * 
    * @return the name of the current user        
    */       
   FUNCTION get_user_id
      RETURN VARCHAR2;
   /**
    * Retrieve a unit in the preferred unit system and optionally convert a value
    * to that unit. The preferred unit system is determed by the first non-null
    * value encountered in the following list:    
    * <ol>
    * <li>database property:
    *     <dl>
    *     <dt><b>office id:</b></dt>
    *     <dd><code><big>'`&lt;<em>p_office_id</em>`&gt;'</big></code></dd>   
    *     <dt><b>category :</b></dt>
    *     <dd><code><big>'Pref_User.`&lt;<em>p_user_id</em>`&gt;'</big></code></dd>   
    *     <dt><b>identifier :</b></dt>
    *     <dd><code><big>'Unit_System'</big></code></dd>
    *     </dl>    
    * <li>database property:
    *     <dl>
    *     <dt><b>office id:</b></dt>
    *     <dd><code><big>'`&lt;<em>p_office_id</em>`&gt;'</big></code></dd>   
    *     <dt><b>category :</b></dt>
    *     <dd><code><big>'Pref_Office'</big></code></dd>   
    *     <dt><b>identifier :</b></dt>
    *     <dd><code><big>'Unit_System'</big></code></dd>
    *     </dl>                 
    * <li><code><big>'SI'</big></code>
    * </ol>
    * 
    * @param p_unit_id the unit in the preferred unit system
    * @param p_value_out the value converted from database storage units to the
    *        output unit
    * @param p_parameter_id the parameter identifier for which to find the unit
    * @param p_value_in a value to convert from database storage units to the 
    *        output uni
    * @param p_user_id the user for whom to determine the preferred unit system.
    *        If <code><big>NULL</big></code> the current user is used
    * @param p_office_id the office for which to determine the preferred unit system.
    *        If <code><big>NULL</big></code> the user's primary office is used                                                                            
    */        
   procedure user_display_unit(
      p_unit_id      out varchar2,
      p_value_out    out number,
      p_parameter_id in  varchar2,
      p_value_in     in  number   default null,
      p_user_id      in  varchar2 default null,
      p_office_id    in  varchar2 default null);
   /**
    * Converts a number of minutes into a string representation showing the
    * the number of years, months, days, hours, and minutes. 
    * 
    * @param p_interval is the number of minutes to convert into a string
    *        representation.
    *        
    * @return the string representation as nnyrnnmonndynnhrnnmi                        
    */                  
   FUNCTION get_interval_string (p_interval IN NUMBER)
      RETURN VARCHAR2;
   /**
    * Returns the default units of a parameter in the specified unit system
    * 
    * @param p_parameter_id the parameter to get the default unit for
    * @param p_unit_system the unit system to get the default unit for. If <code><big>NULL</big></code>
    *        then the SI unit system is assumed.
    *        
    * @return the default unit of the specified parameter and unit system                        
    */             
   FUNCTION get_default_units (p_parameter_id   IN VARCHAR2,
                               p_unit_system    IN VARCHAR2 DEFAULT 'SI'
                              )
      RETURN VARCHAR2;
   /**
    * Returns the database storage unit code of the specified parameter
    * 
    * @param p_paramter_id the parameter to get the database storage unit code for
    * 
    * @return the database storage unit code for the specified parameter                
    */       
   function get_db_unit_code(
      p_parameter_id in varchar2)
      return number;
   /**
    * Returns the database storage unit code of the specified parameter
    * 
    * @param p_parameter_code the parameter to get the database storage unit code for
    * 
    * @return the database storage unit code for the specified parameter                
    */       
   function get_db_unit_code(
      p_parameter_code in number)
      return number;
   /**
    * Converts a value to database storage unit
    * 
    * @param p_value the value to conver
    * @param p_parameter_id the parameter identifier of the value
    * @param p_unit_id the incoming unit of the value
    * 
    * @return the incoming value converted to the database storage unit                        
    */                   
   function convert_to_db_units(
      p_value        in binary_double,
      p_parameter_id in varchar2,
      p_unit_id      in varchar2)
   return binary_double;
   /**
    * Converts a value from one unit to another
    * 
    * @param p_value the value to convert
    * @param p_from_unit_id the unit to convert from
    * @param p_to_unit_id the unit to convert to                
    */             
   function convert_units(
      p_value        in binary_double,
      p_from_unit_id in varchar2,
      p_to_unit_id   in varchar2)
   return binary_double result_cache;   
   /**
    * Converts a value from one unit to another
    * 
    * @param p_value the value to convert
    * @param p_from_unit_code the unit to convert from
    * @param p_to_unit_code the unit to convert to                
    */             
   function convert_units(
      p_value          in binary_double,
      p_from_unit_code in number,
      p_to_unit_code   in number)
   return binary_double result_cache;   
   /**
    * Converts a value from one unit to another
    * 
    * @param p_value the value to convert
    * @param p_from_unit_code the unit to convert from
    * @param p_to_unit_id the unit to convert to                
    */             
   function convert_units(
      p_value          in binary_double,
      p_from_unit_code in number,
      p_to_unit_id     in varchar2)
   return binary_double result_cache;   
   /**
    * Converts a value from one unit to another
    * 
    * @param p_value the value to convert
    * @param p_from_unit_id the unit to convert from
    * @param p_to_unit_code the unit to convert to                
    */             
   function convert_units(
      p_value        in binary_double,
      p_from_unit_id in varchar2,
      p_to_unit_code in number)
   return binary_double result_cache;
   /**
    * Sign-extends 32-bit integers. Enables Java clients to use int values for 32-bit 
    * data quality values and retain the sign of the 32-bit value
    * 
    * @param p_int the integer value to sign-extend
    * 
    * @return the sign-extended integer                     
    */          
   FUNCTION sign_extend (p_int IN INTEGER)
      RETURN INTEGER;
   /**
    * Converts an integer number of months to an equivalent <code><big>INTERVAL YEAR TO MONTH</big></code>
    * 
    * @param p_months the interval to convert
    * 
    * @return an equivalent <code><big>INTERVAL YEAR TO MONTH</big></code>                
    */       
   function months_to_yminterval(
      p_months in integer) 
      return interval year to month;
   /**
    * Converts an integer number of minutes to an equivalent <code><big>INTERVAL DAY TO SECOND</big></code>
    * 
    * @param p_minutes the interval to convert
    * 
    * @return an equivalent <code><big>INTERVAL DAY TO SECOND</big></code>                
    */       
   function minutes_to_dsinterval(
      p_minutes in integer) 
      return interval day to second;
   /**
    * Converts an <code><big>INTERVAL YEAR TO MONTH</big></code> to an equivalent number of months 
    * 
    * @param p_intvl the interval to convert
    * 
    * @return an equivalent number of months                
    */       
   function yminterval_to_months(
      p_intvl in yminterval_unconstrained) 
      return integer;
   /**
    * Converts an <code><big>INTERVAL DAY TO SECOND</big></code> to an equivalent number of minutes 
    * 
    * @param p_intvl the interval to convert
    * 
    * @return an equivalent number of minutes                
    */       
   function dsinterval_to_minutes(
      p_intvl in dsinterval_unconstrained) 
      return integer;
   /**
    * Converts an integer number of minutes to an equivalent ISO 8601 Duration string
    * 
    * @param p_minutes the duration to convert
    * 
    * @return an equivalent ISO 8601 Duration string                
    */       
   function minutes_to_duration (
      p_minutes in integer)
      return varchar2;
   /**
    * Converts an ISO 8601 Duration string to an equivalent number of minutes
    * 
    * @param p_duration the duration to convert
    * 
    * @return an equivalent number of minutes                
    */       
   function duration_to_minutes(
      p_duration in varchar2)
      return integer;   
   /**
    * Converts an ISO 8601 Duration string to equivalent interval 
    *
    * @param p_ym_interval the interval year to month portion of the equivalent interval
    * @param p_ds_interval the interval day to second portion of the equivalent interval 
    * @param p_duration the duration to convert
    */       
   procedure duration_to_interval(
      p_ym_interval out yminterval_unconstrained,
      p_ds_interval out dsinterval_unconstrained,
      p_duration    in  varchar2);      
   /**
    * Converts an ODBC timestamp string to an equivalent <code><big>DATE</big></code>
    * 
    * @param p_odbc_str the ODBC string to convert
    * 
    * @return a <code><big>DATE</big></code> equivalent to the input                 
    */             
   function parse_odbc_ts_string(
      p_odbc_str in varchar2)
      return date;
   /**
    * Converts an ODBC date string to an equivalent <code><big>DATE</big></code>
    * 
    * @param p_odbc_str the ODBC string to convert
    * 
    * @return a <code><big>DATE</big></code> equivalent to the input                 
    */             
   function parse_odbc_d_string(
      p_odbc_str in varchar2)
      return date;
   /**
    * Converts an ODBC timestamp or date string to an equivalent <code><big>DATE</big></code>
    * 
    * @param p_odbc_str the ODBC string to convert
    * 
    * @return a <code><big>DATE</big></code> equivalent to the input                 
    */             
   function parse_odbc_ts_or_d_string(
      p_odbc_str in varchar2)
      return date;
   /**
    * Determines whether a specified token is a constant that can be used in 
    * expression evaluation
    * 
    * @param p_token the token to analyze
    * 
    * @return whether the specified token is in the list of valid expression
    *         evaluation constants
    *         
    * @see expression_constants                                
    */       
   function is_expression_constant(p_token in varchar2) return boolean;   
   /**
    * Determines whether a specified token is a operator that can be used in 
    * expression evaluation
    * 
    * @param p_token the token to analyze
    * 
    * @return whether the specified token is in the list of valid expression
    *         evaluation operators                        
    *         
    * @see expression_operators                                
    */       
   function is_expression_operator(p_token in varchar2) return boolean;   
   /**
    * Determines whether a specified token is a function that can be used in 
    * expression evaluation
    * 
    * @param p_token the token to analyze
    * 
    * @return whether the specified token is in the list of valid expression
    *         evaluation functions                        
    *         
    * @see expression_functions                                
    */       
   function is_expression_function(p_token in varchar2) return boolean;
   /**
    * Determines whether a specified token is a comparison operator that can be used in 
    * logic expression evaluation
    * 
    * @param p_token the token to analyze
    * 
    * @return whether the specified token is in the list of valid logic expression
    *         comparison operators                        
    *         
    * @see comparitors                                
    */       
   function is_comparison_operator(p_token in varchar2) return boolean;
   /**
    * Determines whether a specified token is a combination operator that can be used in 
    * logic expression evaluation
    * 
    * @param p_token the token to analyze
    * 
    * @return whether the specified token is in the list of valid logic expression
    *         combination operators                        
    *         
    * @see combinators                                
    */       
   function is_combination_operator(p_token in varchar2) return boolean;
   /**
    * Determines whether a specified token is a an operator that can be used in 
    * logic expression evaluation
    * 
    * @param p_token the token to analyze
    * 
    * @return whether the specified token is in the list of valid logic expression
    *         comparison or combination operators                        
    *         
    * @see comparitors                                
    * @see combinators                                
    */       
   function is_logic_operator(p_token in varchar2) return boolean;
   /**
    * Generates a table of RPN tokens from an algebraic expression.
    * 
    * @param p_algebraic_expr a mathematical expression in infix (algebraic) notation.
    *        Standard algebraic operator precedence (order of operations) applies
    *        and can be overridden by parentheses.  All tokens in the expression 
    *        (numbers, variables, operators, constants, functions) must be separated
    *        from adjacent tokens by whitespace. No whitespace is required before
    *        or after parentheses. Variables are specified as arg1, arg2, ... argN.
    *        Negated variables (e.g., -argN) are accepted.                        
    * 
    * @return a table of tokens in postfix (reverse Polish) notation (RPN)                
    */             
   function tokenize_algebraic(
      p_algebraic_expr in varchar2)
      return str_tab_t result_cache;
   /**
    * Generates a table of RPN tokens from an RPN expression.
    * 
    * @param p_RPN_expr a mathematical expression in postfix (reverse Polish) notation (RPN).
    *        All tokens in the expression (numbers, variables, operators, constants, 
    *        functions) must be separated from adjacent tokens by whitespace. Parentheses
    *        are not used in RPN notation. Variables are specified as arg1, arg2, ... argN.
    *        Negated variables (e.g., -argN) are accepted.                        
    * 
    * @return a table of tokens in postfix (reverse Polish) notation (RPN)                
    */             
   function tokenize_RPN(
      p_RPN_expr  in varchar2)
      return str_tab_t result_cache;
   /**
    * Generates a table of RPN tokens from an algebraic expression.
    * 
    * @param p_expr a mathematical expression in infix (algebraic) notation or
    *        in postfix (reverse Polish) notation (RPN). Standard algebraic operator
    *        precedence (order of operations) applies for infix notation and can be
    *        overridden by parentheses.  All tokens in the expression (numbers, 
    *        variables, operators, constants, functions) must be separated from
    *        adjacent tokens by whitespace. No whitespace is required before or
    *        after parentheses. Parentheses are not used in RPN notation. Variables 
    *        are specified as arg1, arg2, ... argN. Negated variables (e.g., -argN)
    *        are accepted.                    
    * 
    * @return a table of tokens in postfix (reverse Polish) notation (RPN)                
    */             
   function tokenize_expression(      
      p_expr in varchar2)
      return str_tab_t result_cache;
   /**
    * Generates a stack of RPN expressions that can each be evaluated.
    * 
    * @param p_expr one or more mathematical expressions in infix (algebraic) notation or
    *        in postfix (reverse Polish) notation (RPN). Standard algebraic operator
    *        precedence (order of operations) applies for infix notation and can be
    *        overridden by parentheses.  All tokens in the expression (numbers, 
    *        variables, operators, constants, functions) must be separated from
    *        adjacent tokens by whitespace. No whitespace is required before or
    *        after parentheses. Parentheses are not used in RPN notation. Variables 
    *        are specified as arg1, arg2, ... argN. Negated variables (e.g., -argN)
    *        are accepted.
    *
    * @param p_is_rpn A flag (T/F) specifying whether the expression is known to be in postfix notation.                     
    * 
    * @return a stack of RPN expressions in postfix (reverse Polish) notation (RPN). The first value is the top of the stack                
    */             
   function tokenize_expression2(      
      p_expr   in varchar2,
      p_is_rpn in varchar2 default 'F')
      return str_tab_t result_cache;
   /**
    * Computes a value from tokens in postfix (reverse Polish) notation (RPN) and
    * specified values for variables
    * 
    * @param p_RPN_tokens the tokens representing the mathematical expression to
    *        evaluate. Variables are named arg1, arg2, ... argN.  Negated variables
    *        of the form -argN are accepted.    
    * @param p_args the actual values to use for arg1...argN. Values are assigned 
    *        positionally beginning with the specified or default offset
    * @param p_args_offset the offset into <code><big>p_args</big></code> from which
    *        to start assigning values.  If 0 (default) then the arg1 will be assigned
    *        the first value, etc...        
    *                                                   
    * @return the result of the compuatation      
    */             
   function eval_tokenized_expression(
      p_RPN_tokens in str_tab_t,
      p_args           in double_tab_t,
      p_args_offset    in integer default 0)
      return number;      
   /**
    * Returns a stack of values from tokens in postfix (reverse Polish) notation (RPN) and
    * specified values for variables.  The first value is the top of the stack.
    * 
    * @param p_RPN_tokens the tokens representing the mathematical expression to
    *        evaluate. Variables are named arg1, arg2, ... argN.  Negated variables
    *        of the form -argN are accepted.    
    * @param p_args the actual values to use for arg1...argN. Values are assigned 
    *        positionally beginning with the specified or default offset
    * @param p_args_offset the offset into <code><big>p_args</big></code> from which
    *        to start assigning values.  If 0 (default) then the arg1 will be assigned
    *        the first value, etc...        
    *                                                   
    * @return the stack of values      
    */             
   function eval_tokenized_expression2(
      p_RPN_tokens in str_tab_t,
      p_args           in double_tab_t,
      p_args_offset    in integer default 0)
      return double_tab_t;      
   /**
    * Evaluates an arithmetic expression in infix (algebraic) notation and computes
    * a value based on specified variables.
    *
    * @see expression_constants
    * @see expression_operators
    * @see expression_function
    * 
    * @param p_algebraic_expr a mathematical expression in infix (algebraic) notation.
    *        Standard algebraic operator precedence (order of operations) applies
    *        and can be overridden by parentheses.  All tokens in the expression 
    *        (numbers, variables, operators, constants, functions) must be separated
    *        from adjacent tokens by whitespace. No whitespace is required before
    *        or after parentheses. Variables are specified as arg1, arg2, ... argN.
    *        Negated variables (e.g., -argN) are accepted.                        
    * @param p_args the actual values to use for arg1...argN. Values are assigned 
    *        positionally beginning with the specified or default offset
    * @param p_args_offset the offset into <code><big>p_args</big></code> from which
    *        to start assigning values.  If 0 (default) then the arg1 will be assigned
    *        the first value, etc...        
    *                                                   
    * @return the result of the compuatation      
    */             
   function eval_algebraic_expression(
      p_algebraic_expr in varchar2,
      p_args           in double_tab_t,
      p_args_offset    in integer default 0)
      return number;      
   /**
    * Evaluates an arithmetic expression in infix (algebraic) notation and return
    * a stack of vlues based on specified variables.  The first value is the top of the stack.
    *
    * @see expression_constants
    * @see expression_operators
    * @see expression_function
    * 
    * @param p_algebraic_expr a mathematical expression in infix (algebraic) notation.
    *        Standard algebraic operator precedence (order of operations) applies
    *        and can be overridden by parentheses.  All tokens in the expression 
    *        (numbers, variables, operators, constants, functions) must be separated
    *        from adjacent tokens by whitespace. No whitespace is required before
    *        or after parentheses. Variables are specified as arg1, arg2, ... argN.
    *        Negated variables (e.g., -argN) are accepted.                        
    * @param p_args the actual values to use for arg1...argN. Values are assigned 
    *        positionally beginning with the specified or default offset
    * @param p_args_offset the offset into <code><big>p_args</big></code> from which
    *        to start assigning values.  If 0 (default) then the arg1 will be assigned
    *        the first value, etc...        
    *                                                   
    * @return the stack of values      
    */             
   function eval_algebraic_expression2(
      p_algebraic_expr in varchar2,
      p_args           in double_tab_t,
      p_args_offset    in integer default 0)
      return double_tab_t;      
   /**
    * Evaluates an arithmetic expression in postfix (reverse Polish) notation (RPN)
    * and computes a value based on specified variables.    
    *
    * @see expression_constants
    * @see expression_operators
    * @see expression_function
    *
    * @param p_RPN_expr a mathematical expression in postfix (reverse Polish) notation (RPN).
    *        All tokens in the expression (numbers, variables, operators, constants, 
    *        functions) must be separated from adjacent tokens by whitespace. Parentheses
    *        are not used in RPN notation. Variables are specified as arg1, arg2, ... argN.
    *        Negated variables (e.g., -argN) are accepted.                        
    * @param p_args the actual values to use for arg1...argN. Values are assigned 
    *        positionally beginning with the specified or default offset
    * @param p_args_offset the offset into <code><big>p_args</big></code> from which
    *        to start assigning values.  If 0 (default) then the arg1 will be assigned
    *        the first value, etc...        
    *                                                   
    * @return the result of the compuatation      
    */             
   function eval_RPN_expression(
      p_RPN_expr    in varchar2,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return number;      
   /**
    * Evaluates an arithmetic expression in postfix (reverse Polish) notation (RPN)
    * and return  a stack of values based on specified variables. The first value is the top of the stack.   
    *
    * @see expression_constants
    * @see expression_operators
    * @see expression_function
    *
    * @param p_RPN_expr a mathematical expression in postfix (reverse Polish) notation (RPN).
    *        All tokens in the expression (numbers, variables, operators, constants, 
    *        functions) must be separated from adjacent tokens by whitespace. Parentheses
    *        are not used in RPN notation. Variables are specified as arg1, arg2, ... argN.
    *        Negated variables (e.g., -argN) are accepted.                        
    * @param p_args the actual values to use for arg1...argN. Values are assigned 
    *        positionally beginning with the specified or default offset
    * @param p_args_offset the offset into <code><big>p_args</big></code> from which
    *        to start assigning values.  If 0 (default) then the arg1 will be assigned
    *        the first value, etc...        
    *                                                   
    * @return the stack of values      
    */             
   function eval_RPN_expression2(
      p_RPN_expr    in varchar2,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return double_tab_t;      
   /**
    * Evaluates an arithmetic expression in infix (algebraic) notation or in postfix 
    * (reverse Polish) notation (RPN) and computes a value based on specified variables.    
    *
    * @see expression_constants
    * @see expression_operators
    * @see expression_functions
    *
    * @param p_expr a mathematical expression in infix (algebraic) notation or
    *        in postfix (reverse Polish) notation (RPN). Standard algebraic operator
    *        precedence (order of operations) applies for infix notation and can be
    *        overridden by parentheses.  All tokens in the expression (numbers, 
    *        variables, operators, constants, functions) must be separated from
    *        adjacent tokens by whitespace. No whitespace is required before or
    *        after parentheses. Parentheses are not used in RPN notation. Variables 
    *        are specified as arg1, arg2, ... argN. Negated variables (e.g., -argN)
    *        are accepted.                    
    * @param p_args the actual values to use for arg1...argN. Values are assigned 
    *        positionally beginning with the specified or default offset
    * @param p_args_offset the offset into <code><big>p_args</big></code> from which
    *        to start assigning values.  If 0 (default) then the arg1 will be assigned
    *        the first value, etc...        
    *                                                   
    * @return the result of the compuatation      
    */             
   function eval_expression(
      p_expr        in varchar2,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return number;
   /**
    * Evaluates an arithmetic expression in infix (algebraic) notation or in postfix 
    * (reverse Polish) notation (RPN) and returns a stack of values based on specified variables.
    * The first value is the top of the stack.    
    *
    * @see expression_constants
    * @see expression_operators
    * @see expression_functions
    *
    * @param p_expr a mathematical expression in infix (algebraic) notation or
    *        in postfix (reverse Polish) notation (RPN). Standard algebraic operator
    *        precedence (order of operations) applies for infix notation and can be
    *        overridden by parentheses.  All tokens in the expression (numbers, 
    *        variables, operators, constants, functions) must be separated from
    *        adjacent tokens by whitespace. No whitespace is required before or
    *        after parentheses. Parentheses are not used in RPN notation. Variables 
    *        are specified as arg1, arg2, ... argN. Negated variables (e.g., -argN)
    *        are accepted.                    
    * @param p_args the actual values to use for arg1...argN. Values are assigned 
    *        positionally beginning with the specified or default offset
    * @param p_args_offset the offset into <code><big>p_args</big></code> from which
    *        to start assigning values.  If 0 (default) then the arg1 will be assigned
    *        the first value, etc...        
    *                                                   
    * @return the stack of values      
    */             
   function eval_expression2(
      p_expr        in varchar2,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return double_tab_t;
   /**
    * Tokenizes a comparison expression in infix or postfix notation and returns the 
    * tokens in a table of length 3.  The first two rows of the table are the tokenized arithmetic
    * expressions.  The last row contains a table of length 1 which contains the comparison operator.
    *
    * @param p_comparison_expression. The comparison expression in infix or postfix notation.
    *        The expression must be comprised of two arithmetic expressions and one comparison operator. 
    *        Valid comparison operators are:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">operators</th>
    *     <th class="descr">meaning</th>
    *   </tr>
    *   <tr>
    *     <td class="descr">'='</td>
    *     <td class="descr">The expressions are equal</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'!=', '`&lt;`&gt;', 'NE'</td>
    *     <td class="descr">The expressions are not equal</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&lt;', 'LT'</td>
    *     <td class="descr">The first expression is less than the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&lt;=', 'LE'</td>
    *     <td class="descr">The first expression is less than or equal to the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&gt;', 'GT'</td>
    *     <td class="descr">The first expression is greater than the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&gt;=', 'GE'</td>
    *     <td class="descr">The first expression is greater than or equal to the second</td>
    *   </tr>
    * </table>
    *
    * @return a table of tokens.
    */      
   function tokenize_comparison_expression(
      p_comparison_expression in varchar2)
      return str_tab_tab_t;
   /**
    * Tokenizes a logic expression in infix or postfix notation and returns the 
    * tokens in a table ready for evaluation.
    *
    * @param p_expr. The logic expression in infix or postfix notation.
    *        The expression must be comprised of one or more comparison expressions (two arithmetic expressions and one comparison operator) 
    *        separated by logic operators 
    *        Valid comparison operators are:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">operators</th>
    *     <th class="descr">meaning</th>
    *   </tr>
    *   <tr>
    *     <td class="descr">'='</td>
    *     <td class="descr">The expressions are equal</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'!=', '`&lt;`&gt;', 'NE'</td>
    *     <td class="descr">The expressions are not equal</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&lt;', 'LT'</td>
    *     <td class="descr">The first expression is less than the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&lt;=', 'LE'</td>
    *     <td class="descr">The first expression is less than or equal to the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&gt;', 'GT'</td>
    *     <td class="descr">The first expression is greater than the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&gt;=', 'GE'</td>
    *     <td class="descr">The first expression is greater than or equal to the second</td>
    *   </tr>
    * </table>
    *              
    *Valid logic operators are: (all operators evaluated left to right)
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">operators</th>
    *     <th class="descr">precedence (higher evaluated earlier)</th>
    *   </tr>
    *   <tr>
    *     <td class="descr">AND</td>
    *     <td class="descr">3</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">OR</td>
    *     <td class="descr">1</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">XOR</td>
    *     <td class="descr">2</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">NOT</td>
    *     <td class="descr">4</td>
    *   </tr>
    * </table>
    *
    * @return a table of tokens.
    */      
   function tokenize_logic_expression(
      p_expr in varchar2)
      return str_tab_tab_t;
   /**
    * Replaces top-level parenthetical sub-expressions in a specifed expression. The replaced sub-expressions are in positions 1..count-1 in the returned table
    * and the expression with the sub-expressions replaced is returned in position count in the returned table.  The sub-expressions are replaced with the 
    * string '$n' where n is the position of the replaced sub-expression in the table.
    *
    * @param p_expr The expression whose top-level parenthetical expressions will be replaced
    *
    * @return A table of length n+1 where n is the number of top-level parenthetical expressions replaced
    */   
   function replace_parentheticals(
      p_expr in varchar2)
      return str_tab_t;      
   /**
    * Evaluates a tokenized comparison expression and return the the result of the comparison as a boolean (true or false) 
    *
    * @param p_tokens The tokenized comparison expression
    *
    * @return true or false
    */      
   function eval_tokenized_comparison(
      p_tokens      in str_tab_tab_t,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return boolean;
   /**
    * Evaluates a tokenized comparison expression and return the the result of the comparison as a varchar2(1) ('T' or 'F') 
    *
    * @param p_tokens The tokenized comparison expression
    *
    * @return 'T' or 'F'
    */      
   function eval_tokenized_comparison2(
      p_tokens      in str_tab_tab_t,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return varchar2;
   /**
    * Evaluates a comparison expression in infix or postfix notation and returns the result of the comparison as a boolean (true or false). 
    *
    * @param p_comparison_expression. The comparison expression in infix or postfix notation.
    *        The expression must be comprised of two arithmetic expressions and one comparison operator. 
    *        Valid comparison operators are:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">operators</th>
    *     <th class="descr">meaning</th>
    *   </tr>
    *   <tr>
    *     <td class="descr">'='</td>
    *     <td class="descr">The expressions are equal</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'!=', '`&lt;`&gt;', 'NE'</td>
    *     <td class="descr">The expressions are not equal</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&lt;', 'LT'</td>
    *     <td class="descr">The first expression is less than the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&lt;=', 'LE'</td>
    *     <td class="descr">The first expression is less than or equal to the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&gt;', 'GT'</td>
    *     <td class="descr">The first expression is greater than the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&gt;=', 'GE'</td>
    *     <td class="descr">The first expression is greater than or equal to the second</td>
    *   </tr>
    * </table>
    *
    * @return true or false.
    */      
   function eval_comparison_expression(
      p_expr        in varchar2,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return boolean;
   /**
    * Evaluates a comparison expression in infix or postfix notation and returns the result of the comparison as a varchar2(1) ('T' or 'F') 
    *
    * @param p_comparison_expression. The comparison expression in infix or postfix notation.
    *        The expression must be comprised of two arithmetic expressions and one comparison operator. 
    *        Valid comparison operators are:
    * <p>
    * <table class="descr">
    *   <tr>
    *     <th class="descr">operators</th>
    *     <th class="descr">meaning</th>
    *   </tr>
    *   <tr>
    *     <td class="descr">'='</td>
    *     <td class="descr">The expressions are equal</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'!=', '`&lt;`&gt;', 'NE'</td>
    *     <td class="descr">The expressions are not equal</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&lt;', 'LT'</td>
    *     <td class="descr">The first expression is less than the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&lt;=', 'LE'</td>
    *     <td class="descr">The first expression is less than or equal to the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&gt;', 'GT'</td>
    *     <td class="descr">The first expression is greater than the second</td>
    *   </tr>
    *   <tr>
    *     <td class="descr">'`&gt;=', 'GE'</td>
    *     <td class="descr">The first expression is greater than or equal to the second</td>
    *   </tr>
    * </table>
    *
    * @return The result of the comparison as 'T' or 'F'
    */      
   function eval_comparison_expression2(
      p_expr        in varchar2,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return varchar2;
   /**
    * Retrieves the expression depth (levels of enclosing parentheses) for a specified position in an expression.
    *
    * @param p_position The position in the expression.  Must be in range 1..lenth(expression).
    * @param p_expr     The expression to evaluate
    *
    * @return The expression depth at the specified postion
    *
    */      
   function get_expression_depth_at(
      p_position in integer,
      p_expr     in varchar2)
      return integer;
   /**
    * Reformats a mathematical expression in infix (algebraic) notation
    *
    * @param p_expression The mathematical expression to reformat. It may be specified in infix (algebraic) or postfix (RPN) notation.  
    *                                                                                                                               
    * @return The mathematical expression in infix (algebraic) notation.  The expression will not include any parentheses that are not necessary for correct order of operations.
    */            
   function to_algebraic(
      p_expr in varchar2)
      return varchar2;      
   /**
    * Formats a tokenized mathematical expression in infix (algebraic) notation
    *
    * @param p_tokens The mathematical expression to format as postfix ordered tokens.  
    *                                                                                                                               
    * @return The mathematical expression in infix (algebraic) notation.  The expression will not include any parentheses that are not necessary for correct order of operations.
    */            
   function to_algebraic(
      p_tokens in str_tab_t)
      return varchar2;      
   /**
    * Reformats a logic expression in infix (algebraic) notation
    *
    * @param p_expression The logic expression to reformat. It may be specified in infix (algebraic) or postfix (RPN) notation.  
    *                                                                                                                               
    * @return The logic expression in infix (algebraic) notation.  The expression will not include any parentheses that are not necessary for correct order of operations.
    */            
   function to_algebraic_logic(
      p_expr in varchar2)
      return varchar2;      
   /**
    * Reformats a mathematical expression in postfix (RPN) notation
    *
    * @param p_expression The mathematical expression to reformat. It may be specified in infix (algebraic) or postfix (RPN) notation.  
    *                                                                                                                               
    * @return The mathematical expression in postfix (RPN) notation.
    */            
   function to_rpn(
      p_expr in varchar2)
      return varchar2;      
   /**
    * Formats a mathematical expression in postfix (RPN) notation
    *
    * @param p_tokens The mathematical expression to format as postfix ordered tokens.  
    *                                                                                                                               
    * @return The mathematical expression in postfix (RPN) notation.
    */            
   function to_rpn(
      p_tokens in str_tab_t)
      return varchar2;      
   /**
    * Reformats a logic expression in postfix (RPN) notation
    *
    * @param p_expression The logic expression to reformat. It may be specified in infix (algebraic) or postfix (RPN) notation.  
    *                                                                                                                               
    * @return The logic expression in postfix (RPN) notation.
    */            
   function to_rpn_logic(
      p_expr in varchar2)
      return varchar2;
   /**
    * Returns the symbolic representation of a comparison operator
    *
    * @param p_operator The comparison operator in text or symbolic from
    *
    * @return the comparison operator in symbolic form 
    */         
   function get_comparison_op_symbol(
      p_operator in varchar2)
      return varchar2;         
   /**
    * Returns the text representation of a comparison operator
    *
    * @param p_operator The comparison operator in text or symbolic from
    *
    * @return the comparison operator in text form 
    */         
   function get_comparison_op_text(
      p_operator in varchar2)
      return varchar2;         
   /**
    * Appends text to a <code><big>CLOB</big></code>
    * 
    * @param p_dst the <code><big>CLOB</big></code> to append to
    * @param p_src the text to append             
    */       
   procedure append(
      p_dst in out nocopy clob,
      p_src in            clob);
   /**
    * Appends text to a <code><big>CLOB</big></code>
    * 
    * @param p_dst the <code><big>CLOB</big></code> to append to
    * @param p_src the text to append             
    */       
   procedure append(
      p_dst in out nocopy clob,
      p_src in            varchar2);
   /**
    * Appends text to a <code><big>CLOB</big></code>
    * 
    * @param p_dst the <code><big>CLOB</big></code> to append to
    * @param p_src the text to append             
    */       
   procedure append(
      p_dst in out nocopy clob,
      p_src in            xmltype);
   /**
    * Appends text to an <code><big>XMLTYPE</big></code>
    * 
    * @param p_dst the <code><big>XMLTYPE</big></code> to append to
    * @param p_src the text to append             
    */       
   procedure append(
      p_dst in out nocopy xmltype,
      p_src in            clob);
   /**
    * Appends text to an <code><big>XMLTYPE</big></code>
    * 
    * @param p_dst the <code><big>XMLTYPE</big></code> to append to
    * @param p_src the text to append             
    */       
   procedure append(
      p_dst in out nocopy xmltype,
      p_src in            varchar2);
   /**
    * Appends text to an <code><big>XMLTYPE</big></code>
    * 
    * @param p_dst the <code><big>XMLTYPE</big></code> to append to
    * @param p_src the text to append             
    */       
   procedure append(
      p_dst in out nocopy xmltype,
      p_src in            xmltype);
   /**
    * Retrieves a specified XML element from an <code><big>XMLTYPE</big></code>
    * 
    * @param p_xml The xml document or fragment to retrieve from  
    * @param p_path The element to retrieve, in XPath format
    * 
    * @return the specified element                      
    */       
   function get_xml_node(
      p_xml  in xmltype,
      p_path in varchar)
   return xmltype;
   /**
    * Retrieves matching XML element from an <code><big>XMLTYPE</big></code>
    *
    * @param p_xml        The xml document or fragment to retrieve from  
    * @param p_path       The elements to retrieve, in XPath format
    * @param p_condition  An optional condition by which to filter the elements, in XPath format. If specified, the path in this condition must be relative to the root of the xml document or fragment
    * @param p_order_by   An optional path by which to order the elements, in XPath format. If specified, the path must be relative to the the root of the xml document or fragment.
    * @param p_descending A flag ('T'/'F') specifying if the ordering should be in descending order. If unspecified, any ordering will be in ascending order. This parameter is meaningful only in conjunction with p_order_by parameter.
    *
    * @return The elements that match the input path and condition (if any), in the specified order (if any).
    */
   function get_xml_nodes(
      p_xml        in xmltype,
      p_path       in varchar2,
      p_condition  in varchar2 default null,
      p_order_by   in varchar2 default null,
      p_descending in varchar2 default 'F')
   return xml_tab_t;  
   /**
    * Retrieves the text contained in a specified XML element from an <code><big>XMLTYPE</big></code>
    * 
    * @param p_xml The xml document or fragment to retrieve from  
    * @param p_path The element to retrieve, in XPath format
    * 
    * @return the text contained in the specified element                      
    */       
   function get_xml_text(
      p_xml  in xmltype,
      p_path in varchar)
   return varchar2;
   /**
    * Retrieves the numeric value contained in a specified XML element from an <code><big>XMLTYPE</big></code>
    * 
    * @param p_xml The xml document or fragment to retrieve from  
    * @param p_path The element to retrieve, in XPath format
    * 
    * @return the numeric value contained in the specified element                      
    */       
   FUNCTION get_xml_number (p_xml IN XMLTYPE, p_path IN VARCHAR)
      RETURN NUMBER;
   /**
    * Parses a delmited string and removes all tokens present in a second delimited 
    * string.  Equivalent to using the SQL MINUS operator where the selections are
    * tokens from the delimited strings.    
    * 
    * @param p_list_1 the delimited string to parse
    * @param p_list_2 the delimited string containing the tokens to remove
    * @param p_separator the delimiter for both strings
    * 
    * @return a copy of <code><big>p_list_1</big></code> with all the tokens in
    *         <code><big>p_list_2</big></code> removed
    */          
   FUNCTION x_minus_y (p_list_1      IN VARCHAR2,
                       p_list_2      IN VARCHAR2,
                       p_separator   IN VARCHAR2 DEFAULT NULL
                      )
      RETURN VARCHAR2;

   --
   -- Routines for dealing with AT_BOOLEAN_STATE table
   --
   procedure set_boolean_state(
      p_name  in varchar2,
      p_state in boolean);

   procedure set_boolean_state(
      p_name  in varchar2,
      p_state in char);

   function get_boolean_state(
      p_name in varchar2)
      return boolean;

   function get_boolean_state_char(
      p_name in varchar2)
      return char;
   --
   -- Routines for dealing with AT_SESSION_INFO table
   --
   /**
    * Sets session-specific information
    *
    * @param p_item_name the name of the session info to set
    * @param p_txt_value the text value of the session info
    * @param p_num_value the numeric value of the session info
    */
   procedure set_session_info(
      p_item_name in varchar2,
      p_txt_value in varchar2,
      p_num_value in number);
   /**
    * Sets session-specific information
    *
    * @param p_item_name the name of the session info to set
    * @param p_txt_value the text value of the session info
    */
   procedure set_session_info(
      p_item_name in varchar2,
      p_txt_value in varchar2);
   /**
    * Sets session-specific information
    *
    * @param p_item_name the name of the session info to set
    * @param p_num_value the numeric value of the session info
    */
   procedure set_session_info(
      p_item_name in varchar2,
      p_num_value in number);
   /**
    * Retrieves session-specific information
    *
    * @param p_txt_value the text value of the session info
    * @param p_num_value the numeric value of the session info
    * @param p_item_name the name of the session info to retrieve
    */
   procedure get_session_info(
      p_txt_value out varchar2,
      p_num_value out number,
      p_item_name in  varchar2);
   /**
    * Retrieves session-specific text information
    *
    * @param p_item_name the name of the session info to retrieve
    *
    * @return the text value of the session info
    */
   function get_session_info_txt(
      p_item_name in varchar2)
      return varchar2;
   /**
    * Retrieves session-specific numeric information
    *
    * @param p_item_name the name of the session info to retrieve
    *
    * @return the numeric value of the session info
    */
   function get_session_info_num(
      p_item_name in varchar2)
      return number;
   /**
    * Resets (unsets, deletes) session-specific information
    *
    * @param p_item_name the name of the session info to reset
    */
   procedure reset_session_info(
      p_item_name in varchar2);
   /**
    * Returns 'T' if a number is a NaN, otherwise 'F'. The clause "Is_Nan(<val>) = 'F'"
    * can be used in place of "<val> Is Not Nan" to correctly identify NULL values as 
    * not NaN values..
    *
    * @param p_value The value to check for not-NaN status.
    *
    * @return 'T' if p_value is a NaN, 'F' otherwise.
    */
   function is_nan(
      p_value in binary_double)
      return varchar2;
   /**
    * Returns a subset of a table
    *
    * @param p_table The table to return the subset of
    * @param p_first The index of the first element to include
    * @param p_last  The index of the last element to include.  If NULL or greater than the table length, the last index of the input table will be used.
    *
    * @return A subset of the input table, from p_first to p_last.
    */
   function sub_table(
      p_table in str_tab_t,
      p_first in integer,
      p_last  in integer default null)
      return str_tab_t;
   /**
    * Returns a subset of a table
    *
    * @param p_table The table to return the subset of
    * @param p_first The index of the first element to include
    * @param p_last  The index of the last element to include.  If NULL or greater than the table length, the last index of the input table will be used.
    *
    * @return A subset of the input table, from p_first to p_last.
    */
   function sub_table(
      p_table in number_tab_t,
      p_first in integer,
      p_last  in integer default null)
      return number_tab_t;
   /**
    * Returns a subset of a table
    *
    * @param p_table The table to return the subset of
    * @param p_first The index of the first element to include
    * @param p_last  The index of the last element to include.  If NULL or greater than the table length, the last index of the input table will be used.
    *
    * @return A subset of the input table, from p_first to p_last.
    */
   function sub_table(
      p_table in double_tab_t,
      p_first in integer,
      p_last  in integer default null)
      return double_tab_t;


    FUNCTION str2tbl (p_str IN VARCHAR2, p_delim IN VARCHAR2 DEFAULT ',')
       RETURN str2tblType
       PIPELINED;
       
    FUNCTION stragg (input VARCHAR2)
       RETURN VARCHAR2
       PARALLEL_ENABLE
       AGGREGATE USING string_agg_type;     

   /**
    * Returns the value associated with a specified key in a unit specification string in the form of <code>x=abc|y=def|z=ghi</code> or NULL if the specified key is not present in the string.
    * The characters <code>x</code>, <code>y</code>, and <code>z</code> are keys and <code>abc</code>, <code>def</code>, <code>ghi</code> are the values associated with the keys.
    *
    * @param p_unit_spec The unit specification string to parse
    * @param p_key       The key (not case sensitive) whose value is to be returned.
    *
    * @return The value associated with the specified key, or NULL if the key is not present in the string.
    */
   function parse_unit_spec(
      p_unit_spec in varchar2,
      p_key       in varchar2)
      return varchar2;
   /**
    * Returns the unit from a unit specification string.  The unit is the entire string unless the string is format <code>x=abc|y=def|z=ghi</code>, in
    * which case the value associated with the key <code>U</code> is the unit.
    *
    * @param p_unit_spec The unit specification string
    * @return The unit specified in the string or NULL if the string does not contain a unit.
    * @see parse_unit_spec
    */
   function parse_unit(
      p_unit_spec in varchar2)
      return varchar2;
   /**
    * Returns the vertical datum (associated with the key <code>V</code>) in a unit specification string of the format <code>x=abc|y=def|z=ghi</code>.
    * If a non-NULL default vertical datum is to be overriden by a NULL specified vertical datum, the specified vertical datum must be coded as <code>V=NULL</code> 
    *
    * @param p_unit_spec The unit specification string
    * @return The associated vertical datum or NULL if the key <code>V</code> is not in the string.
    * @see parse_unit_spec
    */
   function parse_vertical_datum(
      p_unit_spec in varchar2)
      return varchar2;
   /**
    * Returns the effective vertical datum. If a vertical datum is encoded into the unit specification string, it is returned. Otherwise the default vertical datum for the session is returned.
    *
    * @param p_unit_spec The unit specification string, which may contain an encoded vertical datum
    * @return The effective vertical datum
    * @see parse_unit
    */
   function get_effective_vertical_datum(
      p_unit_spec in varchar2)
      return varchar2;
   -- not documented
   procedure check_dynamic_sql(
      p_sql in varchar2);
   /**
    * Retrieves data from a URL
    *
    * @param p_url The URL to retrieve data from
    * @param p_timeout The session timeout in seconds for this request 
    *
    * @return The URL data as a CLOB
    */   
   function get_url(
      p_url     in varchar2,
      p_timeout in integer default 60)
      return clob;
   /**
    * Returns a column of data from a table of rows of data. All rows should be of the same length.
    *
    * @param p_table  The table of data
    * @param p_column The column (1-based) to return
    * 
    * @return the column of data as a double_tab_t
    * @exception if p_column is greater than the length of the first row
    */      
   function get_column(
      p_table  in double_tab_tab_t,
      p_column in pls_integer)
      return double_tab_t;      
   /**
    * Returns a column of data from a table of rows of data. All rows should be of the same length.
    *
    * @param p_table  The table of data
    * @param p_column The column (1-based) to return
    * 
    * @return the column of data as a str_tab_t
    * @exception if p_column is greater than the length of the first row
    */      
   function get_column(
      p_table  in str_tab_tab_t,
      p_column in pls_integer)
      return str_tab_t;
   /**
    * Returns true if the interval code is irregular otherwise return false
    *
    * @param p_interval_code  interval code
    *
    * @return Returns true if the interval code is irregular otherwise return false
    * @exception if p_interval_code is an invalid code
    */
   function is_irregular_code(
      p_interval_code  in CWMS_INTERVAL.INTERVAL_CODE%TYPE)
      return boolean;
   /**
    * Checks whether the current user has permissions for the specified office
    *
    * @param p_office_id the office to check for permissions for the current user
    * @param p_user_group_id if specified, the specific user permission to check - otherwise the 'All Users' permission is checked
    * @exception if the user does not have the permission for the specified office
    */
   procedure check_office_permission(
      p_office_id     in varchar2,
      p_user_group_id in varchar2 default null); 
END cwms_util;
/

SHOW ERRORS;

prompt update for package body cwms_util



create or replace package BODY cwms_util
AS
   FUNCTION min_dms (p_decimal_degrees IN NUMBER)
      RETURN NUMBER
   IS
      l_sec_dms   NUMBER;
      l_min_dms   NUMBER;
   BEGIN
      l_sec_dms :=
         ROUND (
            ( (ABS (p_decimal_degrees - TRUNC (p_decimal_degrees)) * 60.0)
             - TRUNC (
                  ABS (p_decimal_degrees - TRUNC (p_decimal_degrees)) * 60))
            * 60.0,
            2);
      l_min_dms :=
         TRUNC (ABS (p_decimal_degrees - TRUNC (p_decimal_degrees)) * 60);

      IF l_sec_dms = 60
      THEN
         RETURN l_min_dms + 1;
      ELSE
         RETURN l_min_dms;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         -- Consider logging the error and then re-raise
         RAISE;
   END min_dms;

   --
   FUNCTION sec_dms (p_decimal_degrees IN NUMBER)
      RETURN NUMBER
   IS
      l_sec_dms   NUMBER;
      l_sec_60    NUMBER;
   BEGIN
      l_sec_dms :=
         ( (ABS (p_decimal_degrees - TRUNC (p_decimal_degrees)) * 60.0)
          - min_dms (p_decimal_degrees))
         * 60.0;
      l_sec_60 := ROUND (l_sec_dms, 2);

      IF l_sec_60 = 60
      THEN
         RETURN 0;
      ELSE
         RETURN l_sec_dms;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         -- Consider logging the error and then re-raise
         RAISE;
   END sec_dms;

   --
   FUNCTION min_dm (p_decimal_degrees IN NUMBER)
      RETURN NUMBER
   IS
   BEGIN
      RETURN (ABS (p_decimal_degrees - TRUNC (p_decimal_degrees)) * 60);
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         -- Consider logging the error and then re-raise
         RAISE;
   END min_dm;

   --
   -- Filter out PST and CST
   function get_timezone (p_timezone in varchar2)
   return varchar2
   is
      l_timezone varchar2(28);
   begin
      if p_timezone is not null then
         begin
            select time_zone_name
              into l_timezone
              from cwms_time_zone_alias
             where upper(time_zone_alias) = upper(p_timezone); 
         exception
            when no_data_found then l_timezone := p_timezone;
         end;
      end if;
      return l_timezone;
   end get_timezone;

   FUNCTION get_xml_time (p_local_time IN DATE, p_local_tz IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_interval        INTERVAL DAY TO SECOND;
      l_tz_designator   VARCHAR2 (6);
      l_xml_time        VARCHAR2 (32);
   BEGIN
      l_xml_time := TO_CHAR (p_local_time, 'yyyy-mm-dd"T"hh24:mi:ss');
      l_interval :=
         CAST (p_local_time AS TIMESTAMP)
         - CAST (
              cwms_util.change_timezone (p_local_time, p_local_tz, 'UTC') AS TIMESTAMP);
      l_tz_designator :=
         CASE l_interval = TO_DSINTERVAL ('00 00:00:00')
            WHEN TRUE
      THEN
               'Z'
         ELSE
                  TO_CHAR (EXTRACT (HOUR FROM l_interval), 'S09')
               || ':'
               || TRIM (TO_CHAR (EXTRACT (MINUTE FROM l_interval), '09'))
         END;
      RETURN l_xml_time || l_tz_designator;
   END get_xml_time;

   FUNCTION FIXUP_TIMEZONE (p_time IN TIMESTAMP WITH TIME ZONE)
      RETURN TIMESTAMP WITH TIME ZONE
   IS
      l_time   TIMESTAMP WITH TIME ZONE;
   BEGIN
      CASE EXTRACT (TIMEZONE_REGION FROM p_time)
         WHEN 'PST'
         THEN
            CASE EXTRACT (TIMEZONE_ABBR FROM p_time)
               WHEN 'PDT'
               THEN
                  l_time :=
                     (p_time + TO_DSINTERVAL ('0 01:00:00'))
                        AT TIME ZONE 'ETC/GMT+8';
               ELSE
                  l_time := p_time;
            END CASE;
         WHEN 'CST'
         THEN
            CASE EXTRACT (TIMEZONE_ABBR FROM p_time)
               WHEN 'CDT'
               THEN
                  l_time :=
                     (p_time + TO_DSINTERVAL ('0 01:00:00'))
                        AT TIME ZONE 'ETC/GMT+6';
               ELSE
                  l_time := p_time;
            END CASE;
         ELSE
            l_time := p_time;
      END CASE;

      RETURN l_time;
   END FIXUP_TIMEZONE;

   --
   -- return the p_in_date which is in p_in_tz as a date in UTC
   FUNCTION date_from_tz_to_utc (p_in_date IN DATE, p_in_tz IN VARCHAR2)
      RETURN DATE
   IS
   BEGIN
      RETURN change_timezone (p_in_date, p_in_tz);
   END date_from_tz_to_utc;

   --
   -- return the input date in a different time zone
   FUNCTION change_timezone (p_in_date   IN TIMESTAMP,
                             p_from_tz   IN VARCHAR2,
                             p_to_tz     IN VARCHAR2 DEFAULT 'UTC')
      RETURN TIMESTAMP
      RESULT_CACHE
   IS
   BEGIN
      RETURN CASE p_to_tz = p_from_tz
                WHEN TRUE
                THEN
                   p_in_date
                ELSE
                   FROM_TZ (p_in_date, get_timezone (p_from_tz))
                      AT TIME ZONE get_timezone (p_to_tz)
             END;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN NULL;
   END change_timezone;

   --
   -- return the input date in a different time zone
   FUNCTION change_timezone (p_in_date   IN DATE,
                             p_from_tz   IN VARCHAR2,
                             p_to_tz     IN VARCHAR2 DEFAULT 'UTC')
      RETURN DATE
      RESULT_CACHE
   IS
   BEGIN
      RETURN CASE p_to_tz = p_from_tz
                WHEN TRUE
                THEN
                   p_in_date
                ELSE
                   CAST (
                      FROM_TZ (CAST (p_in_date AS TIMESTAMP),
                               get_timezone (p_from_tz))
                         AT TIME ZONE get_timezone (p_to_tz) AS DATE)
             END;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN NULL;
   END change_timezone;

   FUNCTION get_base_id (p_full_id IN VARCHAR2)
      RETURN VARCHAR2
      RESULT_CACHE
   IS
      l_num          NUMBER
                        := INSTR (p_full_id,
                                  '-',
                                  1,
                                  1);
      l_length       NUMBER := LENGTH (p_full_id);
      l_sub_length   NUMBER := l_length - l_num;
   BEGIN
      IF    INSTR (p_full_id,
                   '.',
                   1,
                   1) > 0
         OR l_num = l_length
         OR l_num = 1
         OR l_sub_length > max_sub_id_length
         OR l_num > max_base_id_length + 1
         OR l_length > max_full_id_length
      THEN
         cwms_err.raise ('INVALID_FULL_ID', p_full_id);
      END IF;

      IF l_num = 0
      THEN
         RETURN p_full_id;
      ELSE
         RETURN SUBSTR (p_full_id, 1, l_num - 1);
      END IF;
   END get_base_id;

   FUNCTION get_base_param_code (p_param_id     IN VARCHAR2,
                                 p_is_full_id   IN VARCHAR2 DEFAULT 'F')
      RETURN NUMBER
      RESULT_CACHE
   IS
      l_base_param_code   NUMBER (10);
      l_base_param_id     VARCHAR2 (16);
   BEGIN
      CASE cwms_util.is_true (p_is_full_id)
         WHEN TRUE
         THEN
            l_base_param_id := get_base_id (p_param_id);
         WHEN FALSE
         THEN
            l_base_param_id := p_param_id;
      END CASE;

      SELECT base_parameter_code
        INTO l_base_param_code
        FROM cwms_base_parameter
       WHERE UPPER (base_parameter_id) = UPPER (TRIM (l_base_param_id));

      RETURN l_base_param_code;
   END get_base_param_code;

   FUNCTION get_sub_id (p_full_id IN VARCHAR2)
      RETURN VARCHAR2
      RESULT_CACHE
   IS
      l_num          NUMBER
                        := INSTR (p_full_id,
                                  '-',
                                  1,
                                  1);
      l_length       NUMBER := LENGTH (p_full_id);
      l_sub_length   NUMBER := l_length - l_num;
   BEGIN
      IF    INSTR (p_full_id,
                   '.',
                   1,
                   1) > 0
         OR l_num = l_length
         OR l_num = 1
         OR l_sub_length > max_sub_id_length
         OR l_num > max_base_id_length + 1
         OR l_length > max_full_id_length
      THEN
         cwms_err.raise ('INVALID_FULL_ID', p_full_id);
      END IF;

      IF l_num = 0
      THEN
         RETURN NULL;
      ELSE
         RETURN SUBSTR (p_full_id, l_num + 1, l_sub_length);
      END IF;
   END get_sub_id;

   FUNCTION is_true (p_true_false IN VARCHAR2)
      RETURN BOOLEAN
      RESULT_CACHE
   IS
   BEGIN
      IF UPPER (p_true_false) = 'T' OR UPPER (p_true_false) = 'TRUE'
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_true;

   --
   FUNCTION is_false (p_true_false IN VARCHAR2)
      RETURN BOOLEAN
      RESULT_CACHE
   IS
   BEGIN
      IF UPPER (p_true_false) = 'F' OR UPPER (p_true_false) = 'FALSE'
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_false;

   -- Retruns TRUE if p_true_false is T or True
   -- Returns FALSE if p_true_false is F or False.
   FUNCTION return_true_or_false (p_true_false IN VARCHAR2)
      RETURN BOOLEAN
      RESULT_CACHE
   IS
   BEGIN
      IF cwms_util.is_true (p_true_false)
      THEN
         RETURN TRUE;
      ELSIF cwms_util.is_false (p_true_false)
      THEN
         RETURN FALSE;
      ELSE
         cwms_err.raise ('INVALID_T_F_FLAG', p_true_false);
      END IF;
   END return_true_or_false;

   -- Retruns 'T' if p_true_false is T or True
   -- Returns 'F 'if p_true_false is F or False.
   FUNCTION return_t_or_f_flag (p_true_false IN VARCHAR2)
      RETURN VARCHAR2
      RESULT_CACHE
   IS
   BEGIN
      IF cwms_util.is_true (p_true_false)
      THEN
         RETURN 'T';
      ELSIF cwms_util.is_false (p_true_false)
      THEN
         RETURN 'F';
      ELSE
         cwms_err.raise ('INVALID_T_F_FLAG', p_true_false);
      END IF;
   END return_t_or_f_flag;

   --------------------------------------------------------------------------------
   -- function get_real_name
   --
   FUNCTION get_real_name (p_synonym IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_name             VARCHAR2 (32) := UPPER (p_synonym);
      invalid_sql_name   EXCEPTION;
      PRAGMA EXCEPTION_INIT (invalid_sql_name, -44003);
   BEGIN
      BEGIN
         SELECT DBMS_ASSERT.simple_sql_name (l_name) INTO l_name FROM DUAL;

         SELECT table_name
           INTO l_name
           FROM sys.all_synonyms
          WHERE     synonym_name = l_name
                AND owner = 'PUBLIC'
                AND table_owner = '&cwms_schema';
      EXCEPTION
         WHEN invalid_sql_name
         THEN
            cwms_err.raise ('INVALID_ITEM', p_synonym, 'schema item name');
         WHEN NO_DATA_FOUND
         THEN
            NULL;
      END;

      RETURN l_name;
   END get_real_name;

   --------------------------------------------------------
   -- Return the current session user's primary office id
   --
   FUNCTION user_office_id
      RETURN VARCHAR2
   IS
      l_office_id   VARCHAR2 (16);
      l_username    VARCHAR2 (32);
      l_upass_id    VARCHAR2 (32) := 'UPASSADM';
   BEGIN
      l_username := get_user_id;


      BEGIN
      	SELECT prop_value INTO l_upass_id FROM at_properties where prop_id='sec.upass.id' and prop_category='CWMS' and office_code=53;
      EXCEPTION WHEN OTHERS
      THEN
	NULL;
      END;
      SELECT SYS_CONTEXT ('CWMS_ENV', 'SESSION_OFFICE_ID')
        INTO l_office_id
        FROM DUAL;

      IF l_office_id IS NULL
      THEN
         IF l_username = '&cwms_schema' or l_username = 'NOBODY' or l_username = 'CCP' or l_username = 'SYS' or l_username = l_upass_id
         THEN
            RETURN 'CWMS';
         ELSE
      BEGIN
         SELECT a.office_id
           INTO l_office_id
           FROM cwms_office a, at_sec_user_office b
          WHERE     b.username = l_username
		AND a.office_code=b.db_office_code;
	    EXCEPTION WHEN OTHERS THEN
                cwms_err.raise ('SESSION_OFFICE_ID_NOT_SET');
            END;
         END IF;
         END IF;

      RETURN l_office_id;
   END user_office_id;

   PROCEDURE get_user_office_data (p_office_id          OUT VARCHAR2,
                                   p_office_long_name   OUT VARCHAR2)
   IS
      l_office_id   VARCHAR2 (16) := user_office_id;
   BEGIN
      SELECT office_id, long_name
           INTO p_office_id, p_office_long_name
        FROM cwms_office
       WHERE office_id = l_office_id;
   END get_user_office_data;

   --------------------------------------------------------
   -- Return the current session user's primary office code
   --
   FUNCTION user_office_code
      RETURN NUMBER
   IS
      l_office_code   NUMBER (10) := 0;
      l_office_id     VARCHAR2 (16) := user_office_id;
      BEGIN
      SELECT office_code
        INTO l_office_code
        FROM cwms_office
       WHERE office_id = l_office_id;


      RETURN l_office_code;
   END user_office_code;

   --------------------------------------------------------
   -- Return the office code for the specified office id,
   -- or the user's primary office if the office id is null
   --
   FUNCTION get_office_code (p_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER
   IS
      l_office_code   NUMBER := NULL;
   BEGIN
      IF p_office_id IS NULL
      THEN
         l_office_code := user_office_code;
      ELSE
         SELECT office_code
           INTO l_office_code
           FROM cwms_office
          WHERE (office_id) = UPPER (p_office_id);
      END IF;

      RETURN l_office_code;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise ('INVALID_OFFICE_ID', p_office_id);
   END get_office_code;

   --------------------------------------------------------
   -- Return the db host office code for the specified office id,
   -- or the user's primary office if the office id is null
   --
   FUNCTION get_db_office_code (p_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER
   IS
      l_db_office_code   NUMBER := NULL;
   BEGIN
      RETURN get_office_code (p_office_id);
   END get_db_office_code;

   FUNCTION get_db_office_id_from_code (p_db_office_code IN NUMBER)
      RETURN VARCHAR2
   IS
      l_db_office_id   VARCHAR2 (64);
   BEGIN
      l_db_office_id := NULL;

      SELECT office_id
        INTO l_db_office_id
        FROM cwms_office
       WHERE office_code = p_db_office_code;


      RETURN l_db_office_id;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN l_db_office_id;
   END get_db_office_id_from_code;

   --------------------------------------------------------
   --------------------------------------------------------
   FUNCTION get_db_office_id (p_db_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_db_office_code   NUMBER := NULL;
      l_db_office_id     VARCHAR2 (16);
   BEGIN
      IF p_db_office_id IS NULL
      THEN
         l_db_office_id := user_office_id;
      ELSE
         SELECT office_id
           INTO l_db_office_id
           FROM cwms_office
          WHERE (office_id) = UPPER (p_db_office_id);
      END IF;

      RETURN l_db_office_id;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise ('INVALID_OFFICE_ID', p_db_office_id);
   END get_db_office_id;

   --------------------------------------------------------
   --------------------------------------------------------
   FUNCTION get_location_id (p_location_code    IN NUMBER,
                             p_prepend_office   IN VARCHAR2 DEFAULT 'F')
      RETURN VARCHAR2
   IS
      l_location_id   VARCHAR2 (183);
      l_office_id     VARCHAR2 (16);
   BEGIN
      SELECT o.office_id,
                bl.base_location_id
             || SUBSTR ('-', 1, LENGTH (pl.sub_location_id))
             || pl.sub_location_id
        INTO l_office_id, l_location_id
        FROM at_physical_location pl, at_base_location bl, cwms_office o
       WHERE     pl.location_code = p_location_code
             AND bl.base_location_code = pl.base_location_code
             AND o.office_code = bl.db_office_code;

      IF is_true (p_prepend_office)
      THEN
         RETURN l_office_id || '/' || l_location_id;
      END IF;

      RETURN l_location_id;
   END get_location_id;

   --------------------------------------------------------
   --------------------------------------------------------
   FUNCTION get_parameter_id (p_parameter_code IN NUMBER)
      RETURN VARCHAR2
      RESULT_CACHE
   IS
      l_parameter_id   VARCHAR2 (49);
   BEGIN
      BEGIN
         SELECT    cbp.base_parameter_id
                || SUBSTR ('-', 1, LENGTH (atp.sub_parameter_id))
                || atp.sub_parameter_id
           INTO l_parameter_id
           FROM at_parameter atp, cwms_base_parameter cbp
          WHERE atp.parameter_code = p_parameter_code
                AND atp.base_parameter_code = cbp.base_parameter_code;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise (
               'ERROR',
               p_parameter_code || ' is not a valid parameter_code.');
      END;

      RETURN l_parameter_id;
   END get_parameter_id;

   --------------------------------------------------------
   -- Replace filename wildcard chars (?,*) with SQL ones
   -- (_,%), using '\' as an escape character.
   --
   --  A null input generates a result of '%'.
   --
   -- +--------------+-------------------------------------------------------------------------+
   -- |     |       Output String                |
   -- |     +------------------------------------------------------------+------------+
   -- |     |          Recognize SQL       |      |
   -- |     |           Wildcards?        |      |
   -- |     +------+---------------------------+-----+-------------------+      |
   -- | Input String | No  : comments        | Yes : comments    | Different? |
   -- +--------------+------+---------------------------+-----+-------------------+------------+
   -- | %    | \%  : literal '%'               | %   : multi-wildcard    | Yes        |
   -- | _    | \_  : literal '_'               | _   : single-wildcard   | Yes        |
   -- | *    | %  : multi-wildcard      | %   : multi-wildcard  | No     |
   -- | ?    | _  : single-wildcard     | _   : single-wildcard  | No     |
   -- | \%    |   : not allowed       | \%  : literal '%'       | Yes        |
   -- | \_    |   : not allowed       | \_  : literal '_'       | Yes        |
   -- | \*    | *  : literal '*'               | *   : literal '*'       | No         |
   -- | \?    | ?  : literal '?'               | ?   : literal '?'       | No         |
   -- | \\%    | \\\% : literal '\' + literal '%' | \\% : literal '\' + mwc | Yes        |
   -- | \\_    | \\\_ : literal '\' + literal '\' | \\_ : literal '\' + swc | Yes        |
   -- | \\*    | \\%  : literal '\' + mwc         | \\% : literal '\' + mwc | No         |
   -- | \\?    | \\_  : literal '\' + swc         | \\_ : literal '\' + swc | No         |
   -- +--------------+------+---------------------------+-----+-------------------+------------+
   --
   FUNCTION normalize_wildcards (p_string          IN VARCHAR2,
                                 p_recognize_sql   IN BOOLEAN DEFAULT FALSE)
      RETURN VARCHAR2
   IS
      l_result              VARCHAR2 (32767);
      c_slash      CONSTANT VARCHAR2 (1) := CHR (1);
      c_star       CONSTANT VARCHAR2 (1) := CHR (2);
      c_question   CONSTANT VARCHAR2 (1) := CHR (3);
   BEGIN
      --------------------------------
      -- default null string to '%' --
      --------------------------------
      IF p_string IS NULL
      THEN
         RETURN '%';
      END IF;

      l_result := REPLACE (p_string, '\\', c_slash);
      l_result := REPLACE (l_result, '\*', c_star);
      l_result := REPLACE (l_result, '\?', c_question);

      IF SUBSTR (l_result, LENGTH (l_result), 1) = '\'
      THEN
         cwms_err.raise (
            'ERROR',
            'Escape characater ''\'' cannot be the last character.');
      END IF;

      IF NOT p_recognize_sql
      THEN
         IF INSTR (l_result, '\%') + INSTR (l_result, '\_') != 0
         THEN
            cwms_err.raise (
               'ERROR',
               'Cannot have ''\%'' or ''\_'' if p_recognize_sql is false.');
         END IF;

         l_result := REGEXP_REPLACE (l_result, '%', '\%');
         l_result := REGEXP_REPLACE (l_result, '_', '\_');
      END IF;

      l_result := REPLACE (l_result, '*', '%');
      l_result := REPLACE (l_result, '?', '_');
      l_result := REPLACE (l_result, c_slash, '\\');
      l_result := REPLACE (l_result, c_star, '*');
      l_result := REPLACE (l_result, c_question, '?');

      RETURN l_result;
   END normalize_wildcards;

   --------------------------------------------------------
   -- Replace SQL ones (_,%) with filename wildcard chars (?,*),
   -- using '\' as an escape character.
   FUNCTION denormalize_wildcards (p_string IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_result              VARCHAR2 (32767);
      c_slash      CONSTANT VARCHAR2 (1) := CHR (1);
      c_percent    CONSTANT VARCHAR2 (1) := CHR (2);
      c_underbar   CONSTANT VARCHAR2 (1) := CHR (3);
   BEGIN
      --------------------------------
      -- default null string to '*' --
      --------------------------------
      IF p_string IS NULL
      THEN
         RETURN '*';
      END IF;

      l_result := REPLACE (p_string, '\\', c_slash);
      l_result := REPLACE (l_result, '\%', c_percent);
      l_result := REPLACE (l_result, '\_', c_underbar);

      IF SUBSTR (l_result, LENGTH (l_result), 1) = '\'
      THEN
         cwms_err.raise (
            'ERROR',
            'Escape characater ''\'' cannot be the last character.');
      END IF;

      l_result := REPLACE (l_result, '%', '*');
      l_result := REPLACE (l_result, '_', '?');
      l_result := REPLACE (l_result, c_slash, '\\');
      l_result := REPLACE (l_result, c_percent, '%');
      l_result := REPLACE (l_result, c_underbar, '_');

      RETURN l_result;
   END denormalize_wildcards;

   PROCEDURE parse_ts_id (p_base_location_id       OUT VARCHAR2,
                          p_sub_location_id        OUT VARCHAR2,
                          p_base_parameter_id      OUT VARCHAR2,
                          p_sub_parameter_id       OUT VARCHAR2,
                          p_parameter_type_id      OUT VARCHAR2,
                          p_interval_id            OUT VARCHAR2,
                          p_duration_id            OUT VARCHAR2,
                          p_version_id             OUT VARCHAR2,
                          p_cwms_ts_id          IN     VARCHAR2)
   IS
   BEGIN
      cwms_ts.parse_ts (p_cwms_ts_id          => p_cwms_ts_id,
                        p_base_location_id    => p_base_location_id,
                        p_sub_location_id     => p_sub_location_id,
                        p_base_parameter_id   => p_base_parameter_id,
                        p_sub_parameter_id    => p_sub_parameter_id,
                        p_parameter_type_id   => p_parameter_type_id,
                        p_interval_id         => p_interval_id,
                        p_duration_id         => p_duration_id,
                        p_version_id          => p_version_id);
   END parse_ts_id;

   --------------------------------------------------------------------------------
   -- Parses a search string into one or more AND/OR LIKE/NOT LIKE predicate lines.
   -- A search string contains one or more search patterns separated by a blank -
   -- space. When constructing search patterns on can use AND, OR, and NOT between-
   -- search patterns. a blank space between two patterns is assumed to be an AND.
   -- Quotes can be used to aggregate search patterns that contain one or more  -
   -- blank spaces.
   --
   FUNCTION parse_search_string (p_search_patterns   IN VARCHAR2,
                                 p_search_column     IN VARCHAR2,
                                 p_use_upper         IN BOOLEAN DEFAULT TRUE)
      RETURN VARCHAR2
   --------------------------------------------------------------------------------
   -- Usage:                    -
   --   *  - wild card character matches zero or more occurences.   -
   --   ?  - wild card character matches zero or one occurence.   -
   --   and - AND or a blank space, e.g., abc* *123 is eqivalent to   -
   --             abc* AND *123       -
   --   or - OR  e.g., abc* OR *123             -
   --   not - NOT or a dash, e.g., 'NOT abc*' is equivalent to '-abc*'     -
   --   " " - quotes are used to aggregate patters that have blank spaces   -
   --   e.g., "abc 123*"                                              -
   --
   --   One can use the backslash as an escape character for the following  -
   --   special characters:               -
   --   \* used to make an asterisks a literal instead of a wild character  -                    -
   --   \? used to make a question mark a literal instead of a wild   -
   --   character                   -
   --   \- used to start a new parse pattern with a dash instead of a NOT -
   --   \" used to make a quote a literal part of the parse pattern.        -
   --
   -- Example:
   -- p_search_column: COLUMN_OF_INTEREST           -
   -- p_search_patterns: cb* NOT cbt* OR NOT cbk*         -
   --   will return:                  -
   --    AND UPPER(COLUMN_OF_INTEREST)  LIKE 'CB%'                -
   --    AND UPPER(COLUMN_OF_INTEREST) NOT LIKE 'CBT%'            -
   --    OR UPPER(COLUMN_OF_INTEREST) NOT LIKE 'CBK%'             -
   --
   --  if p_use_upper is set to false, the above will return:
   --
   --     AND COLUMN_OF_INTEREST  LIKE 'cb%'                      -
   --     AND COLUMN_OF_INTEREST NOT LIKE 'cbt%'                  -
   --     OR COLUMN_OF_INTEREST NOT LIKE 'cbk%'                   -
   --
   --  A null p_search_patterns generates a result of '%'.
   --
   --     AND COLUMN_OF_INTEREST  LIKE '%'                        -
   --------------------------------------------------------------------------------
   --
   IS
      l_string                VARCHAR2 (256) := TRIM (p_search_patterns);
      l_search_column         VARCHAR2 (30) := UPPER (TRIM (p_search_column));
      l_use_upper             BOOLEAN := NVL (p_use_upper, TRUE);
      l_recognize_sql         BOOLEAN := FALSE;
      l_string_length         NUMBER := NVL (LENGTH (l_string), 0);
      l_skip                  NUMBER := 0;
      l_looking_first_quote   BOOLEAN := TRUE;
      l_sub_string_done       BOOLEAN := FALSE;
      l_first_char            BOOLEAN := TRUE;
      l_char                  VARCHAR2 (1);
      l_sub_string            VARCHAR2 (64) := NULL;
      l_not                   VARCHAR2 (3) := NULL;
      l_and_or                VARCHAR2 (3) := 'AND';
      l_result                VARCHAR2 (1000) := NULL;
      l_open_upper            VARCHAR2 (7);
      l_close_upper           VARCHAR2 (2);
      l_open_paran            VARCHAR2 (10) := NULL;
      l_close_paran           VARCHAR2 (10) := NULL;
      l_space                 VARCHAR2 (1) := ' ';
      l_num_open_paran        NUMBER := 0;
      l_char_position         NUMBER := 0;
      l_num_element           NUMBER := 0;
      l_tmp_string            VARCHAR2 (100) := NULL;
      l_is_closing_quotes     BOOLEAN;
   BEGIN
      --
      -- set the UPPER( ) wrapper...
      IF l_use_upper
      THEN
         l_open_upper := ' UPPER(';
         l_close_upper := ') ';
      ELSE
         l_open_upper := ' ';
         l_close_upper := ' ';
      END IF;

      --
      -- Make sure something was passed in.
      IF l_string_length > 0
      THEN
         FOR i IN 1 .. LENGTH (l_string)
         LOOP
            --   IF l_looking_first_quote
            --   THEN
            --   l_t := 'T';
            --   ELSE
            --   l_t := 'F';
            --   END IF;

            --   DBMS_OUTPUT.put_line (  l_t
            --         || l_char_position
            --         || '>'
            --         || l_sub_string
            --         || '< skip: '
            --         || l_skip
            --        );
            IF l_skip > 0
            THEN
               l_skip := l_skip - 1;
            ELSE
               l_char := SUBSTR (l_string, i, 1);

               --dbms_output.put_line('>>' || l_char || '<<');
               CASE l_char
                  WHEN '\'
                  THEN
                     IF REGEXP_INSTR (NVL (SUBSTR (l_string, i + 1, 1), ' '),
                                      '["*?\(\)]') = 1
                     THEN
                        l_sub_string :=
                           l_sub_string || '\' || SUBSTR (l_string, i + 1, 1);
                        l_char_position := l_char_position + 2;
                     ELSE
                        l_sub_string :=
                           l_sub_string || SUBSTR (l_string, i + 1, 1);
                        l_char_position := l_char_position + 1;
                     END IF;

                     l_skip := l_skip + 1;
                  WHEN '('
                  THEN
                     IF l_char_position = 0
                     THEN
                        l_sub_string := l_sub_string || l_char;
                     ELSE
                        l_sub_string := l_sub_string || l_char;
                        l_char_position := l_char_position + 1;
                     END IF;
                  WHEN ')'
                  THEN
                     l_tmp_string := NULL;

                     FOR j IN i .. l_string_length
                     LOOP
                        l_tmp_string := l_tmp_string || ')';
                        l_skip := l_skip + 1;

                        --DBMS_OUTPUT.put_line (l_tmp_string);
                        IF j = l_string_length
                           OR INSTR (NVL (SUBSTR (l_string, j + 1, 1), ' '),
                                     ' ') = 1
                        THEN
                           l_is_closing_quotes := TRUE;
                           EXIT;
                        ELSIF INSTR (NVL (SUBSTR (l_string, j + 1, 1), ' '),
                                     ')') = 1
                        THEN
                           NULL;
                        ELSE
                           l_is_closing_quotes := FALSE;
                           EXIT;
                        END IF;
                     END LOOP;

                     IF l_is_closing_quotes
                     THEN
                        l_close_paran := l_tmp_string;
                     ELSE
                        l_sub_string := l_sub_string || l_tmp_string;
                     END IF;
                  WHEN '"'
                  THEN
                     IF l_looking_first_quote
                     THEN
                        IF l_char_position = 0
                        THEN
                           l_looking_first_quote := FALSE;
                        ELSE
                           l_sub_string := l_sub_string || l_char;
                           l_char_position := l_char_position + 1;
                        END IF;
                     ELSE                        -- looking for the end quote.
                        --
                        -- An end quote must be followed by a space or end the string.
                        --
                        l_tmp_string := NULL;

                        FOR j IN i .. l_string_length
                        LOOP
                           -- l_tmp_string := l_tmp_string || ')';
                           --l_skip := l_skip + 1;
                           --DBMS_OUTPUT.put_line (l_tmp_string);
                           IF j = l_string_length
                              OR INSTR (
                                    NVL (SUBSTR (l_string, j + 1, 1), ' '),
                                    ' ') = 1
                           THEN
                              l_is_closing_quotes := TRUE;
                              l_sub_string_done := TRUE;
                              --dbms_output.put_line('string is done!');
                              EXIT;
                           ELSIF INSTR (
                                    NVL (SUBSTR (l_string, j + 1, 1), ' '),
                                    ')') = 1
                           THEN
                              l_tmp_string := l_tmp_string || ')';
                              l_skip := l_skip + 1;
                           ELSE
                              l_is_closing_quotes := FALSE;
                              EXIT;
                           END IF;
                        END LOOP;

                        IF l_is_closing_quotes
                        THEN
                           l_close_paran := l_tmp_string;
                        ELSE
                           l_sub_string := '"' || l_sub_string || l_tmp_string;
                        END IF;
                     -----------------
                     --     IF  INSTR (NVL (SUBSTR (l_string, i + 1), ' '), ' ') =
                     --                       1
                     --      OR i = l_string_length
                     --     THEN
                     --      l_skip := l_skip + 1;
                     --      l_sub_string_done := TRUE;
                     --     ELSE
                     --      l_sub_string := l_sub_string || l_char;
                     --      l_char_position := l_char_position + 1;
                     --     END IF;
                     END IF;
                  WHEN ' '
                  THEN
                     IF l_looking_first_quote
                     THEN
                        l_sub_string_done := TRUE;
                     ELSE
                        l_sub_string := l_sub_string || l_char;
                        l_char_position := l_char_position + 1;
                     END IF;
                  ELSE
                     l_sub_string := l_sub_string || l_char;
                     l_char_position := l_char_position + 1;
               END CASE;
            END IF;

            IF l_sub_string_done OR i = l_string_length
            THEN
               IF LENGTH (l_sub_string) > 0
               THEN
                  IF i = l_string_length
                  THEN
                     l_sub_string_done := TRUE;
                  END IF;

                  IF l_looking_first_quote
                  THEN
                     CASE l_sub_string
                        WHEN 'OR'
                        THEN
                           l_and_or := 'OR';
                           l_sub_string_done := FALSE;
                        WHEN 'AND'
                        THEN
                           l_and_or := 'AND';
                           l_sub_string_done := FALSE;
                        WHEN 'NOT'
                        THEN
                           l_not := 'NOT';
                           l_sub_string_done := FALSE;
                        ELSE
                           NULL;
                     END CASE;
                  END IF;

                  IF l_sub_string_done
                  THEN
                     l_sub_string :=
                        cwms_util.normalize_wildcards (
                           p_string          => l_sub_string,
                           p_recognize_sql   => l_recognize_sql);

                     IF l_use_upper
                     THEN
                        l_sub_string := UPPER (l_sub_string);
                     END IF;

                     IF l_num_element = 0
                     THEN
                        l_and_or := ' ( ';
                        l_num_element := 1;
                     END IF;

                     l_result :=
                           l_result
                        || ' '
                        || l_and_or
                        || l_space
                        || l_open_paran
                        || l_open_upper
                        || l_search_column
                        || l_close_upper
                        || l_not
                        || ' LIKE '''
                        || l_sub_string
                        || ''' '
                        || l_close_paran
                        || l_space
                        || CHR (10);
                     l_and_or := 'AND';
                     l_not := NULL;
                     l_open_paran := NULL;
                     l_close_paran := NULL;
                     l_looking_first_quote := TRUE;
                  END IF;
               END IF;

               l_first_char := TRUE;
               l_sub_string := NULL;
               l_sub_string_done := FALSE;
               l_char_position := 0;
            END IF;
         END LOOP;

         l_result := l_result || ' ) ';
      ELSE
         l_result := ' 1 = 1 ';
      END IF;

      RETURN l_result;
   END parse_search_string;

   --------------------------------------------------------------------
   -- Return a string with all leading and trailing whitespace removed.
   --
   FUNCTION strip (p_text IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_first   PLS_INTEGER := 1;
      l_last    PLS_INTEGER := LENGTH (p_text);
   BEGIN
      if p_text is null then 
         return null; 
      end if;
      FOR i IN l_first .. l_last
      LOOP
         l_first := i;
         EXIT WHEN ASCII (SUBSTR (p_text, i, 1)) BETWEEN 33 AND 126;
      END LOOP;

      FOR i IN REVERSE l_first .. l_last
      LOOP
         l_last := i;
         EXIT WHEN ASCII (SUBSTR (p_text, i, 1)) BETWEEN 33 AND 126;
      END LOOP;

      RETURN SUBSTR (p_text, l_first, l_last - l_first + 1);
   END strip;

   --------------------------------------------------------------------------------
   PROCEDURE test
   IS
   BEGIN
      DBMS_OUTPUT.put_line ('successful test');
   END test;

   FUNCTION concat_base_sub_id (p_base_id IN VARCHAR2, p_sub_id IN VARCHAR2)
      RETURN VARCHAR2
      RESULT_CACHE
   IS
   BEGIN
      RETURN    p_base_id
             || SUBSTR ('-', 1, LENGTH (TRIM (p_sub_id)))
             || TRIM (p_sub_id);
   END concat_base_sub_id;

   FUNCTION concat_ts_id (p_base_location_id    IN VARCHAR2,
                          p_sub_location_id     IN VARCHAR2,
                          p_base_parameter_id   IN VARCHAR2,
                          p_sub_parameter_id    IN VARCHAR2,
                          p_parameter_type_id   IN VARCHAR2,
                          p_interval_id         IN VARCHAR2,
                          p_duration_id         IN VARCHAR2,
                          p_version_id          IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_base_location_id    VARCHAR2 (16) := TRIM (p_base_location_id);
      l_sub_location_id     VARCHAR2 (32) := TRIM (p_sub_location_id);
      l_base_parameter_id   VARCHAR2 (16) := TRIM (p_base_parameter_id);
      l_sub_parameter_id    VARCHAR2 (32) := TRIM (p_sub_parameter_id);
      l_parameter_type_id   VARCHAR2 (16) := TRIM (p_parameter_type_id);
      l_interval_id         VARCHAR2 (16) := TRIM (p_interval_id);
      l_duration_id         VARCHAR2 (16) := TRIM (p_duration_id);
      l_version_id          VARCHAR2 (32) := TRIM (p_version_id);
   BEGIN
      SELECT cbp.base_parameter_id
        INTO l_base_parameter_id
        FROM cwms_base_parameter cbp
       WHERE UPPER (cbp.base_parameter_id) = UPPER (l_base_parameter_id);

      SELECT cpt.parameter_type_id
        INTO l_parameter_type_id
        FROM cwms_parameter_type cpt
       WHERE UPPER (cpt.parameter_type_id) = UPPER (l_parameter_type_id);

      SELECT interval_id
        INTO l_interval_id
        FROM cwms_interval ci
       WHERE UPPER (ci.interval_id) = UPPER (l_interval_id);

      SELECT duration_id
        INTO l_duration_id
        FROM cwms_duration cd
       WHERE UPPER (cd.duration_id) = UPPER (l_duration_id);

      IF l_parameter_type_id = 'Inst' AND l_duration_id != '0'
      THEN
         cwms_err.raise (
            'ERROR',
               'The Duration Id for an "Inst" record cannot be "'
            || l_duration_id
            || '". The Duration Id must be "0".');
      -----------------------------------------------------------------
      -- This condition is no longer true. A "0" duration indicates  --
      -- a duration from the last irregular value to the current one --
      -----------------------------------------------------------------
      -- ELSIF l_parameter_type_id IN ('Ave', 'Max', 'Min', 'Total') AND l_duration_id = '0'
      -- THEN
      --  cwms_err.raise (
      --   'ERROR',
      --    'A Parameter Type of "'
      --   || l_parameter_type_id
      --   || '" cannot have a "0" Duration Id.'
      --  );
      END IF;

      RETURN    l_base_location_id
             || SUBSTR ('-', 1, LENGTH (l_sub_location_id))
             || l_sub_location_id
             || '.'
             || l_base_parameter_id
             || SUBSTR ('-', 1, LENGTH (l_sub_parameter_id))
             || l_sub_parameter_id
             || '.'
             || l_parameter_type_id
             || '.'
             || l_interval_id
             || '.'
             || l_duration_id
             || '.'
             || l_version_id;
   END concat_ts_id;

   --------------------------------------------------------------------------------
   -- function get_time_zone_code
   --
   FUNCTION get_time_zone_code (p_time_zone_name IN VARCHAR2)
      RETURN NUMBER
   IS
      l_time_zone_code   NUMBER (10);
   BEGIN
      SELECT time_zone_code
        INTO l_time_zone_code
        FROM mv_time_zone
       WHERE time_zone_name = get_timezone (NVL (p_time_zone_name, 'UTC'));

      RETURN l_time_zone_code;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise ('INVALID_TIME_ZONE', p_time_zone_name);
   END get_time_zone_code;

   --------------------------------------------------------------------------------
   -- function get_time_zone_name
   --
   FUNCTION get_time_zone_name (p_time_zone_name IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_time_zone_name   VARCHAR2 (28);
   BEGIN
      SELECT z.time_zone_name
        INTO l_time_zone_name
        FROM mv_time_zone v, cwms_time_zone z
       WHERE upper(v.time_zone_name) = upper(get_timezone (p_time_zone_name))
             AND z.time_zone_code = v.time_zone_code;

      RETURN l_time_zone_name;
   END get_time_zone_name;

   --------------------------------------------------------------------------------
   -- function get_tz_usage_code
   --
   FUNCTION get_tz_usage_code (p_tz_usage_id IN VARCHAR2)
      RETURN NUMBER
   IS
      l_tz_usage_code   NUMBER (10);
   BEGIN
      SELECT tz_usage_code
        INTO l_tz_usage_code
        FROM cwms_tz_usage
       WHERE UPPER (tz_usage_id) = UPPER (NVL (p_tz_usage_id, 'Standard'));

      RETURN l_tz_usage_code;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise ('INVALID_ITEM',
                         p_tz_usage_id,
                         'CWMS time zone usage');
   END get_tz_usage_code;

   ----------------------------------------------------------------------------
   PROCEDURE DUMP (p_str IN VARCHAR2, p_len IN PLS_INTEGER DEFAULT 80)
   IS
      i   PLS_INTEGER;
   BEGIN
      -- Dump (put_line) a character string p_str in chunks of length p_len
      i := 1;

      WHILE i < LENGTH (p_str)
      LOOP
         DBMS_OUTPUT.put_line (SUBSTR (p_str, i, p_len));
         i := i + p_len;
      END LOOP;
   END DUMP;

   ----------------------------------------------------------------------------
   PROCEDURE create_view
   IS
      l_sel   VARCHAR2 (120);
      l_sql   VARCHAR2 (4000);

      CURSOR c1
      IS
         SELECT * FROM at_ts_table_properties;
   BEGIN
      -- Create the partitioned timeseries table view

      -- Note: start_date and end_date are coded as ANSI DATE literals

      -- CREATE OR REPLACE FORCE VIEW AV_TSV AS
      -- select ts_code, date_time, data_entry_date, value, quality,
      --   DATE '2000-01-01' start_date, DATE '2001-01-01' end_date from IOT_2000
      -- union all
      -- select ts_code, date_time, data_entry_date, value, quality,
      --   DATE '2001-01-01' start_date, DATE '2002-01-01' end_date from IOT_2001
      l_sql := 'create or replace force view av_tsv as ';
      l_sel :=
         'select ts_code, date_time, version_date, data_entry_date, value, quality_code, DATE ''';

      FOR rec IN c1
      LOOP
         IF c1%ROWCOUNT > 1
         THEN
            l_sql := l_sql || ' union all ';
         END IF;

         l_sql :=
               l_sql
            || l_sel
            || TO_CHAR (rec.start_date, 'yyyy-mm-dd')
            || ''' start_date, DATE '''
            || TO_CHAR (rec.end_date, 'yyyy-mm-dd')
            || ''' end_date from '
            || rec.table_name;
      END LOOP;

      cwms_util.DUMP (l_sql);
      EXECUTE IMMEDIATE l_sql;
   EXCEPTION
      -- ORA-24344: success with compilation error
      WHEN OTHERS
      THEN
         --dbms_output.put_line(SQLERRM);
         RAISE;
   END create_view;

   -------------------------------------------------------------------------------
   -- function split_text(...) overload to return a single element of the split
   --
   --
   FUNCTION split_text (p_text           IN VARCHAR2,
                        p_return_index   IN INTEGER,
                        p_separator      IN VARCHAR2 DEFAULT NULL,
                        p_max_split      IN INTEGER DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_str_tab        str_tab_t;
      l_return_index   INTEGER;
   BEGIN
      -- default index is first.
      IF p_return_index IS NULL
      THEN
         l_return_index := 1;
      ELSE
         l_return_index := p_return_index;
      END IF;

      --split the text.
      l_str_tab := split_text (p_text, p_separator, p_max_split);

      --error handle indexes.
      IF l_return_index <= 0 OR l_return_index > l_str_tab.COUNT
      THEN
         RETURN NULL;
      END IF;

      --grab element.
      RETURN l_str_tab (p_return_index);
   END split_text;

   -------------------------------------------------------------------------------
   -- function split_text(...)
   --
   --
   FUNCTION split_text (p_text        IN VARCHAR2,
                        p_separator   IN VARCHAR2 DEFAULT NULL,
                        p_max_split   IN INTEGER DEFAULT NULL)
      RETURN str_tab_t
      RESULT_CACHE
   IS
      l_str_tab        str_tab_t := str_tab_t ();
      l_str            VARCHAR2 (32767);
      l_field          VARCHAR2 (32767);
      l_pos            PLS_INTEGER;
      l_sep            VARCHAR2 (32767);
      l_sep_len        PLS_INTEGER;
      l_split_count    PLS_INTEGER := 0;
      l_count_splits   BOOLEAN;
   BEGIN
      IF p_text IS NOT NULL
      THEN
         l_count_splits := p_max_split IS NOT NULL;

         IF p_separator IS NULL
         THEN
            l_str := REGEXP_REPLACE (p_text, '\s+', ' ');
            l_sep := ' ';
         ELSE
            l_str := p_text;
            l_sep := p_separator;
         END IF;

         l_sep_len := LENGTH (l_sep);

         LOOP
            l_pos := INSTR (l_str, l_sep);

            IF l_count_splits AND l_split_count = p_max_split
            THEN
               l_pos := 0;
            END IF;

            IF l_pos = 0
            THEN
               l_field := l_str;
               l_str := NULL;
            ELSE
               l_split_count := l_split_count + 1;
               l_field := SUBSTR (l_str, 1, l_pos - 1);
               l_str := SUBSTR (l_str, l_pos + l_sep_len);
            END IF;

            l_str_tab.EXTEND;
            l_str_tab (l_str_tab.LAST) := l_field;
            EXIT WHEN l_pos = 0;

            IF l_str IS NULL
            THEN
               l_str_tab.EXTEND;
               l_str_tab (l_str_tab.LAST) := l_str;
               EXIT;
            END IF;
         END LOOP;
      END IF;

      RETURN l_str_tab;
   END split_text;

   -------------------------------------------------------------------------------
   -- function split_text(...)
   --
   --
   FUNCTION split_text (p_text        IN CLOB,
                        p_separator   IN VARCHAR2 DEFAULT NULL,
                        p_max_split   IN INTEGER DEFAULT NULL)
      RETURN str_tab_t
   IS
      l_clob                CLOB := p_text;
      l_rows                str_tab_t := str_tab_t ();
      l_new_rows            str_tab_t;
      l_buf                 VARCHAR2 (32767) := '';
      l_chunk               VARCHAR2 (4000);
      l_clob_offset         BINARY_INTEGER := 1;
      l_buf_offset          BINARY_INTEGER := 1;
      l_amount              BINARY_INTEGER;
      l_clob_len            BINARY_INTEGER;
      l_last                BINARY_INTEGER;
      l_done_reading        BOOLEAN;
      chunk_size   CONSTANT BINARY_INTEGER := 4000;
   BEGIN
      IF p_text IS NULL
      THEN
         RETURN NULL;
      END IF;

      l_clob_len := DBMS_LOB.getlength (l_clob);
      l_amount := LEAST (chunk_size, l_clob_len);
      DBMS_LOB.open (l_clob, DBMS_LOB.lob_readonly);

      IF l_amount > 0
      THEN
         LOOP
            DBMS_LOB.read (l_clob,
                           l_amount,
                           l_clob_offset,
                           l_chunk);
            l_clob_offset := l_clob_offset + l_amount;
            l_done_reading := l_clob_offset > l_clob_len;
            l_buf := l_buf || l_chunk;

            IF INSTR (l_buf, p_separator) > 0 OR l_done_reading
            THEN
               l_new_rows := split_text (l_buf, p_separator);

               FOR i IN 1 .. l_new_rows.COUNT - 1
               LOOP
                  l_rows.EXTEND;
                  l_rows (l_rows.LAST) := l_new_rows (i);
               END LOOP;

               l_buf := l_new_rows (l_new_rows.COUNT);

               IF l_done_reading
               THEN
                  l_rows.EXTEND;
                  l_rows (l_rows.LAST) := l_buf;
               END IF;
            END IF;

            EXIT WHEN l_done_reading;
         END LOOP;
      END IF;

      DBMS_LOB.close (l_clob);
      RETURN l_rows;
   END split_text;
   
   function split_text_regexp(
      p_text               in varchar2,
      p_separator          in varchar2,
      p_include_separators in varchar2 default 'F',
      p_match_parameter    in varchar2 default 'c',
      p_max_split          in integer default null)
      return str_tab_t
   is
      l_rows               str_tab_t := str_tab_t();
      l_start_pos          pls_integer;      -- start position of separator
      l_end_pos            pls_integer := 1; -- end position of separator plus 1
      l_len                pls_integer := length(p_text);
      l_include_separators boolean := is_true(p_include_separators);
   begin
      loop
         exit when l_end_pos > l_len;         
         l_start_pos := regexp_instr(p_text, p_separator, l_end_pos, 1, 0, p_match_parameter);
         if l_start_pos = 0 then
            l_rows.extend;
            l_rows(l_rows.count) := substr(p_text, l_end_pos);
            exit;
         end if;
         if l_start_pos > l_end_pos then
            l_rows.extend;
            l_rows(l_rows.count) := substr(p_text, l_end_pos, l_start_pos-l_end_pos+1);
         end if;
         l_end_pos := regexp_instr(p_text, p_separator, l_start_pos, 1, 1, p_match_parameter);
         if l_include_separators then
            l_rows.extend;
            l_rows(l_rows.count) := substr(p_text, l_start_pos, l_end_pos-l_start_pos);
         end if;
      end loop; 
      return l_rows;
   end split_text_regexp;            

   -------------------------------------------------------------------------------
   -- function join_text(...)
   --
   --
   FUNCTION join_text (p_text_tab    IN str_tab_t,
                       p_separator   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_text   VARCHAR2 (32767) := NULL;
   BEGIN
      FOR i IN 1 .. p_text_tab.COUNT
      LOOP
         IF i > 1
         THEN
            l_text := l_text || p_separator;
         END IF;

         l_text := l_text || p_text_tab (i);
      END LOOP;

      RETURN l_text;
   END join_text;

   --------------------------------------------------------------------------------
   -- procedure format_xml(...)
   --
   PROCEDURE format_xml (p_xml_clob IN OUT NOCOPY CLOB, p_indent IN VARCHAR2)
   IS
      l_lines              str_tab_t;
      l_level              BINARY_INTEGER := 0;
      l_len                BINARY_INTEGER := LENGTH (NVL (p_indent, ''));
      l_newline   CONSTANT VARCHAR2 (1) := CHR (10);

      PROCEDURE write_line (p_line IN VARCHAR2)
      IS
      BEGIN
         IF l_len > 0
         THEN
            FOR i IN 1 .. l_level
            LOOP
               DBMS_LOB.writeappend (p_xml_clob, l_len, p_indent);
            END LOOP;
         END IF;

         DBMS_LOB.writeappend (p_xml_clob,
                               LENGTH (p_line) + 1,
                               p_line || l_newline);
      END;
   BEGIN
      IF p_xml_clob IS NOT NULL
      THEN
         p_xml_clob := REPLACE (p_xml_clob, '<', l_newline || '<');
         p_xml_clob := REPLACE (p_xml_clob, '>', '>' || l_newline);
         p_xml_clob := REPLACE (p_xml_clob, l_newline || l_newline, l_newline);
         l_lines := split_text (p_xml_clob, l_newline);
         DBMS_LOB.open (p_xml_clob, DBMS_LOB.lob_readwrite);
         DBMS_LOB.TRIM (p_xml_clob, 0);

         FOR i IN l_lines.FIRST .. l_lines.LAST
         LOOP
            FOR once IN 1 .. 1
            LOOP
               EXIT WHEN l_lines (i) IS NULL;
               l_lines (i) := TRIM (l_lines (i));
               EXIT WHEN LENGTH (l_lines (i)) = 0;

               IF INSTR (l_lines (i), '<') = 1
               THEN
                  IF INSTR (l_lines (i), '<!--') = 1
                  THEN
                     write_line (l_lines (i));
                  ELSIF INSTR (l_lines (i), '</') = 1
                  THEN
                     l_level := l_level - 1;
                     write_line (l_lines (i));
                  ELSE
                     write_line (l_lines (i));

                     IF INSTR (l_lines (i), '<xml?') != 1
                        AND INSTR (l_lines (i), '/>', -1) !=
                               LENGTH (l_lines (i)) - 1
                     THEN
                        l_level := l_level + 1;
                     END IF;
                  END IF;
               ELSE
                  write_line (l_lines (i));
               END IF;
            END LOOP;
         END LOOP;

         DBMS_LOB.close (p_xml_clob);
      END IF;
   END format_xml;

   -------------------------------------------------------------------------------
   -- function parse_clob_recordset(...)
   --
   --
   function parse_clob_recordset (p_clob in clob)
      return str_tab_tab_t
   is
      l_tab       str_tab_tab_t;
      l_row       str_tab_t;
      l_row_pos   integer;
      l_row_start integer;         
      l_col_pos   integer;
      l_col_start integer;
      l_row_done  boolean;
      l_tab_done  boolean;         
   begin
      if p_clob is not null then
         l_tab := str_tab_tab_t();
         l_row_start := 1;
         loop         
            l_tab_done := false;
            l_row_pos := instr(p_clob, record_separator, l_row_start, 1);
            if l_row_pos = 0 then
               l_tab_done := true;
               l_row_pos := dbms_lob.getlength(p_clob);
            end if;
            l_col_start := l_row_start;
            l_row := str_tab_t();
            loop    
               l_row_done := false;
               l_col_pos := instr(p_clob, field_separator, l_col_start, 1);
               if l_col_pos = 0 or l_col_pos > l_row_pos then
                  l_row_done := true;
                  if l_col_pos = 0 then
                     l_col_pos := dbms_lob.getlength(p_clob);
                  else
                     l_col_pos := l_row_pos;
                  end if;
               end if;
               l_row.extend;
               l_row(l_row.count) := dbms_lob.substr(p_clob, l_col_pos - l_col_start, l_col_start);
               l_col_start := l_col_pos + 1;                                                       
               exit when l_row_done;
            end loop;
            l_tab.extend;
            l_tab(l_tab.count) := l_row;
            l_row_start := l_row_pos + 1;
            exit when l_tab_done;
         end loop; 
      end if;
      return l_tab;
   end parse_clob_recordset;

   -------------------------------------------------------------------------------
   -- function parse_string_recordset(...)
   --
   --
   FUNCTION parse_string_recordset (p_string IN VARCHAR2)
      RETURN str_tab_tab_t
   IS
      l_rows   str_tab_t;
      l_tab    str_tab_tab_t := str_tab_tab_t ();
   BEGIN
      IF p_string IS NULL
      THEN
         RETURN NULL;
      END IF;

      l_rows := split_text (p_string, record_separator);

      IF l_rows.COUNT > 0
      THEN
         FOR i IN l_rows.FIRST .. l_rows.LAST
         LOOP
            l_tab.EXTEND;
            l_tab (l_tab.LAST) := split_text (l_rows (i), field_separator);
         END LOOP;
      END IF;

      RETURN l_tab;
   END parse_string_recordset;

   --------------------------------------------------------------------
   -- Return UTC timestamp for specified ISO 8601 string
   --
   FUNCTION TO_TIMESTAMP (p_iso_str IN VARCHAR2)
      RETURN TIMESTAMP
   IS
      l_yr                     VARCHAR2 (5);
      l_mon                    VARCHAR2 (2) := '01';
      l_day                    VARCHAR2 (2) := '01';
      l_hr                     VARCHAR2 (2) := '00';
      l_min                    VARCHAR2 (2) := '00';
      l_sec                    VARCHAR2 (8) := '00.0';
      l_tz                     VARCHAR2 (32) := '+00:00';
      l_time                   VARCHAR2 (32);
      l_parts                  str_tab_t;
      l_ts                     TIMESTAMP;
      l_offset                 INTERVAL DAY (9) TO SECOND (9);
      l_iso_pattern   CONSTANT VARCHAR2 (71)
         := '-?\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(:(\d{2}([.]\d+)?))?([-+]\d{2}:\d{2}|Z)?' ;
      l_str                    VARCHAR2 (64) := strip (p_iso_str);
      l_pos                    BINARY_INTEGER;
      l_add_day                BOOLEAN := FALSE;
   BEGIN
      IF REGEXP_INSTR (l_str, l_iso_pattern) != 1
         OR REGEXP_INSTR (l_str,
                          l_iso_pattern,
                          1,
                          1,
                          1) != LENGTH (l_str) + 1
      THEN
         cwms_err.raise ('INVALID_ITEM', l_str, 'dateTime-formatted string');
      END IF;

      l_pos :=
         REGEXP_INSTR (l_str,
                       '-?\d{4}',
                       1,
                       1,
                       1);
      l_yr := SUBSTR (l_str, 1, l_pos - 1);
      l_str := SUBSTR (l_str, l_pos + 1);
      l_mon := SUBSTR (l_str, 1, 2);
      l_str := SUBSTR (l_str, 4);
      l_day := SUBSTR (l_str, 1, 2);
      l_str := SUBSTR (l_str, 4);
      l_hr := SUBSTR (l_str, 1, 2);
      l_str := SUBSTR (l_str, 4);
      l_min := SUBSTR (l_str, 1, 2);
      l_str := SUBSTR (l_str, 3);

      IF SUBSTR (l_str, 1, 1) = ':'
      THEN
         l_pos :=
            REGEXP_INSTR (l_str,
                          ':\d{2}([.]\d+)?',
                          1,
                          1,
                          1);
         l_sec := SUBSTR (l_str, 2, l_pos - 2);
         l_str := SUBSTR (l_str, l_pos);
      END IF;

      IF LENGTH (l_str) > 0
      THEN
         l_tz := l_str;
      END IF;

      IF l_hr = '24'
      THEN
         l_add_day := TRUE;
         l_hr := '00';
      END IF;

      l_time :=
            l_yr
         || '-'
         || l_mon
         || '-'
         || l_day
         || 'T'
         || l_hr
         || ':'
         || l_min
         || ':'
         || l_sec;

      ----------------------------------------------------------------------
      -- use select to avoid namespace collision with CWMS_UTIL functions --
      ----------------------------------------------------------------------
      SELECT TO_TIMESTAMP (l_time, 'YYYY-MM-DD"T"HH24:MI:SS.FF')
        INTO l_ts
        FROM DUAL;

      IF l_add_day
      THEN
         l_ts := l_ts + INTERVAL '1 00:00:00' DAY TO SECOND;
      END IF;

      --------------------------------------------------------------
      -- for some reason the TZH:TZM format only works on TO_CHAR --
      --------------------------------------------------------------
      l_tz := REPLACE (l_tz, 'Z', '+00:00');
      l_parts := split_text (SUBSTR (l_tz, 2), ':');
      l_hr := l_parts (1);
      l_min := l_parts (2);
      l_offset := TO_DSINTERVAL ('0 ' || l_hr || ':' || l_min || ':00');

      IF SUBSTR (l_tz, 1, 1) = '-'
      THEN
         l_ts := l_ts + l_offset;
      ELSE
         l_ts := l_ts - l_offset;
      END IF;

      RETURN l_ts;
   END TO_TIMESTAMP;

   --------------------------------------------------------------------
   -- Return UTC timestamp for specified Java milliseconds
   --
   FUNCTION TO_TIMESTAMP (p_millis IN NUMBER)
      RETURN TIMESTAMP
   IS
      l_millis     NUMBER := ABS (p_millis);
      l_day        NUMBER;
      l_hour       NUMBER;
      l_min        NUMBER;
      l_sec        NUMBER;
      l_negative   BOOLEAN := p_millis < 0;
      l_interval   INTERVAL DAY (9) TO SECOND (9);
   BEGIN
      l_day := TRUNC (l_millis / 86400000);
      l_millis := l_millis - (l_day * 86400000);
      l_hour := TRUNC (l_millis / 3600000);
      l_millis := l_millis - (l_hour * 3600000);
      l_min := TRUNC (l_millis / 60000);
      l_millis := l_millis - (l_min * 60000);
      l_sec := TRUNC (l_millis / 1000);
      l_millis := l_millis - (l_sec * 1000);
      l_interval :=
         TO_DSINTERVAL (
               ''
            || l_day
            || ' '
            || TO_CHAR (l_hour, '00')
            || ':'
            || TO_CHAR (l_min, '00')
            || ':'
            || TO_CHAR (l_sec, '00')
            || '.'
            || TO_CHAR (l_millis, '000'));

      IF l_negative
      THEN
         RETURN epoch - l_interval;
      ELSE
         RETURN epoch + l_interval;
      END IF;
   END TO_TIMESTAMP;

   --------------------------------------------------------------------
   -- Return Java milliseconds for a specified UTC timestamp.
   --
   FUNCTION to_millis (p_timestamp IN TIMESTAMP)
      RETURN NUMBER
   IS
      l_intvl    INTERVAL DAY (9) TO SECOND (9);
      l_millis   NUMBER;
   BEGIN
      l_intvl := p_timestamp - epoch;
      l_millis :=
         TRUNC (
              EXTRACT (DAY FROM l_intvl) * 86400000
            + EXTRACT (HOUR FROM l_intvl) * 3600000
            + EXTRACT (MINUTE FROM l_intvl) * 60000
            + EXTRACT (SECOND FROM l_intvl) * 1000);
      RETURN l_millis;
   END to_millis;

   --------------------------------------------------------------------
   -- Return Java milliseconds for current time.
   --
   FUNCTION current_millis
      RETURN NUMBER
   IS
   BEGIN
      RETURN to_millis (SYSTIMESTAMP AT TIME ZONE 'UTC');
   END current_millis;

   --------------------------------------------------------------------
   -- Return Java microseconds for a specified UTC timestamp.
   --
   FUNCTION to_micros (p_timestamp IN TIMESTAMP)
      RETURN NUMBER
   IS
      l_intvl    INTERVAL DAY (9) TO SECOND (9);
      l_micros   NUMBER;
   BEGIN
      l_intvl := p_timestamp - epoch;
      l_micros :=
         TRUNC (
              EXTRACT (DAY FROM l_intvl) * 86400000000
            + EXTRACT (HOUR FROM l_intvl) * 3600000000
            + EXTRACT (MINUTE FROM l_intvl) * 60000000
            + EXTRACT (SECOND FROM l_intvl) * 1000000);
      RETURN l_micros;
   END to_micros;

   --------------------------------------------------------------------
   -- Return Java microseconds for current time.
   --
   FUNCTION current_micros
      RETURN NUMBER
   IS
   BEGIN
      RETURN to_micros (SYSTIMESTAMP AT TIME ZONE 'UTC');
   END current_micros;


   FUNCTION get_ts_interval (p_cwms_ts_code IN NUMBER)
      RETURN NUMBER
      RESULT_CACHE
   IS
      l_ts_interval   NUMBER;
   BEGIN
      SELECT a.interval
        INTO l_ts_interval
        FROM cwms_interval a, at_cwms_ts_spec b
       WHERE b.interval_code = a.interval_code AND b.ts_code = p_cwms_ts_code;

      RETURN l_ts_interval;
   END get_ts_interval;

   FUNCTION get_unit_id (p_unit_or_alias   IN VARCHAR2,
                         p_office_id       IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS              
      l_unit_id_in    VARCHAR2 (16) := parse_unit(p_unit_or_alias);
      l_unit_id_out   VARCHAR2 (16);
      l_office_code   NUMBER (10) := get_db_office_code (p_office_id);
   BEGIN
      BEGIN
         SELECT unit_id
           INTO l_unit_id_out
           FROM cwms_unit
          WHERE unit_id = l_unit_id_in;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
      END;

      IF l_unit_id_out IS NULL
      THEN
         BEGIN
            SELECT u.unit_id
              INTO l_unit_id_out
              FROM at_unit_alias ua, cwms_unit u
             WHERE ua.alias_id = l_unit_id_in
                   AND ua.db_office_code IN
                          (db_office_code_all, l_office_code)
                   AND u.unit_code = ua.unit_code;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
         END;
      END IF;

      IF l_unit_id_out IS NULL
      THEN
         BEGIN
            SELECT unit_id
              INTO l_unit_id_out
              FROM cwms_unit
             WHERE UPPER (unit_id) = (l_unit_id_in);
         EXCEPTION
            WHEN OTHERS
            THEN
               NULL;
         END;
      END IF;

      IF l_unit_id_out IS NULL
      THEN
         BEGIN
            SELECT u.unit_id
              INTO l_unit_id_out
              FROM at_unit_alias ua, cwms_unit u
             WHERE UPPER (ua.alias_id) = UPPER (l_unit_id_in)
                   AND ua.db_office_code IN
                          (db_office_code_all, l_office_code)
                   AND u.unit_code = ua.unit_code;
         EXCEPTION
            WHEN OTHERS
            THEN
               NULL;
         END;
      END IF;

      RETURN l_unit_id_out;
   END get_unit_id;

   FUNCTION get_unit_id2 (p_unit_code IN VARCHAR2)
      RETURN VARCHAR2
      RESULT_CACHE
   IS
      l_unit_id   VARCHAR2 (16);
   BEGIN
      SELECT unit_id
        INTO l_unit_id
        FROM cwms_unit
       WHERE unit_code = p_unit_code;

      RETURN l_unit_id;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise ('INVALID_ITEM', p_unit_code, 'CWMS unit');
   END get_unit_id2;

   PROCEDURE get_valid_units (p_valid_units       OUT SYS_REFCURSOR,
                              p_parameter_id   IN     VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      IF p_parameter_id IS NULL
      THEN
         OPEN p_valid_units FOR
            SELECT a.unit_id
              FROM cwms_unit a;
      ELSE
         OPEN p_valid_units FOR
            SELECT a.unit_id
              FROM cwms_unit a
             WHERE abstract_param_code =
                      (SELECT abstract_param_code
                         FROM cwms_base_parameter
                        WHERE UPPER (base_parameter_id) =
                                 UPPER (get_base_id (p_parameter_id)));
      END IF;
   END get_valid_units;

   /* get_valid_unit_id return the properly cased unit_id for p_unit_id.
    */


   FUNCTION get_valid_unit_id (p_unit_id        IN VARCHAR2,
                               p_parameter_id   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_unit_id   VARCHAR2 (16);
   BEGIN
      BEGIN
         SELECT unit_id
           INTO l_unit_id
           FROM TABLE (get_valid_units_tab (p_parameter_id))
          WHERE unit_id = p_unit_id;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            BEGIN
               SELECT unit_id
                 INTO l_unit_id
                 FROM TABLE (get_valid_units_tab (p_parameter_id))
                WHERE UPPER (unit_id) = UPPER (p_unit_id);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  IF p_parameter_id IS NULL
                  THEN
                     raise_application_error (
                        -20102,
                           'The unit: '
                        || TRIM (p_unit_id)
                        || ' is not a recognized CWMS Database unit.',
                        TRUE);
                  ELSE
                     raise_application_error (
                        -20102,
                           'The unit: '
                        || TRIM (p_unit_id)
                        || ' is not a recognized CWMS Database unit for the '
                        || TRIM (p_parameter_id)
                        || ' Parameter_ID.',
                        TRUE);
                  END IF;
               WHEN TOO_MANY_ROWS
               THEN
                  raise_application_error (
                     -20102,
                        'The unit: '
                     || TRIM (p_unit_id)
                     || ' has multiple matches in the CWMS Database.'
                     || ' Please specify the Parameter_ID and/or use the'
                     || ' exact letter casing for the desired unit.',
                     TRUE);
            END;
      END;

      RETURN l_unit_id;
   END get_valid_unit_id;

   FUNCTION get_valid_units_tab (p_parameter_id IN VARCHAR2 DEFAULT NULL)
      RETURN cat_unit_tab_t
      PIPELINED
   IS
      l_query_cursor   SYS_REFCURSOR;
      l_output_row     cat_unit_rec_t;
   BEGIN
      get_valid_units (l_query_cursor, p_parameter_id);

      LOOP
         FETCH l_query_cursor INTO l_output_row;

         EXIT WHEN l_query_cursor%NOTFOUND;
         PIPE ROW (l_output_row);
      END LOOP;

      CLOSE l_query_cursor;
   END get_valid_units_tab;

   FUNCTION get_unit_code (p_unit_id             IN VARCHAR2,
                           p_abstract_param_id   IN VARCHAR2 DEFAULT NULL,
                           p_db_office_id        IN VARCHAR2 DEFAULT NULL)
      RETURN NUMBER
   IS
      l_unit_code        NUMBER;
      l_db_office_code   VARCHAR2 (16) := get_db_office_code (p_db_office_id);
   BEGIN
      IF p_abstract_param_id IS NULL
      THEN
         BEGIN
            SELECT unit_code
              INTO l_unit_code
              FROM av_unit
             WHERE unit_id = TRIM (p_unit_id)
                   AND db_office_code IN (l_db_office_code, 53);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               cwms_err.raise ('INVALID_ITEM',
                               TRIM (p_unit_id),
                               'unit id. Note units are case senstive.');
            WHEN TOO_MANY_ROWS
            THEN
               cwms_err.raise (
                  'ERROR',
                     'More than one entry was found for the unit: "'
                  || TRIM (p_unit_id)
                  || '". Try specifying the p_abstract_param for this unit.');
         END;
      ELSE
         BEGIN
            SELECT unit_code
              INTO l_unit_code
              FROM av_unit
             WHERE unit_id = TRIM (p_unit_id)
                   AND db_office_code IN (l_db_office_code, 53)
                   AND abstract_param_code =
                          (SELECT abstract_param_code
                             FROM cwms_abstract_parameter
                            WHERE abstract_param_id =
                                     UPPER (TRIM (p_abstract_param_id)));
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               cwms_err.raise ('INVALID_ITEM',
                               TRIM (p_unit_id),
                               'unit id. Note units are case senstive.');
         END;
      END IF;

      RETURN l_unit_code;
   END get_unit_code;

   FUNCTION get_ts_group_code (p_ts_category_id   IN VARCHAR2,
                               p_ts_group_id      IN VARCHAR2,
                               p_db_office_code   IN NUMBER)
      RETURN NUMBER
   IS
      l_ts_group_code   NUMBER;
   BEGIN
      IF p_db_office_code IS NULL
      THEN
         cwms_err.raise ('ERROR', 'p_db_office_code cannot be null.');
      END IF;

      --
      IF p_ts_category_id IS NOT NULL AND p_ts_group_id IS NOT NULL
      THEN
         BEGIN
            SELECT ts_group_code
              INTO l_ts_group_code
              FROM at_ts_group a, at_ts_category b
             WHERE a.ts_category_code = b.ts_category_code
                   AND UPPER (b.ts_category_id) =
                          UPPER (TRIM (p_ts_category_id))
                   AND b.db_office_code IN
                          (p_db_office_code, cwms_util.db_office_code_all)
                   AND UPPER (a.ts_group_id) = UPPER (TRIM (p_ts_group_id))
                   AND a.db_office_code IN
                          (p_db_office_code, cwms_util.db_office_code_all);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               cwms_err.raise (
                  'ERROR',
                     'Could not find '
                  || TRIM (p_ts_category_id)
                  || '-'
                  || TRIM (p_ts_group_id)
                  || ' category-group combination');
         END;
      ELSIF (p_ts_category_id IS NOT NULL AND p_ts_group_id IS NULL)
            OR (p_ts_category_id IS NULL AND p_ts_group_id IS NOT NULL)
      THEN
         cwms_err.raise (
            'ERROR',
            'The ts_category_id and ts_group_id is not a valid combination');
      END IF;

      RETURN l_ts_group_code;
   END get_ts_group_code;

   FUNCTION get_loc_group_code (p_loc_category_id   IN VARCHAR2,
                                p_loc_group_id      IN VARCHAR2,
                                p_db_office_code    IN NUMBER)
      RETURN NUMBER
   IS
      l_loc_group_code   NUMBER;
   BEGIN
      IF p_db_office_code IS NULL
      THEN
         cwms_err.raise ('ERROR', 'p_db_office_code cannot be null.');
      END IF;

      --
      IF p_loc_category_id IS NOT NULL AND p_loc_group_id IS NOT NULL
      THEN
         BEGIN
            SELECT loc_group_code
              INTO l_loc_group_code
              FROM at_loc_group a, at_loc_category b
             WHERE a.loc_category_code = b.loc_category_code
                   AND UPPER (b.loc_category_id) =
                          UPPER (TRIM (p_loc_category_id))
                   AND b.db_office_code IN
                          (p_db_office_code, cwms_util.db_office_code_all)
                   AND UPPER (a.loc_group_id) = UPPER (TRIM (p_loc_group_id))
                   AND a.db_office_code IN
                          (p_db_office_code, cwms_util.db_office_code_all);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               cwms_err.raise (
                  'ERROR',
                     'Could not find '
                  || TRIM (p_loc_category_id)
                  || '-'
                  || TRIM (p_loc_group_id)
                  || ' category-group combination');
         END;
      ELSIF (p_loc_category_id IS NOT NULL AND p_loc_group_id IS NULL)
            OR (p_loc_category_id IS NULL AND p_loc_group_id IS NOT NULL)
      THEN
         cwms_err.raise (
            'ERROR',
            'The loc_category_id and loc_group_id is not a valid combination');
      END IF;

      RETURN l_loc_group_code;
   END get_loc_group_code;

   FUNCTION get_loc_group_code (p_loc_category_id   IN VARCHAR2,
                                p_loc_group_id      IN VARCHAR2,
                                p_db_office_id      IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
      RETURN get_loc_group_code (
                p_loc_category_id   => p_loc_category_id,
                p_loc_group_id      => p_loc_group_id,
                p_db_office_code    => cwms_util.get_db_office_code (
                                         p_db_office_id));
   END get_loc_group_code;

   --------------------------------------------------------------------------------
   -- get_user_id uses either sys_context or the apex authenticated user id. -
   --
   -- The "v" function is installed with apex - so apex needs to be installed     -
   -- for this package to compile.
   --------------------------------------------------------------------------------
   FUNCTION get_user_id
      RETURN VARCHAR2
   IS
      l_user_id   VARCHAR2 (31);
   BEGIN
      IF v ('APP_USER') != 'APEX_PUBLIC_USER' AND v ('APP_USER') IS NOT NULL
      THEN
         l_user_id := v ('APP_USER');
      ELSE
         l_user_id := SYS_CONTEXT ('userenv', 'session_user');
      END IF;

      RETURN UPPER (l_user_id);
   END get_user_id;

   PROCEDURE user_display_unit (
      p_unit_id           OUT VARCHAR2,
      p_value_out         OUT NUMBER,
      p_parameter_id   IN     VARCHAR2,
      p_value_in       IN     NUMBER DEFAULT NULL,
      p_user_id        IN     VARCHAR2 DEFAULT NULL,
      p_office_id      IN     VARCHAR2 DEFAULT NULL)
   IS
      l_unit_system           VARCHAR2 (2);
      l_user_id               VARCHAR2 (31) := UPPER (NVL (p_user_id, get_user_id));
      l_office_id             VARCHAR2 (16) := get_db_office_id (p_office_id);
      l_base_parameter_id     VARCHAR2 (16) := get_base_id (p_parameter_id);
      l_office_code           NUMBER := get_db_office_code (p_office_id);
      l_unit_code             NUMBER;
      l_base_parameter_code   NUMBER;
   BEGIN
      p_unit_id := NULL;
      p_value_out := NULL;
      --
      -- get preferred unit system or default to 'SI'
      --
      l_unit_system :=
         cwms_properties.get_property ('Pref_User.' || l_user_id,
                                       'Unit_System',
                                       cwms_properties.get_property (
                                          'Pref_Office',
                                          'Unit_System',
                                          'SI',
                                          l_office_id),
                                       l_office_id);

      --
      -- get display unit for parameter in preferred unit system
      --
      BEGIN
         SELECT base_parameter_code,
                CASE l_unit_system
                   WHEN 'SI' THEN display_unit_code_si
                   WHEN 'EN' THEN display_unit_code_en
                END
           INTO l_base_parameter_code, l_unit_code
           FROM cwms_base_parameter
          WHERE UPPER (base_parameter_id) = UPPER (l_base_parameter_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise ('INVALID_PARAM_ID', p_parameter_id);
      END;

      SELECT unit_id
        INTO p_unit_id
        FROM cwms_unit
       WHERE unit_code = l_unit_code;

      --
      -- convert the specified value from storage unit
      --
      IF p_value_in IS NOT NULL
      THEN
         SELECT p_value_in * cuc.factor + cuc.offset
           INTO p_value_out
           FROM cwms_unit_conversion cuc, cwms_base_parameter bp
          WHERE     bp.base_parameter_code = l_base_parameter_code
                AND cuc.from_unit_code = bp.unit_code
                AND cuc.to_unit_code = l_unit_code;
      END IF;
   END user_display_unit;

   FUNCTION get_interval_string (p_interval IN NUMBER)
      RETURN VARCHAR2
   IS
      --   public static final String YEAR_TIME_INTERVAL  = "yr";
      --   public static final String MONTH_TIME_INTERVAL = "mo";
      --   public static final String WEEK_TIME_INTERVAL  = "wk";
      --   public static final String DAY_TIME_INTERVAL = "dy";
      --   public static final String HOUR_TIME_INTERVAL  = "hr";
      --   public static final String MINUTE_TIME_INTERVAL = "mi";
      l_num_yr    NUMBER;
      l_num_mo    NUMBER;
      l_num_dy    NUMBER;
      l_num_hr    NUMBER;
      l_num_mi    NUMBER;
      l_min_rem   NUMBER;
      l_lvl       VARCHAR2 (2) := NULL;
      l_return    VARCHAR2 (64) := NULL;
   BEGIN
      --
      l_num_yr := TRUNC (p_interval / CWMS_TS.MIN_IN_YR);
      l_min_rem := l_num_yr * CWMS_TS.MIN_IN_YR;

      IF l_num_yr > 0
      THEN
         l_return := l_num_yr || 'yr';
         l_lvl := 'YR';
      END IF;

      --
      l_num_mo := TRUNC ( (p_interval - l_min_rem) / CWMS_TS.MIN_IN_MO);
      l_min_rem := l_min_rem + l_num_mo * CWMS_TS.MIN_IN_MO;

      CASE
         WHEN l_lvl IS NULL
         THEN
            IF l_num_mo > 0
            THEN
               l_return := l_num_mo || 'mo';
               l_lvl := 'MO';
            END IF;
         ELSE
            l_return := l_return || l_num_mo || 'mo';
      END CASE;

      --
      --      l_num_wk := TRUNC ( (p_interval - l_min_rem) / CWMS_TS.MIN_IN_WK);
      --      l_min_rem := l_min_rem + l_num_wk * CWMS_TS.MIN_IN_WK;
      --
      --      CASE
      --         WHEN l_lvl IS NULL
      --         THEN
      --            IF l_num_wk > 0
      --            THEN
      --               l_return := l_num_wk || 'wk';
      --               l_lvl := 'WK';
      --            END IF;
      --         ELSE
      --            l_return := l_return || l_num_wk || 'wk';
      --      END CASE;

      --
      l_num_dy := TRUNC ( (p_interval - l_min_rem) / CWMS_TS.MIN_IN_DY);
      l_min_rem := l_min_rem + l_num_dy * CWMS_TS.MIN_IN_DY;

      CASE
         WHEN l_lvl IS NULL
         THEN
            IF l_num_dy > 0
            THEN
               l_return := l_num_dy || 'dy';
               l_lvl := 'DY';
            END IF;
         ELSE
            l_return := l_return || l_num_dy || 'dy';
      END CASE;

      --
      l_num_hr := TRUNC ( (p_interval - l_min_rem) / CWMS_TS.MIN_IN_HR);
      l_min_rem := l_min_rem + l_num_hr * CWMS_TS.MIN_IN_HR;

      CASE
         WHEN l_lvl IS NULL
         THEN
            IF l_num_hr > 0
            THEN
               l_return := l_num_hr || 'hr';
               l_lvl := 'HR';
            END IF;
         ELSE
            l_return := l_return || l_num_hr || 'hr';
      END CASE;

      --
      l_num_mi := p_interval - l_min_rem;
      l_return := l_return || l_num_mi || 'mi';
      --



      RETURN l_return;
   END get_interval_string;

   FUNCTION get_user_display_unit (p_parameter_id   IN VARCHAR2,
                                   p_user_id        IN VARCHAR2 DEFAULT NULL,
                                   p_office_id      IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_unit_id     VARCHAR2 (16);
      l_value_out   NUMBER;
   BEGIN
      user_display_unit (l_unit_id,
                         l_value_out,
                         p_parameter_id,
                         1.0,
                         p_user_id,
                         p_office_id);

      RETURN l_unit_id;
   END get_user_display_unit;

   ----------------------------------------------------------------------------

   FUNCTION get_default_units (p_parameter_id   IN VARCHAR2,
                               p_unit_system    IN VARCHAR2 DEFAULT 'SI')
      RETURN VARCHAR2
   AS
      l_default_units     VARCHAR2 (16);
      l_base_param_code   NUMBER;
   BEGIN
      IF p_parameter_id IS NULL
      THEN
         RETURN NULL;
      END IF;

      l_base_param_code := get_base_param_code (get_base_id (p_parameter_id));

      IF UPPER (p_unit_system) = 'SI'
      THEN
         SELECT a.unit_id
           INTO l_default_units
           FROM cwms_unit a, cwms_base_parameter b
          WHERE a.unit_code = b.display_unit_code_si
                AND b.base_parameter_code = l_base_param_code;
      ELSIF UPPER (p_unit_system) = 'EN'
      THEN
         SELECT a.unit_id
           INTO l_default_units
           FROM cwms_unit a, cwms_base_parameter b
          WHERE a.unit_code = b.display_unit_code_en
                AND b.base_parameter_code = l_base_param_code;
      ELSE
         cwms_err.raise ('INVALID_ITEM',
                         p_unit_system,
                         'Unit System. Use either SI or EN');
      END IF;

      RETURN l_default_units;
   END get_default_units;

   FUNCTION get_db_unit_code (p_parameter_id IN VARCHAR2)
      RETURN NUMBER
   IS
      l_unit_code   NUMBER (10);
   BEGIN
      SELECT unit_code
        INTO l_unit_code
        FROM cwms_base_parameter
       WHERE base_parameter_id = get_base_id (p_parameter_id);

      RETURN l_unit_code;
   END get_db_unit_code;

   FUNCTION get_db_unit_code (p_parameter_code IN NUMBER)
      RETURN NUMBER
   IS
      l_unit_code   NUMBER (10);
   BEGIN
      SELECT bp.unit_code
        INTO l_unit_code
        FROM cwms_base_parameter bp, at_parameter p
       WHERE p.parameter_code = p_parameter_code
             AND bp.base_parameter_code = p.base_parameter_code;

      RETURN l_unit_code;
   END get_db_unit_code;

   FUNCTION convert_to_db_units (p_value          IN BINARY_DOUBLE,
                                 p_parameter_id   IN VARCHAR2,
                                 p_unit_id        IN VARCHAR2)
      RETURN BINARY_DOUBLE
   IS
      l_factor   BINARY_DOUBLE;
      l_offset   BINARY_DOUBLE;
   BEGIN
      SELECT uc.factor, uc.offset
        INTO l_factor, l_offset
        FROM cwms_unit_conversion uc, cwms_base_parameter bp
       WHERE     bp.base_parameter_id = get_base_id (p_parameter_id)
             AND uc.to_unit_code = bp.unit_code
             AND uc.from_unit_id = p_unit_id;

      RETURN p_value * l_factor + l_offset;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot convert parameter '
            || p_parameter_id
            || ' in unit '
            || p_unit_id
            || ' to database unit.');
   END convert_to_db_units;

   FUNCTION get_factor_and_offset (p_from_unit_id   IN VARCHAR2,
                                   p_to_unit_id     IN VARCHAR2)
      RETURN double_tab_t
      RESULT_CACHE
   IS
      l_factor_and_offset   double_tab_t := double_tab_t ();
   BEGIN
      l_factor_and_offset.EXTEND (2);

      SELECT factor, offset
        INTO l_factor_and_offset (1), l_factor_and_offset (2)
        FROM cwms_unit_conversion
       WHERE from_unit_id = get_unit_id (p_from_unit_id)
             AND to_unit_id = get_unit_id (p_to_unit_id);

      RETURN l_factor_and_offset;
   END get_factor_and_offset;

   FUNCTION convert_units (p_value          IN BINARY_DOUBLE,
                           p_from_unit_id   IN VARCHAR2,
                           p_to_unit_id     IN VARCHAR2)
      RETURN BINARY_DOUBLE
      RESULT_CACHE
   IS
      l_factor_and_offset   double_tab_t;
      l_converted           binary_double;
   BEGIN
      if p_value is not null then
         l_factor_and_offset :=
            get_factor_and_offset (p_from_unit_id, p_to_unit_id);
         l_converted :=  p_value * l_factor_and_offset (1) + l_factor_and_offset (2);
      end if;
      RETURN l_converted;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot convert from unit '
            || p_from_unit_id
            || ' to unit '
            || p_to_unit_id);
   END convert_units;

   FUNCTION convert_units (p_value            IN BINARY_DOUBLE,
                           p_from_unit_code   IN NUMBER,
                           p_to_unit_code     IN NUMBER)
      RETURN BINARY_DOUBLE
      RESULT_CACHE
   IS
      l_factor   BINARY_DOUBLE;
      l_offset   BINARY_DOUBLE;
   BEGIN
      SELECT factor, offset
        INTO l_factor, l_offset
        FROM cwms_unit_conversion
       WHERE from_unit_code = p_from_unit_code
             AND to_unit_code = p_to_unit_code;

      RETURN p_value * l_factor + l_offset;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot convert from unit '
            || get_unit_id2 (p_from_unit_code)
            || ' to unit '
            || get_unit_id2 (p_to_unit_code));
   END convert_units;

   FUNCTION convert_units (p_value            IN BINARY_DOUBLE,
                           p_from_unit_code   IN NUMBER,
                           p_to_unit_id       IN VARCHAR2)
      RETURN BINARY_DOUBLE
      RESULT_CACHE
   IS
      l_factor   BINARY_DOUBLE;
      l_offset   BINARY_DOUBLE;
   BEGIN
      SELECT factor, offset
        INTO l_factor, l_offset
        FROM cwms_unit_conversion
       WHERE from_unit_code = p_from_unit_code
             AND to_unit_id = get_unit_id (p_to_unit_id);

      RETURN p_value * l_factor + l_offset;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot convert from unit '
            || get_unit_id2 (p_from_unit_code)
            || ' to unit '
            || p_to_unit_id);
   END convert_units;

   FUNCTION convert_units (p_value          IN BINARY_DOUBLE,
                           p_from_unit_id   IN VARCHAR2,
                           p_to_unit_code   IN NUMBER)
      RETURN BINARY_DOUBLE
      RESULT_CACHE
   IS
      l_factor   BINARY_DOUBLE;
      l_offset   BINARY_DOUBLE;
   BEGIN
      SELECT factor, offset
        INTO l_factor, l_offset
        FROM cwms_unit_conversion
       WHERE from_unit_id = get_unit_id (p_from_unit_id)
             AND to_unit_code = p_to_unit_code;

      RETURN p_value * l_factor + l_offset;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot convert from unit '
            || p_from_unit_id
            || ' to unit '
            || get_unit_id2 (p_to_unit_code));
   END convert_units;

   --
   -- sign-extends 32-bit integers so they can be retrieved by
   -- java int type
   --

   FUNCTION sign_extend (p_int IN INTEGER)
      RETURN INTEGER
   IS
   BEGIN
      DBMS_OUTPUT.put_line (
         'Warning: Use of CWMS_UTIL.SIGN_EXTEND is deprecated');
      RETURN p_int;
   END sign_extend;

   -----------------------------------
   -- function months_to_yminterval --
   -----------------------------------

   FUNCTION months_to_yminterval (p_months IN INTEGER)
      RETURN INTERVAL YEAR TO MONTH
   IS
   BEGIN
      IF p_months IS NULL
      THEN
         RETURN NULL;
      END IF;

      RETURN TO_YMINTERVAL (
                   TO_CHAR (TRUNC (p_months / 12))
                || '-'
                || TO_CHAR (MOD (p_months, 12)));
   END months_to_yminterval;

   ------------------------------------
   -- function minutes_to_dsinterval --
   ------------------------------------

   FUNCTION minutes_to_dsinterval (p_minutes IN INTEGER)
      RETURN INTERVAL DAY TO SECOND
   IS
   BEGIN
      IF p_minutes IS NULL
      THEN
         RETURN NULL;
      END IF;

      RETURN TO_DSINTERVAL (
                   TO_CHAR (TRUNC (p_minutes / 1440))
                || ' '
                || TO_CHAR (TRUNC (MOD (p_minutes, 1440) / 60))
                || ':'
                || TO_CHAR (MOD (p_minutes, 60) || ': 00'));
   END minutes_to_dsinterval;

   -----------------------------------
   -- function yminterval_to_months --
   -----------------------------------

   FUNCTION yminterval_to_months (p_intvl IN yminterval_unconstrained)
      RETURN INTEGER
   IS
   BEGIN
      IF p_intvl IS NULL
      THEN
         RETURN NULL;
      END IF;

      RETURN 12 * EXTRACT (YEAR FROM p_intvl) + EXTRACT (MONTH FROM p_intvl);
   END yminterval_to_months;

   ------------------------------------
   -- function dsinterval_to_minutes --
   ------------------------------------

   FUNCTION dsinterval_to_minutes (p_intvl IN dsinterval_unconstrained)
      RETURN INTEGER
   IS
   BEGIN
      IF p_intvl IS NULL
      THEN
         RETURN NULL;
      END IF;

      RETURN   1440 * EXTRACT (DAY FROM p_intvl)
             + 60 * EXTRACT (HOUR FROM p_intvl)
             + EXTRACT (MINUTE FROM p_intvl);
   END dsinterval_to_minutes;

   ----------------------------------
   -- function minutes_to_duration --
   ----------------------------------

   function minutes_to_duration (
      p_minutes in integer)
      return varchar2
   is
      l_duration varchar2(16);
      l_dsintvl  dsinterval_unconstrained;
      l_days     integer;
      l_hours    integer;
      l_minutes  integer;
   begin
      if p_minutes is not null then
         l_duration := 'P';
         l_dsintvl  := minutes_to_dsinterval(p_minutes);
         l_days     := extract(day from l_dsintvl);
         l_hours    := extract(hour from l_dsintvl);
         l_minutes  := extract(minute from l_dsintvl);
         if l_days > 0 then
            l_duration := l_duration || l_days || 'D';
         end if;
         if l_hours + l_minutes > 0 then
            l_duration := l_duration || 'T';
         end if;
         if l_hours > 0 then
            l_duration := l_duration || l_hours || 'H';
         end if;
         if l_minutes > 0 or l_days + l_hours = 0 then
            l_duration := l_duration || l_minutes || 'M';
         end if;
      end if;                      
      return l_duration;
   end minutes_to_duration;

   ----------------------------------
   -- function duration_to_minutes --
   ----------------------------------

   function duration_to_minutes(
      p_duration in varchar2)
      return integer
   is
      --                                     1      2      3      4 5      6      7   8
      l_pattern constant varchar2(128) := '^P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+([.]\d+)?S)?)?$';
      l_duration varchar2(64) := trim(p_duration);
      l_text    varchar2(8);        
      l_minutes integer;
   begin                                                                                     
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 0) is null then
         cwms_err.raise('INVALID_ITEM', l_duration, 'ISO 8601 duration');
      end if;                                             
      for i in 1..2 loop
         if regexp_substr(l_duration, l_pattern, 1, 1, 'i', i) is not null then
            l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', i);
            if to_number(substr(l_text, 1, length(l_text)-1)) > 0 then
               cwms_err.raise('ERROR', 'Cannont compute minutes. Duration "'||l_duration||'" contains years and/or months');
            end if;
         end if;
      end loop;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 7) is not null then
            l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 7);
            if to_number(substr(l_text, 1, length(l_text)-1)) > 0 then
               cwms_err.raise('ERROR', 'Cannont compute minutes. Duration "'||l_duration||'" contains seconds');
            end if;
      end if;
      l_minutes := 0;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 3) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 3);
         l_minutes := l_minutes + 1440 * to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 5) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 5);
         l_minutes := l_minutes + 60 * to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 6) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 6);
         l_minutes := l_minutes + to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      return l_minutes;
   end duration_to_minutes;      

   ------------------------------------
   -- procedure duration_to_interval --
   ------------------------------------

   procedure duration_to_interval(
      p_ym_interval out yminterval_unconstrained,
      p_ds_interval out dsinterval_unconstrained,
      p_duration    in  varchar2)
   is
      --                                     1      2      3      4 5      6      7   8
      l_pattern constant varchar2(128) := '^P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+([.]\d+)?S)?)?$';
      l_duration varchar2(64) := trim(p_duration);
      l_text     varchar2(8);        
      l_years    pls_integer := 0;
      l_months   pls_integer := 0;
      l_days     pls_integer := 0;
      l_hours    pls_integer := 0;
      l_minutes  pls_integer := 0;
      l_seconds  number := 0;
   begin
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 0) is null then
         cwms_err.raise('INVALID_ITEM', l_duration, 'ISO 8601 duration');
      end if;                                             
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 1) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 1);
         l_years := to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 2) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 2);
         l_months := to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 3) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 3);
         l_days := to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 5) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 5);
         l_hours := to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 6) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 6);
         l_minutes := to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      if regexp_substr(l_duration, l_pattern, 1, 1, 'i', 7) is not null then
         l_text := regexp_substr(l_duration, l_pattern, 1, 1, 'i', 7);
         l_seconds := to_number(substr(l_text, 1, length(l_text)-1));
      end if;
      p_ym_interval := to_yminterval(l_years||'-'||l_months);
      p_ds_interval := to_dsinterval(l_days||' '||l_hours||':'||l_minutes||':'||l_seconds);
   end duration_to_interval;            

   -----------------------------------
   -- function parse_odbc_ts_string --
   -----------------------------------

   FUNCTION parse_odbc_ts_string (p_odbc_str IN VARCHAR2)
      RETURN DATE
   IS
   BEGIN
      IF p_odbc_str IS NULL
      THEN
         RETURN NULL;
      END IF;

      RETURN TO_DATE (p_odbc_str, odbc_ts_fmt);
   EXCEPTION
      WHEN OTHERS
      THEN
         cwms_err.raise ('INVALID_ITEM',
                         p_odbc_str,
                         'ODBC timestamp format (' || odbc_ts_fmt || ')');
   END parse_odbc_ts_string;

   ----------------------------------
   -- function parse_odbc_d_string --
   ----------------------------------

   FUNCTION parse_odbc_d_string (p_odbc_str IN VARCHAR2)
      RETURN DATE
   IS
   BEGIN
      IF p_odbc_str IS NULL
      THEN
         RETURN NULL;
      END IF;

      RETURN TO_DATE (p_odbc_str, odbc_d_fmt);
   EXCEPTION
      WHEN OTHERS
      THEN
         cwms_err.raise ('INVALID_ITEM',
                         p_odbc_str,
                         'ODBC date format (' || odbc_d_fmt || ')');
   END parse_odbc_d_string;

   ----------------------------------------
   -- function parse_odbc_ts_or_d_string --
   ----------------------------------------

   FUNCTION parse_odbc_ts_or_d_string (p_odbc_str IN VARCHAR2)
      RETURN DATE
   IS
      l_date   DATE;
   BEGIN
      IF p_odbc_str IS NULL
      THEN
         RETURN NULL;
      END IF;

      l_date := parse_odbc_ts_string (p_odbc_str);
      RETURN l_date;
   EXCEPTION
      WHEN OTHERS
      THEN
         BEGIN
            l_date := parse_odbc_d_string (p_odbc_str);
            RETURN l_date;
         EXCEPTION
            WHEN OTHERS
            THEN
               cwms_err.raise (
                  'INVALID_ITEM',
                  p_odbc_str,
                     'ODBC timestamp or date format ('
                  || odbc_ts_fmt
                  || ', '
                  || ')');
         END;
   END parse_odbc_ts_or_d_string;

   function is_expression_constant(
      p_token in varchar2)
      return boolean
   is
      l_count   integer;
   begin
      select count(*)
        into l_count
        from table(expression_constants)
       where column_value = p_token;

      return l_count > 0;
   end is_expression_constant;

   function is_expression_operator(
      p_token in varchar2)
      return boolean
   is
      l_count   integer;
   begin
      select count(*)
        into l_count
        from table(expression_operators)
       where column_value = p_token;

      return l_count > 0;
   end is_expression_operator;

   function is_expression_function(
      p_token in varchar2)
      return boolean
   is
      l_count   integer;
   begin
      select count(*)
        into l_count
        from table(expression_functions)
       where column_value = p_token;

      return l_count > 0;
   end is_expression_function;

   function is_comparison_operator(
      p_token in varchar2)
      return boolean
   is
      l_count   integer;
   begin
      select count(*)
        into l_count
        from table(comparitors)
       where column_value = p_token;

      return l_count > 0;
   end is_comparison_operator;

   function is_combination_operator(
      p_token in varchar2)
      return boolean
   is
      l_count   integer;
   begin
      select count(*)
        into l_count
        from table(combinators)
       where column_value = p_token;

      return l_count > 0;
   end is_combination_operator;

   function is_logic_operator(
      p_token in varchar2)
      return boolean
   is        
   begin
      return is_comparison_operator(p_token) or is_combination_operator(p_token);
   end is_logic_operator;
   
   function tokenize_comparison_expression(
      p_comparison_expression in varchar2)
      return str_tab_tab_t
   is
      c_re          constant varchar2(49) := '\W?('||join_text(comparitors, '|')||')\W?';
      l_tokenized   str_tab_tab_t;
      l_parts       str_tab_t;
      l_expressions str_tab_t;
      l_op          varchar2(3);
      procedure invalid is 
      begin 
         cwms_err.raise('ERROR', 'Invalid comparison expression: '||p_comparison_expression);
      end;
   begin        
      l_parts := split_text(upper(trim(p_comparison_expression)));
      if is_comparison_operator(l_parts(l_parts.count)) then
         l_op := l_parts(l_parts.count); 
         l_parts := tokenize_expression2(join_text(sub_table(l_parts, 1, l_parts.count-1), ' '), 'T');
         l_tokenized := str_tab_tab_t();
         l_tokenized.extend(l_parts.count+1);
         for i in 1..l_parts.count loop
            l_tokenized(i) := split_text(l_parts(i));
         end loop;
         l_tokenized(l_tokenized.count) := str_tab_t(l_op); 
      else
         select trim(column_value) 
           bulk collect 
           into l_parts 
          from table(cwms_util.split_text_regexp(p_comparison_expression, c_re, 'T', 'i')); 
         case l_parts.count
         when 2 then
            if is_comparison_operator(l_parts(2)) then
               l_expressions := tokenize_expression2(l_parts(1));
               if l_expressions.count = 2 then
                  l_tokenized := str_tab_tab_t();
                  l_tokenized.extend(3);
                  l_tokenized(1) := tokenize_rpn(l_expressions(1));
                  l_tokenized(2) := tokenize_rpn(l_expressions(2));
                  l_tokenized(3) := str_tab_t(l_parts(2));
               else
                  invalid;
               end if;
            else
               invalid;
            end if;
         when 3 then
            if is_comparison_operator(l_parts(2)) then
               l_tokenized := str_tab_tab_t();
               l_tokenized.extend(3);
                  l_tokenized(1) := tokenize_expression(l_parts(1));
                  l_tokenized(2) := tokenize_expression(l_parts(3));
                  l_tokenized(3) := str_tab_t(l_parts(2));
            else
               invalid;
            end if;
         else 
            invalid;
         end case;
      end if;
      return l_tokenized;
   end tokenize_comparison_expression;
   
   -----------------------------------------------------------------------------
   -- FUNCTION tokenize_logic_expression
   -----------------------------------------------------------------------------
   function tokenize_logic_expression(
      p_expr in varchar2)                                                                                                                 
      return str_tab_tab_t
   is              
      c_re           constant varchar2(22) := '\W?('||cwms_util.join_text(cwms_util.combinators, '|')||')\W?';
      l_expr         varchar2(32767);
      l_temp         varchar2(32676);
      l_results      str_tab_tab_t;
      l_len          pls_integer;
      l_parts        str_tab_t;
      l_replacements str_tab_t;
      l_table1       str_tab_t;
      l_table2       str_tab_tab_t;
      l_start        pls_integer;
      l_end          pls_integer;  
      
      function sub_expr(p_table in str_tab_t, p_first in pls_integer, p_last in pls_integer default null) return varchar2
      is
         l_table str_tab_t;
         l_expr  varchar2(32767);
         l_end   pls_integer := nvl(p_last, p_table.count);
         l_extra pls_integer;
      begin
         select trim(column_value)
           bulk collect
           into l_table 
           from table(sub_table(p_table, p_first, p_last));    
         l_expr := join_text(l_table, ' ');                           
         return l_expr;                           
      end sub_expr; 
                     
      function drop_elements(p_indices in number_tab_t, p_table in str_tab_t) return str_tab_t
      is
         l_table str_tab_t;
      begin
         select column_value
           bulk collect
           into l_table
           from (select column_value,
                        rownum as seq
                   from table(p_table)
                )
          where seq not in (select * from table(p_indices))
          order by seq;
          
         return l_table;                     
      end drop_elements;
   begin
      l_expr := upper(trim(p_expr));
      l_len  := length(l_expr);
      if nvl(get_expression_depth_at(l_len+1, l_expr), 0) != 0 then
         cwms_err.raise('ERROR', 'Expression has unbalanced parentheses: '||p_expr);
      end if;
      if regexp_count(l_expr, c_re) = 0 then
         ------------------------
         -- no logic operators --
         ------------------------
         begin
            l_results := tokenize_comparison_expression(p_expr);
         exception
            when others then
               ------------------------------------
               -- no comparison operators either --
               ------------------------------------
               l_results := str_tab_tab_t(tokenize_expression(p_expr));
         end;
      else
         l_parts := split_text(l_expr);
         l_len := l_parts.count;
         if is_combination_operator(l_parts(l_len)) or 
            is_comparison_operator(l_parts(l_len)) or
            is_expression_operator(l_parts(l_len)) or
            is_expression_function(l_parts(l_len))
         then
            -------------
            -- postfix --
            ------------- 
            if instr(l_expr, '(') > 0 then
               cwms_err.raise('ERROR', 'Invalid logic expression: '||p_expr);
            end if; 
            l_results := str_tab_tab_t();
            l_temp  := null;
            for i in 1..l_len loop  
               if is_comparison_operator(l_parts(i)) then 
                  l_temp := l_temp||' '||l_parts(i);
                  l_table2 := tokenize_comparison_expression(l_temp);
                  if l_table2.count != 3 then
                     cwms_err.raise('ERROR', 'Invalid logic expression: '||l_temp);
                  end if;
                  l_results.extend(3);
                  for j in 1..3 loop
                     l_results(l_results.count-3+j) := l_table2(j);
                  end loop;
                  l_temp  := null;
               elsif is_combination_operator(l_parts(i)) then
                  l_results.extend;
                  l_results(l_results.count) := str_tab_t(l_parts(i));
               else
                  l_temp := l_temp||' '||l_parts(i);
               end if;
            end loop;
         else
            -----------
            -- infix --
            -----------
            ---------------------------- 
            -- bind parentheses first --
            ---------------------------- 
            l_replacements := replace_parentheticals(l_expr);
            l_replacements(l_replacements.count) := regexp_replace(l_replacements(l_replacements.count), '\$(\d+)', 'ARG10\1', 1, 0);
            l_expr := l_replacements(l_replacements.count);
            l_replacements.trim;
            -----------------------------------------------------------
            -- next bind operators in decreasing order of precedence --
            -----------------------------------------------------------
            l_start := l_replacements.count + 1;
            l_parts := split_text_regexp(l_expr, c_re, 'T', 'i');
            for rec in (select column_value as op from table(str_tab_t('NOT', 'AND', 'XOR', 'OR'))) loop
               for i in reverse 1..l_parts.count loop
                  if trim(l_parts(i)) = rec.op then
                     l_replacements.extend;
                     if rec.op = 'NOT' then
                        l_replacements(l_replacements.count) := join_text(sub_table(l_parts, i, i+1),' ');
                        l_parts(i) := 'ARG10'||l_replacements.count;
                        l_parts := drop_elements(number_tab_t(i+1), l_parts);
                     else
                        l_replacements(l_replacements.count) := join_text(sub_table(l_parts, i-1, i+1), ' ');
                        l_parts(i-1) := 'ARG10'||l_replacements.count;
                        l_parts := drop_elements(number_tab_t(i, i+1), l_parts);
                     end if;
                  end if;
               end loop;
            end loop;
            ------------------------------------------------------
            -- unwind operator replacements in postfix notation --
            ------------------------------------------------------
            l_expr := l_parts(1);
            for i in reverse 1..l_replacements.count loop
               l_temp := null;
               if i < l_start then
                  -------------------------------------
                  -- replace parentetical expression --
                  -------------------------------------  
                  l_table1 := split_text(l_replacements(i));
                  if is_expression_function(l_table1(1)) then
                     l_table2 := tokenize_logic_expression(sub_expr(l_table1, 2));
                     l_table2.extend;
                     l_table2(l_table2.count) := str_tab_t(l_table1(1));
                  else 
                     l_table2 := tokenize_logic_expression(l_replacements(i));
                  end if;
                  for j in 1..l_table2.count loop
                     l_temp := l_temp||join_text(l_table2(j), ' ')||' ';
                  end loop;
               else
                  ------------------------------
                  -- replace logic expression --
                  ------------------------------
                  l_parts := split_text_regexp(l_replacements(i), c_re, 'T', 'i');
                  case l_parts.count
                  when 2 then 
                     --------------------------
                     -- unary operator (NOT) --
                     --------------------------
                     begin
                        l_table2 := tokenize_comparison_expression(l_parts(2));
                        for j in 1..l_table2.count loop
                           l_temp := l_temp||join_text(l_table2(j), ' ')||' ';
                        end loop;
                        l_temp := l_temp||l_parts(1);
                     exception
                        when others then
                           l_temp := l_parts(2)||' '||l_parts(1);
                     end; 
                  when 3 then
                     --------------------- 
                     -- binary operator --
                     --------------------- 
                     begin
                        l_table2 := tokenize_comparison_expression(l_parts(1));
                        for j in 1..l_table2.count loop
                           l_temp := l_temp||join_text(l_table2(j), ' ')||' ';
                        end loop;
                     exception
                        when others then
                           l_temp := l_parts(1);
                     end; 
                     begin
                        l_table2 := tokenize_comparison_expression(l_parts(3));
                        for j in 1..l_table2.count loop
                           l_temp := l_temp||join_text(l_table2(j), ' ')||' ';
                        end loop;
                        l_temp := l_temp||l_parts(2);
                     exception
                        when others then
                           l_temp := l_temp||' '||l_parts(3)||' '||l_parts(2);
                     end; 
                  else 
                     cwms_err.raise('ERROR', 'Invalid subexpression: '||l_replacements(i));
                  end case;
               end if;
               l_expr := replace(l_expr, 'ARG10'||i, l_temp);
            end loop;
            l_results := tokenize_logic_expression(l_expr);
         end if;
      end if; 
      return l_results;
   end tokenize_logic_expression;
   
   function tokenize_algebraic(
      p_algebraic_expr in varchar2)
      return str_tab_t
      result_cache
   is
      l_infix_tokens        str_tab_t;
      l_postfix_tokens      str_tab_t := new str_tab_t();
      l_stack               str_tab_t := new str_tab_t();
      l_func_stack          str_tab_t := new str_tab_t();
      l_left_paren_count    binary_integer := 0;
      l_right_paren_count   binary_integer := 0;
      l_func                varchar2(8);
      l_dummy               varchar2(1);
      --------------------
      -- local routines --
      --------------------
      procedure error
      is
      begin
         cwms_err.raise(
            'ERROR',
            'Invalid algebraic expression: ' || p_algebraic_expr);
      end;

      procedure token_error(token in varchar2)
      is
      begin
         cwms_err.raise('ERROR', 'Invalid token in equation: ' || token);
      end;

      function precedence(op in varchar2) return number
      is
         l_precedence pls_integer;
      begin     
         if op is not null then
            l_precedence :=  case op
                             when '+'  then 1
                             when '-'  then 1
                             when '*'  then 2
                             when '/'  then 2
                             when '//' then 2
                             when '%'  then 2
                             when '^'  then 3
                             else 0
                             end;
            if l_precedence < 1 then
               cwms_err.raise('ERROR', 'Invalid arithmetic operator: '||op);
            end if;
         end if;
         return l_precedence;                          
      end;

      procedure push(p_op in varchar2)
      is
      begin
         l_stack.extend;
         l_stack(l_stack.count) := p_op;
      end;

      function pop return varchar2
      is
         l_op   varchar2(8);
      begin
         begin
            l_op := l_stack(l_stack.count);
         exception
            when others then error;
         end;
         l_stack.trim;
         return l_op;
      end;

      procedure push_func(p_func in varchar2)
      is
      begin
         l_func_stack.extend;
         l_func_stack(l_func_stack.count) := p_func;
      end;

      function pop_func return varchar2
      is
         l_func   varchar2(8);
      begin
         begin
            l_func := l_func_stack(l_func_stack.count);
         exception
            when others then error;
         end;
         l_func_stack.trim;
         return l_func;
      end;
   begin
      ---------------------------------
      -- parse the infix into tokens --
      ---------------------------------
      l_infix_tokens := cwms_util.split_text(trim(regexp_replace(upper(replace(p_algebraic_expr,chr(10),' ')),'([()])',' \1 ')));
      -------------------------------------
      -- process the tokens into postfix --
      -------------------------------------
      for i in 1 .. l_infix_tokens.count
      loop   
         case
         when is_expression_operator(l_infix_tokens(i)) then
            ---------------
            -- operators --
            ---------------
            if l_stack.count > 0 and precedence(l_stack(l_stack.count)) >= precedence(l_infix_tokens(i)) then
               l_postfix_tokens.extend;
               l_postfix_tokens(l_postfix_tokens.count) := pop;
            end if;

            push(l_infix_tokens(i));
         when is_expression_function(l_infix_tokens(i)) then
            ---------------
            -- functions --
            ---------------
            push_func(l_infix_tokens(i));
         when l_infix_tokens(i) = '(' then
            ----------------------
            -- open parentheses --
            ----------------------
            push(null);
            push_func(null);
            l_left_paren_count := l_left_paren_count + 1;
         when l_infix_tokens(i) = ')' then
            ------------------------
            -- close parentheses --
            ------------------------
            while l_stack(l_stack.count) is not null loop
               l_postfix_tokens.extend;
               l_postfix_tokens(l_postfix_tokens.count) := pop;
            end loop;

            l_dummy := pop;
            l_func := pop_func;

            if l_func_stack.count > 0 and l_func_stack(l_func_stack.count) is not null then
               l_func := pop_func;
               l_postfix_tokens.extend;
               l_postfix_tokens(l_postfix_tokens.count) := l_func;
            end if;

            l_right_paren_count := l_right_paren_count + 1;
         else
            ---------------------
            -- everything else --
            ---------------------
            l_postfix_tokens.extend;
            l_postfix_tokens(l_postfix_tokens.count) := l_infix_tokens(i);
         end case;
      end loop;

      if l_right_paren_count != l_left_paren_count
      then
         error;
      end if;

      while l_stack.count > 0
      loop
         l_postfix_tokens.extend;
         l_postfix_tokens(l_postfix_tokens.count) := pop;
      end loop;

      return l_postfix_tokens;
   end tokenize_algebraic;

   -----------------------------------------------------------------------------
   -- FUNCTION tokenize_rpn
   -----------------------------------------------------------------------------
   function tokenize_rpn(
      p_rpn_expr in varchar2)
      return str_tab_t
      result_cache
   is
   begin
      return split_text(trim(upper(replace(p_rpn_expr, chr(10), ' '))));
   end tokenize_rpn;

   -----------------------------------------------------------------------------
   -- FUNCTION tokenize_expression
   -----------------------------------------------------------------------------
   function tokenize_expression(
      p_expr in varchar2)
      return str_tab_t
      result_cache
   is
      l_tokens str_tab_t;
      l_count  integer := 0;
      l_number number;
   begin
      if instr(p_expr, '(') > 0 then
         -----------------------------------------------------
         -- must be algebraic, rpn doesn't have parentheses --
         -----------------------------------------------------
         l_tokens := tokenize_algebraic(p_expr);
      else            
         -------------------
         -- first try rpn --
         -------------------
         l_tokens := tokenize_rpn(p_expr);
         case l_tokens.count
         when 0 then null;
         when 1 then
            begin
               l_number := to_number(l_tokens(1));
            exception
               when others then
                  if not regexp_like(l_tokens(1), 'arg\d+', 'i') and not is_expression_constant(l_tokens(1)) then
                     cwms_err.raise('ERROR', 'Invalid expression: '||p_expr);
                  end if; 
            end;
         else
            if not is_expression_operator(l_tokens(l_tokens.count)) and 
               not is_expression_function(l_tokens(l_tokens.count)) and
               not is_comparison_operator(l_tokens(l_tokens.count)) and
               not is_combination_operator(l_tokens(l_tokens.count))
            then
               -----------------------------------------------------------------
               -- last token isn't an operator or function, must be algebraic --
               -----------------------------------------------------------------
               l_tokens := tokenize_algebraic(p_expr);
            end if;
         end case;
      end if;

      return l_tokens;
   end tokenize_expression;
   
   function tokenize_expression2(
      p_expr   in varchar2,
      p_is_rpn in varchar2 default 'F')
      return str_tab_t
      result_cache
   is    
      l_rpn_tokens str_tab_t;
      l_stack      str_tab_t := str_tab_t();
      l_val1       varchar2(32767);
      l_val2       varchar2(32767);
      l_idx        binary_integer; 
      l_number     number;
      --------------------
      -- local routines --
      --------------------
      procedure token_error(token in varchar2)
      is
      begin
         cwms_err.raise('ERROR', 'Invalid token in equation: ' || token);
      end;

      procedure argument_error(l_idx in integer)
      is
      begin
         cwms_err.raise('ERROR', 'ARG' || l_idx || ' does not exist');
      end;

      procedure push(val in varchar2)
      is
      begin
         l_stack.extend;
         l_stack(l_stack.count) := val;
      end;

      function pop return varchar2
      is
         val varchar2(32767);
      begin
         val := l_stack(l_stack.last);
         l_stack.trim;
         return val;
      end;
   begin                   
      if is_true(p_is_rpn) then
         l_rpn_tokens := split_text(p_expr);
      else
         l_rpn_tokens := tokenize_expression(p_expr);
      end if;
      for i in 1 .. l_rpn_tokens.count loop
         case
         ---------------
         -- operators --
         ---------------
         when is_expression_operator(l_rpn_tokens(i)) or
              is_comparison_operator(l_rpn_tokens(i)) or
              is_combination_operator(l_rpn_tokens(i))          
         then
            if l_rpn_tokens(i) = 'NOT' then
               push(pop||l_rpn_tokens(i));
            else
               l_val2 := pop;
               l_val1 := pop;
               push(l_val1||' '||l_val2||' '||l_rpn_tokens(i));
            end if; 
         ---------------
         -- constants --
         ---------------
         when is_expression_constant(l_rpn_tokens(i)) then push(l_rpn_tokens(i));
         ---------------------
         -- unary functions --
         ---------------------
         when is_expression_function(l_rpn_tokens(i)) then
            push(pop||' '||l_rpn_tokens(i));
         ---------------
         -- arguments --
         ---------------
         when substr(l_rpn_tokens(i), 1, 3) = 'ARG' or substr(l_rpn_tokens(i), 1, 4) = '-ARG' then
            push(l_rpn_tokens(i));
         -------------
         -- numbers --
         -------------
         else             
            begin
               l_number := to_number(l_rpn_tokens(i));
            exception
               when others then cwms_err.raise('ERROR', 'Invalid expression token: '||l_rpn_tokens(i));
            end;
            push(l_rpn_tokens(i));
         end case;
      end loop;
      return l_stack;
   end tokenize_expression2;
   
   -----------------------------------------------------------------------------
   -- FUNCTION replace_parentheticals
   -----------------------------------------------------------------------------
   function replace_parentheticals(
      p_expr in varchar2)
      return str_tab_t
   is
      l_results   str_tab_t := str_tab_t();
      l_positions number_tab_t;
      l_expr      varchar2(32767);
      l_start     pls_integer;
      l_end       pls_integer;
      l_token     varchar2(4);
      l_parts     str_tab_t;  
   begin
      select pos
        bulk collect
        into l_positions 
        from (select pos,
                     offset,
                     sum(offset) over (order by pos) as depth
                from (select instr(p_expr, '(', 1, level) as pos,
                             1 as offset 
                        from dual
                     connect by level <= regexp_count(p_expr, '\(')
                      union all
                      select instr(p_expr, ')', 1, level) as pos,
                             -1 as offset 
                        from dual
                     connect by level <= regexp_count(p_expr, '\)')
                     )
              )
        where offset =  1 and depth = 1
           or offset = -1 and depth = 0;
      if l_positions.count = 1 then 
         l_positions.trim;
      end if;           
      l_results.extend(l_positions.count/2+1);
      l_expr := p_expr;
      for i in reverse 1..l_positions.count/2 loop
         l_start := l_positions(2*i-1);
         l_end   := l_positions(2*i);  
         l_results(i) := trim(substr(l_expr, l_start+1, l_end-l_start-1)); 
                              
         l_token := '$'||i;
         l_expr  := rtrim(substr(l_expr, 1, l_start-1))||' '||l_token||' '||ltrim(substr(l_expr, l_end+1));
         l_parts := split_text(l_expr);
         for j in 1..l_parts.count loop
            if l_parts(j) = l_token then
               if j > 1 and is_expression_function(l_parts(j-1)) then
                  l_results(i) := l_parts(j-1)||' '||l_results(i);
                  l_parts(j-1) := ' ';
                  l_expr := join_text(l_parts, ' ');
               end if;
               exit;
            end if;
         end loop; 
      end loop;
      l_results(l_positions.count/2+1) := trim(l_expr);              
      return l_results;
   end replace_parentheticals;      

   -----------------------------------------------------------------------------
   -- FUNCTION eval_tokenized_expression
   -----------------------------------------------------------------------------
   function eval_tokenized_expression(
      p_rpn_tokens    in str_tab_t,
      p_args          in double_tab_t,
      p_args_offset   in integer default 0)
      return number
   is 
      l_stack double_tab_t;
   begin
      l_stack := eval_tokenized_expression2(
         p_rpn_tokens  => p_rpn_tokens,
         p_args        => p_args,
         p_args_offset => p_args_offset);
      if l_stack.count > 1 then
         cwms_err.raise ('ERROR', 'Remaining items on stack');
      end if;
      return l_stack(1);         
   end eval_tokenized_expression;      

   -----------------------------------------------------------------------------
   -- FUNCTION eval_tokenized_expression2
   -----------------------------------------------------------------------------
   function eval_tokenized_expression2(
      p_rpn_tokens    in str_tab_t,
      p_args          in double_tab_t,
      p_args_offset   in integer default 0)
   return double_tab_t
   is
      l_stack double_tab_t := double_tab_t();
      l_val1  binary_double;
      l_val2  binary_double;
      l_idx   binary_integer;
      --------------------
      -- local routines --
      --------------------
      procedure token_error(token in varchar2)
      is
      begin
         cwms_err.raise('ERROR', 'Invalid token in equation: ' || token);
      end;

      procedure argument_error(l_idx in integer)
      is
      begin
         cwms_err.raise('ERROR', 'ARG' || l_idx || ' does not exist');
      end;

      procedure push(val in binary_double)
      is
      begin
         l_stack.extend;
         l_stack(l_stack.count) := val;
      end;

      function pop return binary_double
      is
         val binary_double;
      begin
         val := l_stack(l_stack.last);
         l_stack.trim;
         return val;
      end;
   begin
      for i in 1 .. p_rpn_tokens.count
      loop
         case
         ---------------
         -- operators --
         ---------------
         when p_rpn_tokens(i) = '+'  then push(pop + pop);
         when p_rpn_tokens(i) = '-'  then push(-pop + pop);
         when p_rpn_tokens(i) = '*'  then push(pop * pop);
         when p_rpn_tokens(i) = '/'  then
            l_val2 := nullif(pop, 0);
            l_val1 := pop;
            push(l_val1 / l_val2);
         when p_rpn_tokens(i) = '//' then -- same as Python
            l_val2 := nullif(pop, 0);
            l_val1 := pop;
            push(floor(l_val1 / l_val2));
         when p_rpn_tokens(i) = '%'  then -- same as Python math.fmod, not %
            l_val2 := nullif(pop, 0);
            l_val1 := pop;
            push(mod(l_val1, l_val2));
         when p_rpn_tokens(i) = '^'  then
            l_val2 := pop;
            l_val1 := pop;
            push(power(l_val1, l_val2));
         ---------------
         -- constants --
         ---------------
         when p_rpn_tokens(i) = 'E'  then push(2.7182818284590451);
         when p_rpn_tokens(i) = 'PI' then push(3.1415926535897931);
         ---------------------
         -- unary functions --
         ---------------------
         when p_rpn_tokens(i) = 'ABS'   then push(abs(pop));
         when p_rpn_tokens(i) = 'ACOS'  then push(acos(pop));
         when p_rpn_tokens(i) = 'ASIN'  then push(asin(pop));
         when p_rpn_tokens(i) = 'ATAN'  then push(atan(pop));
         when p_rpn_tokens(i) = 'CEIL'  then push(ceil(pop));
         when p_rpn_tokens(i) = 'COS'   then push(cos(pop));
         when p_rpn_tokens(i) = 'EXP'   then push(exp(pop));
         when p_rpn_tokens(i) = 'FLOOR' then push(floor(pop));
         when p_rpn_tokens(i) = 'INV'   then push(1 / pop);
         when p_rpn_tokens(i) = 'LN'    then push(ln(pop));
         when p_rpn_tokens(i) = 'LOG'   then push(log(10, pop)); -- log base 10
         when p_rpn_tokens(i) = 'NEG'   then push(pop * -1);
         when p_rpn_tokens(i) = 'ROUND' then push(round(pop));
         when p_rpn_tokens(i) = 'SIGN'  then                     -- not SQL sign, but +1, 0, or -1
            l_val1 := pop;
            case
            when l_val1 < 0 then push(-1);
            when l_val1 > 0 then push(1);
            else push(0);
            end case;
         when p_rpn_tokens(i) = 'SIN'   then push(sin(pop));
         when p_rpn_tokens(i) = 'SQRT'  then push(sqrt(pop));
         when p_rpn_tokens(i) = 'TAN'   then push(tan(pop));
         when p_rpn_tokens(i) = 'TRUNC' then push(trunc(pop));
         ---------------
         -- arguments --
         ---------------
         when substr(p_rpn_tokens(i), 1, 3) = 'ARG' then
            begin
               l_idx := to_number(substr(p_rpn_tokens(i), 4)) + p_args_offset;
               if l_idx < 1 or l_idx > p_args.count then
                  argument_error(l_idx - p_args_offset);
               end if;
               push(p_args(l_idx)); 
            exception
               when others then
                  token_error(p_rpn_tokens(i));
            end;
         when substr(p_rpn_tokens(i), 1, 4) = '-ARG' then
            begin
               l_idx := to_number(substr(p_rpn_tokens(i), 5));
               if l_idx < 1 or l_idx > p_args.count
               then
                  argument_error(l_idx - p_args_offset);
               end if;
               push(p_args(l_idx));
            exception
               when others then
                  token_error(p_rpn_tokens(i));
            end;
         -------------
         -- numbers --
         -------------
         else
            begin
               push(to_binary_double(p_rpn_tokens(i)));
            exception
               when others then
                  token_error(p_rpn_tokens(i));
            end;
         end case;
      end loop;
      return l_stack;
   end eval_tokenized_expression2;

   -----------------------------------------------------------------------------
   -- FUNCTION eval_algebraic_expression
   -----------------------------------------------------------------------------
   function eval_algebraic_expression(
      p_algebraic_expr in varchar2,
      p_args           in double_tab_t,
      p_args_offset    in integer default 0)
      return number
   is
   begin
      return eval_tokenized_expression(
                tokenize_algebraic(p_algebraic_expr),
                p_args,
                p_args_offset);
   exception
      when others then
         cwms_err.raise('ERROR', 'Invalid algebraic expression: ' || p_algebraic_expr);
   end eval_algebraic_expression;

   -----------------------------------------------------------------------------
   -- FUNCTION eval_algebraic_expression2
   -----------------------------------------------------------------------------
   function eval_algebraic_expression2(
      p_algebraic_expr in varchar2,
      p_args           in double_tab_t,
      p_args_offset    in integer default 0)
      return double_tab_t
   is
   begin
      return eval_tokenized_expression2(
                tokenize_algebraic(p_algebraic_expr),
                p_args,
                p_args_offset);
   exception
      when others then
         cwms_err.raise('ERROR', 'Invalid algebraic expression: ' || p_algebraic_expr);
   end eval_algebraic_expression2;

   -----------------------------------------------------------------------------
   -- FUNCTION eval_rpn_expression
   -----------------------------------------------------------------------------
   function eval_rpn_expression(
      p_rpn_expr      in varchar2,
      p_args          in double_tab_t,
      p_args_offset   in integer default 0)
      return number
   is
   begin
      return eval_tokenized_expression(
                tokenize_rpn(p_rpn_expr),
                p_args,
                p_args_offset);
   exception
      when others then
         cwms_err.raise('ERROR', 'Invalid RPN expression: ' || p_rpn_expr);
   end eval_rpn_expression;

   -----------------------------------------------------------------------------
   -- FUNCTION eval_rpn_expression2
   -----------------------------------------------------------------------------
   function eval_rpn_expression2(
      p_rpn_expr      in varchar2,
      p_args          in double_tab_t,
      p_args_offset   in integer default 0)
      return double_tab_t
   is
   begin
      return eval_tokenized_expression2(
                tokenize_rpn(p_rpn_expr),
                p_args,
                p_args_offset);
   exception
      when others then
         cwms_err.raise('ERROR', 'Invalid RPN expression: ' || p_rpn_expr);
   end eval_rpn_expression2;

   -----------------------------------------------------------------------------
   -- FUNCTION eval_expression
   -----------------------------------------------------------------------------
   function eval_expression(
      p_expr          in varchar2,
      p_args          in double_tab_t,
      p_args_offset   in integer default 0)
      return number
   is
   begin
      return eval_tokenized_expression(tokenize_expression(p_expr), p_args, p_args_offset);
   exception
      when others then
         cwms_err.raise('ERROR', 'Invalid expression: ' || p_expr);
   end eval_expression;
   
   -----------------------------------------------------------------------------
   -- FUNCTION eval_expression2
   -----------------------------------------------------------------------------
   function eval_expression2(
      p_expr          in varchar2,
      p_args          in double_tab_t,
      p_args_offset   in integer default 0)
      return double_tab_t
   is
   begin
      return eval_tokenized_expression2(tokenize_expression(p_expr), p_args, p_args_offset);
   exception
      when others then
         cwms_err.raise('ERROR', 'Invalid expression: ' || p_expr);
   end eval_expression2;

   -----------------------------------------------------------------------------
   -- FUNCTION eval_tokenized_comparison
   -----------------------------------------------------------------------------
   function eval_tokenized_comparison(
      p_tokens      in str_tab_tab_t,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return boolean
   is
      l_val1   number;
      l_val2   number;
      l_op     varchar2(16);
      l_result boolean;
   begin
      l_val1 := eval_tokenized_expression(p_tokens(1), p_args, p_args_offset);
      l_val2 := eval_tokenized_expression(p_tokens(2), p_args, p_args_offset);
      l_op   := p_tokens(3)(1);
      case
         when l_op =   '='        then l_result := l_val1  = l_val2;
         when l_op in ('!=','<>') then l_result := l_val1 != l_val2;
         when l_op in ('<', 'LT') then l_result := l_val1 <  l_val2;
         when l_op in ('<=','LE') then l_result := l_val1 <= l_val2;
         when l_op in ('>', 'GT') then l_result := l_val1 >  l_val2;
         when l_op in ('>=','GE') then l_result := l_val1 >= l_val2;
         else cwms_err.raise('ERROR', 'Invalid comparison operator: '||l_op);
      end case;
      return l_result;
   end eval_tokenized_comparison;
          
   -----------------------------------------------------------------------------
   -- FUNCTION eval_tokenized_comparison2
   -----------------------------------------------------------------------------
   function eval_tokenized_comparison2(
      p_tokens      in str_tab_tab_t,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return varchar2
   is
   begin
      return case eval_tokenized_comparison(p_tokens, p_args, p_args_offset)
             when true  then 'T'
             when false then 'F'
             end;
   end eval_tokenized_comparison2;
          
   -----------------------------------------------------------------------------
   -- FUNCTION eval_comparison_expression
   -----------------------------------------------------------------------------
   function eval_comparison_expression(
      p_expr        in varchar2,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return boolean
   is
   begin
      return eval_tokenized_comparison(
         tokenize_comparison_expression(p_expr), 
         p_args, 
         p_args_offset);
   end eval_comparison_expression;
          
   -----------------------------------------------------------------------------
   -- FUNCTION eval_comparison_expression2
   -----------------------------------------------------------------------------
   function eval_comparison_expression2(
      p_expr        in varchar2,
      p_args        in double_tab_t,
      p_args_offset in integer default 0)
      return varchar2
   is
   begin
      return case eval_comparison_expression(p_expr, p_args, p_args_offset)
             when true  then 'T'
             when false then 'F'
             end;
   end eval_comparison_expression2;
          
   -----------------------------------------------------------------------------
   -- FUNCTION get_expression_depth_at
   -----------------------------------------------------------------------------
   function get_expression_depth_at(
      p_position in integer,
      p_expr     in varchar2)
      return integer
   is
      l_expr  varchar2(32767) := substr(p_expr, 1, p_position);
      l_depth pls_integer;
   begin                       
      l_depth := regexp_count(l_expr, '\(') - regexp_count(l_expr, '\)');
      if substr(l_expr, p_position, 1) = ')' then
         l_depth := l_depth + 1;
      end if;
      return l_depth;
   end get_expression_depth_at;      
            
   function to_algebraic(
      p_expr in varchar2)
      return varchar2
   is
   begin
      return to_algebraic(tokenize_expression(p_expr));
   end to_algebraic;      
            
   function to_algebraic(
      p_tokens in str_tab_t)
      return varchar2
   is
      l_rpn_tokens str_tab_t;
      l_stack      str_tab_t := str_tab_t();
      l_val1       varchar2(32767);
      l_val2       varchar2(32767);
      l_idx        binary_integer;
      --------------------
      -- local routines --
      --------------------
      procedure token_error(token in varchar2)
      is
      begin
         cwms_err.raise('ERROR', 'Invalid token in equation: ' || token);
      end;

      procedure argument_error(l_idx in integer)
      is
      begin
         cwms_err.raise('ERROR', 'ARG' || l_idx || ' does not exist');
      end;

      procedure push(val in varchar2)
      is
      begin
         l_stack.extend;
         l_stack(l_stack.count) := val;
      end;

      function pop return varchar2
      is
         val         varchar2(32767);
      begin
         val := l_stack(l_stack.last);
         l_stack.trim;
         return val;
      end;
      
      function precedence(p_op in varchar2) return integer
      is
         l_precedence integer;
      begin
         case 
         when p_op in ('+','-')          then l_precedence := 1;
         when p_op in ('*','/','//','%') then l_precedence := 2;
         when p_op = '^'                 then l_precedence := 3;
         else cwms_err.raise('ERROR', 'Invalid operator: '||p_op); 
         end case;
         return l_precedence;
      end;
   begin             
      for i in 1 .. p_tokens.count loop
         case
         ---------------
         -- operators --
         ---------------
         when p_tokens(i) in ('+','-','*','/','//','%','^')  then 
            l_val2 := pop;
            l_rpn_tokens := tokenize_expression(l_val2);
            if l_rpn_tokens(l_rpn_tokens.count) in ('+','-','*','/','//','%','^') and 
               precedence(l_rpn_tokens(l_rpn_tokens.count)) < precedence(p_tokens(i))
            then
               l_val2 := '('||l_val2||')';
            end if; 
            l_val1 := pop;
            l_rpn_tokens := tokenize_expression(l_val1);
            if l_rpn_tokens(l_rpn_tokens.count) in ('+','-','*','/','//','%','^') and 
            precedence(l_rpn_tokens(l_rpn_tokens.count)) < precedence(p_tokens(i))
            then
               l_val1 := '('||l_val1||')';
            end if; 
            push(l_val1||' '||p_tokens(i)||' '||l_val2);
         ---------------
         -- constants --
         ---------------
         when p_tokens(i) in ('E', 'PI') then push(p_tokens(i));
         ---------------------
         -- unary functions --
         ---------------------
         when p_tokens(i) in ('ABS','ACOS','ASIN','ATAN','CEIL','COS','EXP','FLOOR','INV','LN','LOG','NEG','ROUND','SIGN','SIN','SQRT','TAN','TRUNC') then
            l_val1 := pop;
            if substr(l_val1, 1, 1) = '(' then
               push(p_tokens(i)||l_val1);
            else
               push(p_tokens(i)||'('||l_val1||')');
            end if;
         ---------------
         -- arguments --
         ---------------
         when substr(p_tokens(i), 1, 3) = 'ARG' or substr(p_tokens(i), 1, 4) = '-ARG' then
            push(p_tokens(i));
         -------------
         -- numbers --
         -------------
         else
            push(p_tokens(i));
         end case;
      end loop;
      if l_stack.count != 1 then
         cwms_err.raise('ERROR', 'Items left on stack');
      end if;
      return pop;
   end to_algebraic;
         
   function to_algebraic_logic(
      p_expr in varchar2)
      return varchar2
   is
      l_expr        varchar2(256);
      l_logic_expr logic_expr_t;
   begin
      l_logic_expr := logic_expr_t(p_expr);
      l_logic_expr.to_algebraic(l_expr);
      return l_expr;
   end to_algebraic_logic;            
            
   function to_rpn(
      p_expr in varchar2)
      return varchar2
   is
   begin
      return to_rpn(tokenize_expression(p_expr));
   end to_rpn;      
            
   function to_rpn(
      p_tokens in str_tab_t)
      return varchar2
   is
   begin
      return join_text(p_tokens, ' ');
   end to_rpn;      
         
   function to_rpn_logic(
      p_expr in varchar2)
      return varchar2
   is
      l_expr        varchar2(256);
      l_logic_expr logic_expr_t;
   begin
      l_logic_expr := logic_expr_t(p_expr);
      l_logic_expr.to_rpn(l_expr);
      return l_expr;
   end to_rpn_logic;
               
   function get_comparison_op_symbol(
      p_operator in varchar2)
      return varchar2
   is
      l_op varchar2(8); 
   begin
      l_op := upper(trim(p_operator));
      case
      when l_op in ('EQ', '='        ) then l_op := '=' ;
      when l_op in ('NE', '!=', '<>' ) then l_op := '!=';
      when l_op in ('LT', '<'        ) then l_op := '<' ;
      when l_op in ('LE', '<='       ) then l_op := '<=';
      when l_op in ('GT', '>'        ) then l_op := '>' ;
      when l_op in ('GE', '>='       ) then l_op := '>=';
      else cwms_err.raise('INVALID_ITEM', p_operator, 'comparison operator');
      end case;
      return l_op;
   end;               
               
   function get_comparison_op_text(
      p_operator in varchar2)
      return varchar2
   is
      l_op varchar2(8); 
   begin
      l_op := upper(trim(p_operator));
      case
      when l_op in ('EQ', '='        ) then l_op := 'EQ';
      when l_op in ('NE', '!=', '<>' ) then l_op := 'NE';
      when l_op in ('LT', '<'        ) then l_op := 'LT';
      when l_op in ('LE', '<='       ) then l_op := 'LE';
      when l_op in ('GT', '>'        ) then l_op := 'GT';
      when l_op in ('GE', '>='       ) then l_op := 'GE';
      else cwms_err.raise('INVALID_ITEM', p_operator, 'comparison operator');
      end case;
      return l_op;
   end;               

   ---------------------
   -- Append routines --
   ---------------------

   PROCEDURE append (p_dst IN OUT NOCOPY CLOB, p_src IN CLOB)
   IS
   BEGIN
      DBMS_LOB.append (p_dst, p_src);
   END append;

   PROCEDURE append (p_dst IN OUT NOCOPY CLOB, p_src IN VARCHAR2)
   IS
   BEGIN
      DBMS_LOB.writeappend (p_dst, LENGTH (p_src), p_src);
   END append;

   PROCEDURE append (p_dst IN OUT NOCOPY CLOB, p_src IN XMLTYPE)
   IS
      l_src   CLOB := p_src.getclobval;
   BEGIN
      append (p_dst, l_src);
   END append;

   PROCEDURE append (p_dst IN OUT NOCOPY XMLTYPE, p_src IN CLOB)
   IS
      l_dst   CLOB := p_dst.getclobval;
   BEGIN
      append (l_dst, p_src);
      p_dst := xmltype (l_dst);
   END append;

   PROCEDURE append (p_dst IN OUT NOCOPY XMLTYPE, p_src IN VARCHAR2)
   IS
      l_dst   CLOB := p_dst.getclobval;
   BEGIN
      append (l_dst, p_src);
      p_dst := xmltype (l_dst);
   END append;

   PROCEDURE append (p_dst IN OUT NOCOPY XMLTYPE, p_src IN XMLTYPE)
   IS
      l_dst   CLOB := p_dst.getclobval;
   BEGIN
      append (l_dst, p_src);
      p_dst := xmltype (l_dst);
   END append;

   --------------------------
   -- XML Utility routines --
   --------------------------

   function get_xml_node (
      p_xml  in xmltype, 
      p_path in varchar)
   return xmltype
   is
   begin
      return case p_xml is null or p_path is null
             when true then null
             when false then p_xml.extract (p_path)
             end;
   end get_xml_node;
   
   function get_xml_nodes(
      p_xml        in xmltype,
      p_path       in varchar2,
      p_condition  in varchar2 default null,
      p_order_by   in varchar2 default null,
      p_descending in varchar2 default 'F')
   return xml_tab_t  
   is
      l_flwor   varchar2(32767);
      l_results xml_tab_t;
   begin
      -------------------------------------
      -- build an XQuery FLWOR statement --
      -------------------------------------
      l_flwor := 'for $e in '||p_path;
      if p_condition is not null then
         l_flwor := l_flwor||' where '||replace(p_condition, p_path, '$e');
      end if;
      if p_order_by is not null then
         l_flwor := l_flwor||' order by '||replace(p_order_by, p_path, '$e');
         if return_true_or_false(p_descending) then
            l_flwor := l_flwor||' descending';
         end if;
      end if;
      l_flwor := l_flwor||' return $e';
      select element
        bulk collect
        into l_results
        from xmltable(
                l_flwor 
                passing p_xml
                columns element xmltype path '.'); -- included only for completeness
      return l_results;
   end get_xml_nodes;

   function get_xml_text(
      p_xml  in xmltype, 
      p_path in varchar)
   return varchar2
   is
      l_xml    xmltype;
      l_text   varchar2(32767);
   begin    
      l_xml := get_xml_node(p_xml, p_path);
      if l_xml is not null and instr(p_path, '/@') = 0 then
         l_xml := l_xml.extract('/node()/text()');
      end if;

      if l_xml is not null then
         l_text := regexp_replace(regexp_replace(l_xml.getstringval, '^\s+'), '\s+$');
      end if;
      return l_text;
   end get_xml_text;

   function get_xml_number(
      p_xml  in xmltype, 
      p_path in varchar)
   return number
   is
   begin
      return to_number(get_xml_text (p_xml, p_path));
   end get_xml_number;


   FUNCTION x_minus_y (p_list_1      IN VARCHAR2,
                       p_list_2      IN VARCHAR2,
                       p_separator   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_list_1   str_tab_t;
      l_list_2   str_tab_t;
      l_list_3   str_tab_t;
   BEGIN
      l_list_1 := split_text (p_text => p_list_1, p_separator => p_separator);
      l_list_2 := split_text (p_text => p_list_2, p_separator => p_separator);

      SELECT *
        BULK COLLECT INTO l_list_3
        FROM (SELECT * FROM TABLE (l_list_1)
              MINUS
              SELECT * FROM TABLE (l_list_2));

      RETURN cwms_util.join_text (p_text_tab    => l_list_3,
                                  p_separator   => p_separator);
   END x_minus_y;


   PROCEDURE set_boolean_state (p_name IN VARCHAR2, p_state IN BOOLEAN)
   IS
   BEGIN
      set_boolean_state (
         p_name,
         CASE p_state WHEN TRUE THEN 'T' WHEN FALSE THEN 'F' END);
   END set_boolean_state;

   PROCEDURE set_boolean_state (p_name IN VARCHAR2, p_state IN CHAR)
   IS
      l_name   VARCHAR2 (64);
   BEGIN
      SELECT name
        INTO l_name
        FROM at_boolean_state
       WHERE UPPER (name) = UPPER (p_name);

      UPDATE at_boolean_state
         SET state = p_state
       WHERE name = l_name;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         INSERT INTO at_boolean_state
              VALUES (p_name, p_state);
   END set_boolean_state;

   FUNCTION get_boolean_state_char (p_name IN VARCHAR2)
      RETURN CHAR
   IS
      l_state   CHAR (1);
   BEGIN
      BEGIN
         SELECT state
           INTO l_state
           FROM at_boolean_state
          WHERE UPPER (name) = UPPER (p_name);
      EXCEPTION
         WHEN OTHERS
         THEN
            NULL;
      END;

      RETURN l_state;
   END get_boolean_state_char;

   FUNCTION get_boolean_state (p_name IN VARCHAR2)
      RETURN BOOLEAN
   IS
      l_state   CHAR (1);
   BEGIN
      l_state := get_boolean_state_char (p_name);
      RETURN CASE l_state IS NULL WHEN TRUE THEN NULL ELSE l_state = 'T' END;
   END get_boolean_state;

   PROCEDURE set_session_info (p_item_name   IN VARCHAR2,
                               p_txt_value   IN VARCHAR2,
                               p_num_value   IN NUMBER)
   IS
      l_item_name   VARCHAR2 (64);
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      IF p_item_name IS NULL
      THEN
         cwms_err.raise ('NULL_ARGUMENT', 'P_ITEM_NAME');
      END IF;

      -----------------------------
      -- insert/update the table --
      -----------------------------
      l_item_name := UPPER (TRIM (p_item_name));

      MERGE INTO at_session_info t
           USING (SELECT l_item_name AS item_name FROM DUAL) d
              ON (t.item_name = d.item_name)
      WHEN MATCHED
      THEN
         UPDATE SET str_value = p_txt_value, num_value = p_num_value
      WHEN NOT MATCHED
      THEN
         INSERT     VALUES (l_item_name, p_txt_value, p_num_value);
   END set_session_info;

   PROCEDURE set_session_info (p_item_name   IN VARCHAR2,
                               p_txt_value   IN VARCHAR2)
   IS
      l_item_name   VARCHAR2 (64);
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      IF p_item_name IS NULL
      THEN
         cwms_err.raise ('NULL_ARGUMENT', 'P_ITEM_NAME');
      END IF;

      -----------------------------
      -- insert/update the table --
      -----------------------------
      l_item_name := UPPER (TRIM (p_item_name));

      MERGE INTO at_session_info t
           USING (SELECT l_item_name AS item_name FROM DUAL) d
              ON (t.item_name = d.item_name)
      WHEN MATCHED
      THEN
         UPDATE SET str_value = p_txt_value
      WHEN NOT MATCHED
      THEN
         INSERT     VALUES (l_item_name, p_txt_value, NULL);
   END set_session_info;

   PROCEDURE set_session_info (p_item_name   IN VARCHAR2,
                               p_num_value   IN NUMBER)
   IS
      l_item_name   VARCHAR2 (64);
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      IF p_item_name IS NULL
      THEN
         cwms_err.raise ('NULL_ARGUMENT', 'P_ITEM_NAME');
      END IF;

      -----------------------------
      -- insert/update the table --
      -----------------------------
      l_item_name := UPPER (TRIM (p_item_name));

      MERGE INTO at_session_info t
           USING (SELECT l_item_name AS item_name FROM DUAL) d
              ON (t.item_name = d.item_name)
      WHEN MATCHED
      THEN
         UPDATE SET num_value = p_num_value
      WHEN NOT MATCHED
      THEN
         INSERT     VALUES (l_item_name, NULL, p_num_value);
   END set_session_info;

   PROCEDURE get_session_info (p_txt_value      OUT VARCHAR2,
                               p_num_value      OUT NUMBER,
                               p_item_name   IN     VARCHAR2)
   IS
      l_item_name   VARCHAR2 (64);
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      IF p_item_name IS NULL
      THEN
         cwms_err.raise ('NULL_ARGUMENT', 'P_ITEM_NAME');
      END IF;

      -------------------------
      -- retrieve the values --
      -------------------------
      l_item_name := UPPER (TRIM (p_item_name));

      BEGIN
         SELECT str_value, num_value
           INTO p_txt_value, p_num_value
           FROM at_session_info
          WHERE item_name = l_item_name;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
      END;
   END get_session_info;

   FUNCTION get_session_info_txt (p_item_name IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_txt_value   VARCHAR2 (256);
      l_num_value   NUMBER;
   BEGIN
      get_session_info (l_txt_value, l_num_value, p_item_name);

      RETURN l_txt_value;
   END get_session_info_txt;

   FUNCTION get_session_info_num (p_item_name IN VARCHAR2)
      RETURN NUMBER
   IS
      l_txt_value   VARCHAR2 (256);
      l_num_value   NUMBER;
   BEGIN
      get_session_info (l_txt_value, l_num_value, p_item_name);

      RETURN l_num_value;
   END get_session_info_num;

   PROCEDURE reset_session_info (p_item_name IN VARCHAR2)
   IS
      l_item_name   VARCHAR2 (64);
   BEGIN
      -------------------
      -- sanity checks --
      -------------------
      IF p_item_name IS NULL
      THEN
         cwms_err.raise ('NULL_ARGUMENT', 'P_ITEM_NAME');
      END IF;

      -----------------------
      -- delete the record --
      -----------------------
      l_item_name := UPPER (TRIM (p_item_name));

      BEGIN
         DELETE FROM at_session_info
               WHERE item_name = l_item_name;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
      END;
   END reset_session_info;

   FUNCTION is_nan (p_value IN BINARY_DOUBLE)
      RETURN VARCHAR2
   IS
      l_is_nan   BOOLEAN := p_value IS NAN;
   BEGIN
      RETURN CASE l_is_nan WHEN TRUE THEN 'T' ELSE 'F' END;
   END is_nan;

   function sub_table(
      p_table in str_tab_t,
      p_first in integer,
      p_last  in integer default null)
      return str_tab_t
   is  
      l_last  integer;
      l_table str_tab_t;
   begin
      l_last := least(nvl(p_last, p_table.count), p_table.count);

      select trim(column_value)
        bulk collect
        into l_table
        from (select column_value,
                     rownum as seq
                from table(p_table)
             )
       where seq between p_first and l_last
       order by seq; 
       
      return l_table;                        
   end sub_table;

   function sub_table(
      p_table in number_tab_t,
      p_first in integer,
      p_last  in integer default null)
      return number_tab_t
   is  
      l_last  integer;
      l_table number_tab_t;
   begin
      l_last := least(nvl(p_last, p_table.count), p_table.count);

      select trim(column_value)
        bulk collect
        into l_table
        from (select column_value,
                     rownum as seq
                from table(p_table)
             )
       where seq between p_first and l_last
       order by seq; 
       
      return l_table;                        
   end sub_table;

   function sub_table(
      p_table in double_tab_t,
      p_first in integer,
      p_last  in integer default null)
      return double_tab_t
   is  
      l_last  integer;
      l_table double_tab_t;
   begin
      l_last := least(nvl(p_last, p_table.count), p_table.count);

      select trim(column_value)
        bulk collect
        into l_table
        from (select column_value,
                     rownum as seq
                from table(p_table)
             )
       where seq between p_first and l_last
       order by seq; 
       
      return l_table;                        
   end sub_table;
      
   function parse_unit_spec(
      p_unit_spec in varchar2,
      p_key       in varchar2)
      return varchar2
   is
      l_parts1 str_tab_t;
      l_parts2 str_tab_t;
      l_parsed varchar2(16);
      l_key    varchar2(1) := upper(trim(p_key));
      begin
      l_parts1 := split_text(p_unit_spec, '|');
      for i in 1..l_parts1.count loop
         l_parts2 := split_text(trim(l_parts1(i)), '=');
         if l_parts2.count = 2 and upper(trim(l_parts2(1))) = l_key then
            l_parsed := trim(l_parts2(2));
            exit;
         end if;
      end loop;
      return l_parsed;
   end parse_unit_spec;

   function parse_unit(
      p_unit_spec in varchar2)
      return varchar2
   is
   begin
      if instr(p_unit_spec, '=') > 0 then
         return parse_unit_spec(p_unit_spec, 'U');
      else
         return p_unit_spec;
      end if;
   end parse_unit;

   function parse_vertical_datum(
      p_unit_spec in varchar2)
      return varchar2
   is
   begin
      return parse_unit_spec(p_unit_spec, 'V');
   end parse_vertical_datum;

   function get_effective_vertical_datum(
      p_unit_spec in varchar2)
      return varchar2
   is
      l_vertical_datum varchar2(16);
   begin
      l_vertical_datum := parse_vertical_datum(p_unit_spec);
      if l_vertical_datum is null then
         l_vertical_datum := cwms_loc.get_default_vertical_datum;
      end if;
      l_vertical_datum := upper(trim(l_vertical_datum));
      if l_vertical_datum = 'NULL' then
         l_vertical_datum := null;
      end if;
      return l_vertical_datum;
   end get_effective_vertical_datum;

   procedure check_dynamic_sql(
      p_sql in varchar2)
   is 
      l_sql_no_quotes varchar2(32767);

      function remove_quotes(p_text in varchar2) return varchar2
      as
         l_test varchar2(32767);
         l_result varchar2(32767);
         l_pos    pls_integer;
   begin
         l_test := p_text;
         loop
            l_pos := regexp_instr(l_test, '[''"]');
            if l_pos > 0 then
               if substr(l_test, l_pos, 1) = '"' then 
                  ------------------------
                  -- double-quote first --
                  ------------------------
                  l_result := regexp_replace(l_test, '"[^"]*?"', '#', 1, 1);
                  l_result := regexp_replace(l_result, '''[^'']*?''', '$', 1, 1);
               else
                  ------------------------
                  -- single-quote first --
                  ------------------------
                  l_result := regexp_replace(l_test, '''[^'']*?''', '$', 1, 1);
                  l_result := regexp_replace(l_result, '"[^"]*?"', '#', 1, 1);
               end if;
            else
      -----------------------
              -- no quotes in text --
      -----------------------
               l_result := l_test;
            end if;
            exit when l_result = l_test;
            l_test := l_result;
         end loop;
         return l_result;
      end;
   begin
      l_sql_no_quotes := remove_quotes(p_sql);
      if regexp_instr(l_sql_no_quotes, '([''";]|--|/\*)') > 0 then
         cwms_err.raise(
            'ERROR',
            'UNSAFE DYNAMIC SQL : '||p_sql);
      end if;
   end check_dynamic_sql;      

   
   function get_url(
      p_url     in varchar2,
      p_timeout in integer default 60)
      return clob
   is
      l_req  utl_http.req;
      l_resp utl_http.resp;
      l_buf  varchar2(32767);
      l_clob clob;
      
      procedure write_clob(p_text in varchar2)
      is
         l_len binary_integer := length(p_text);
      begin
         dbms_lob.writeappend(l_clob, l_len, p_text);
      end;
   begin       
      dbms_lob.createtemporary(l_clob, true);
      dbms_lob.open(l_clob, dbms_lob.lob_readwrite);   
   begin
         utl_http.set_transfer_timeout(p_timeout);
         l_req := utl_http.begin_request(p_url);
         utl_http.set_header(l_req, 'User-Agent', 'Mozilla/4.0');
         l_resp := utl_http.get_response(l_req);
         utl_http.set_transfer_timeout;
          loop                             
            utl_http.read_text(l_resp, l_buf);
            write_clob(l_buf);
         end loop;
      exception
         when utl_http.end_of_body then
            utl_http.end_response(l_resp);
            
         when others then
            begin
               utl_http.end_response(l_resp);
            exception
               when others then null;
            end;
            raise;
      end;
      dbms_lob.close(l_clob);
      return l_clob;
   end get_url;      
   
   function get_column(
      p_table  in double_tab_tab_t,
      p_column in pls_integer)
      return double_tab_t
   is
      l_results double_tab_t;
      l_count   pls_integer;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_table is null then
         cwms_err.raise('NULL_ARGUMENT', 'p_table');
      end if;
      if p_column is null then
         cwms_err.raise('NULL_ARGUMENT', 'p_column');
      end if;
      select count(*) into l_count from table(p_table) where column_value is null;
      if l_count != 0 then 
         cwms_err.raise(
            'ERROR',
            'Table has one or more null rows');
      end if;
      l_count := p_table(1).count;
      if not p_column between 1 and l_count then
         cwms_err.raise(
            'ERROR',
            'Specified column ('
            ||p_column
            ||') is not valid for a table of width '
            ||l_count);
      end if;
      select value_in_column
        bulk collect
        into l_results 
        from (select t2.column_value as value_in_column, 
                     rownum as r 
                from table(p_table) t1,
                     table(t1.column_value) t2
               where t2.column_value in (select column_value from table(t1.column_value))             
             )
             where mod(r, l_count) = mod(p_column, l_count);
      return l_results;
   end get_column;            
   
    FUNCTION str2tbl (p_str IN VARCHAR2, p_delim IN VARCHAR2 DEFAULT ',')
       RETURN str2tblType
       PIPELINED
    AS
       l_str   LONG DEFAULT p_str || p_delim;
       l_n     NUMBER;
    BEGIN
       LOOP
          l_n := INSTR (l_str, p_delim);
          EXIT WHEN (NVL (l_n, 0) = 0);
          PIPE ROW (LTRIM (RTRIM (SUBSTR (l_str, 1, l_n - 1))));
          l_str := SUBSTR (l_str, l_n + 1);
       END LOOP;

       RETURN;
    END;

   function get_column(
      p_table  in str_tab_tab_t,
      p_column in pls_integer)
      return str_tab_t
   is
      l_results str_tab_t;
      l_count   pls_integer;
   begin
      -------------------
      -- sanity checks --
      -------------------
      if p_table is null then
         cwms_err.raise('NULL_ARGUMENT', 'p_table');
      end if;
      if p_column is null then
         cwms_err.raise('NULL_ARGUMENT', 'p_column');
      end if;
      select count(*) into l_count from table(p_table) where column_value is null;
      if l_count != 0 then 
         cwms_err.raise(
            'ERROR',
            'Table has one or more null rows');
      end if;
      l_count := p_table(1).count;
      if not p_column between 1 and l_count then
         cwms_err.raise(
            'ERROR',
            'Specified column ('
            ||p_column
            ||') is not valid for a table of width '
            ||l_count);
      end if;
      select value_in_column
        bulk collect
        into l_results 
        from (select t2.column_value as value_in_column, 
                     rownum as r 
                from table(p_table) t1,
                     table(t1.column_value) t2
               where t2.column_value in (select column_value from table(t1.column_value))             
             )
             where mod(r, l_count) = mod(p_column, l_count);
      return l_results;
   end get_column;            

   FUNCTION is_irregular_code (
      p_interval_code   IN CWMS_INTERVAL.INTERVAL_CODE%TYPE)
      RETURN BOOLEAN
   IS
      l_interval_dur   CWMS_INTERVAL.INTERVAL%TYPE;
   BEGIN
      BEGIN
         SELECT interval
           INTO l_interval_dur
           FROM cwms_interval ci
          WHERE interval_code = p_interval_code;
      EXCEPTION
         WHEN OTHERS
         THEN
            RAISE;
      END;

      IF (l_interval_dur = 0)
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_irregular_code;

   procedure check_office_permission(
      p_office_id     in varchar2,
      p_user_group_id in varchar2 default null)
   is
      l_user_id       varchar2(30); 
      l_office_id     varchar2(16);
      l_user_group_id varchar2(32);
   begin
      l_user_id := get_user_id;
      if l_user_id != '&cwms_schema' then
         l_office_id := cwms_util.get_db_office_id(p_office_id);
         if p_user_group_id is null then
            l_user_group_id := 'All Users';
         else
            l_user_group_id := p_user_group_id;
         end if;
         select db_office_id 
           into l_office_id     
           from table(cwms_sec.get_assigned_priv_groups_tab)
          where upper(user_group_id) = upper(l_user_group_id)
            and is_member = 'T'
            and db_office_id = l_office_id; 
      end if;
   exception 
      when no_data_found then
         cwms_err.raise(
            'ERROR', 
            'User '
            ||get_user_id
            ||' does not have '
            ||l_user_group_id
            ||' permission for office '
            ||l_office_id);
   end check_office_permission;


/*
BEGIN
 -- anything put here will be executed on every mod_plsql call
  NULL;
*/

END cwms_util;
/

SHOW ERRORS;
prompt update for package spec cwms_sec
/* Formatted on 5/28/2013 1:59:38 PM (QP5 v5.163.1008.3004) */
create or replace package cwms_sec
AS
   max_cwms_priv_ugroup_code     CONSTANT NUMBER := 9;
   max_cwms_ts_ugroup_code       CONSTANT NUMBER := 19;
   max_cwms_ts_group_code        CONSTANT NUMBER := 9;
   --
   user_group_code_all_users     CONSTANT NUMBER := 10;
   user_group_code_dba_users     CONSTANT NUMBER := 0;
   user_group_code_user_admins   CONSTANT NUMBER := 7;
   --
   acc_state_locked              CONSTANT VARCHAR2 (16) := 'LOCKED';
   acc_state_unlocked            CONSTANT VARCHAR2 (16) := 'UNLOCKED';
   acc_state_no_account          CONSTANT VARCHAR2 (16) := 'NO ACCOUNT';

   TYPE cat_at_sec_allow_rec_t IS RECORD
   (
      db_office_code    NUMBER,
      user_group_code   NUMBER,
      ts_group_code     NUMBER,
      db_office_id      VARCHAR2 (16),
      user_group_id     VARCHAR2 (32),
      ts_group_id       VARCHAR2 (32),
      priv_sum          NUMBER,
      priv              VARCHAR2 (15)
   );

   TYPE cat_at_sec_allow_tab_t IS TABLE OF cat_at_sec_allow_rec_t;

   TYPE cat_priv_groups_rec_t IS RECORD
   (
      username            VARCHAR2 (31),
      db_office_id        VARCHAR2 (16),
      user_group_type     VARCHAR2 (24),
      user_group_owner    VARCHAR2 (16),
      user_group_id       VARCHAR2 (32),
      is_member           VARCHAR2 (1),
      user_group_desc     VARCHAR2 (256)
   );

   TYPE cat_priv_groups_tab_t IS TABLE OF cat_priv_groups_rec_t;

   FUNCTION get_this_db_office_code
      RETURN NUMBER;

   FUNCTION get_this_db_office_id
      RETURN VARCHAR2;

   FUNCTION get_this_db_office_name
      RETURN VARCHAR2;


   FUNCTION get_max_cwms_ts_group_code
      RETURN NUMBER;

   FUNCTION is_user_admin (p_db_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN BOOLEAN;

   FUNCTION is_member_user_group (p_user_group_code   IN NUMBER,
                                  p_username          IN VARCHAR2,
                                  p_db_office_code    IN NUMBER)
      RETURN BOOLEAN;


   PROCEDURE set_user_office_id (p_username                  IN VARCHAR2,
                                 p_db_office_id   IN VARCHAR2);

   PROCEDURE assign_ts_group_user_group (
      p_ts_group_id     IN VARCHAR2,
      p_user_group_id   IN VARCHAR2,
      p_privilege       IN VARCHAR2,                    -- none, read or write
      p_db_office_id    IN VARCHAR2 DEFAULT NULL);

   PROCEDURE lock_db_account (p_username IN VARCHAR2);

   PROCEDURE unlock_db_account (p_username IN VARCHAR2);

   PROCEDURE create_cwms_db_account (
      p_username       IN VARCHAR2,
      p_password       IN VARCHAR2,
      p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   PROCEDURE create_cwmsdbi_db_user (
      p_dbi_username   IN VARCHAR2,
      p_dbi_password   IN VARCHAR2 DEFAULT NULL,
      p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   PROCEDURE set_dbi_user_passwd (p_dbi_password   IN VARCHAR2,
                                  p_dbi_username   IN VARCHAR2 DEFAULT NULL,
                                  p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   PROCEDURE delete_cwms_db_account (p_username IN VARCHAR2);

   PROCEDURE get_assigned_priv_groups (
      p_priv_groups       OUT SYS_REFCURSOR,
      p_db_office_id   IN     VARCHAR2 DEFAULT NULL);

   FUNCTION get_assigned_priv_groups_tab (
      p_db_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN cat_priv_groups_tab_t
      PIPELINED;

   PROCEDURE get_user_priv_groups (
      p_priv_groups       OUT SYS_REFCURSOR,
      p_username       IN     VARCHAR2 DEFAULT NULL,
      p_db_office_id   IN     VARCHAR2 DEFAULT NULL);

   FUNCTION get_user_priv_groups_tab (
      p_username       IN VARCHAR2 DEFAULT NULL,
      p_db_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN cat_priv_groups_tab_t
      PIPELINED;

   PROCEDURE get_user_office_data (p_office_id          OUT VARCHAR2,
                                   p_office_long_name   OUT VARCHAR2);

   FUNCTION get_user_office_id
      RETURN VARCHAR2;

   PROCEDURE unlock_user (p_username       IN VARCHAR2,
                          p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   FUNCTION get_user_group_code (p_user_group_id    IN VARCHAR2,
                                 p_db_office_code   IN NUMBER)
      RETURN NUMBER;

   PROCEDURE add_user_to_group (p_username         IN VARCHAR2,
                                p_user_group_id    IN VARCHAR2,
                                p_db_office_code   IN NUMBER);

   PROCEDURE add_user_to_group (p_username        IN VARCHAR2,
                                p_user_group_id   IN VARCHAR2,
                                p_db_office_id    IN VARCHAR2 DEFAULT NULL);

   PROCEDURE create_logon_trigger (p_username IN VARCHAR2);
   PROCEDURE create_user (p_username             IN VARCHAR2,
                          p_password             IN VARCHAR2,
                          p_user_group_id_list   IN char_32_array_type,
                          p_db_office_id         IN VARCHAR2 DEFAULT NULL);


   PROCEDURE delete_user (p_username IN VARCHAR2);

   PROCEDURE lock_user (p_username       IN VARCHAR2,
                        p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   PROCEDURE remove_user_from_group (
      p_username        IN VARCHAR2,
      p_user_group_id   IN VARCHAR2,
      p_db_office_id    IN VARCHAR2 DEFAULT NULL);

   FUNCTION get_user_state (p_username       IN VARCHAR2,
                            p_db_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2;

   PROCEDURE cat_at_sec_allow (p_at_sec_allow      OUT SYS_REFCURSOR,
                               p_db_office_id   IN     VARCHAR2 DEFAULT NULL);

   FUNCTION cat_at_sec_allow_tab (p_db_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN cat_at_sec_allow_tab_t
      PIPELINED;

   PROCEDURE refresh_mv_sec_ts_privileges;

   PROCEDURE start_refresh_mv_sec_privs_job;

   PROCEDURE store_priv_groups (p_username             IN VARCHAR2,
                                p_user_group_id_list   IN char_32_array_type,
                                p_db_office_id_list    IN char_16_array_type,
                                p_is_member_list       IN char_16_array_type);

   PROCEDURE change_user_group_id (
      p_user_group_id_old   IN VARCHAR2,
      p_user_group_id_new   IN VARCHAR2,
      p_db_office_id        IN VARCHAR2 DEFAULT NULL);

   PROCEDURE change_user_group_desc (
      p_user_group_id     IN VARCHAR2,
      p_user_group_desc   IN VARCHAR2,
      p_db_office_id      IN VARCHAR2 DEFAULT NULL);

   PROCEDURE delete_user_group (p_user_group_id   IN VARCHAR2,
                                p_db_office_id    IN VARCHAR2 DEFAULT NULL);

   PROCEDURE create_user_group (p_user_group_id     IN VARCHAR2,
                                p_user_group_desc   IN VARCHAR2,
                                p_db_office_id      IN VARCHAR2 DEFAULT NULL);

   PROCEDURE delete_ts_group (p_ts_group_id    IN VARCHAR2,
                              p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   PROCEDURE change_ts_group_id (
      p_ts_group_id_old   IN VARCHAR2,
      p_ts_group_id_new   IN VARCHAR2,
      p_db_office_id      IN VARCHAR2 DEFAULT NULL);

   PROCEDURE change_ts_group_desc (
      p_ts_group_id     IN VARCHAR2,
      p_ts_group_desc   IN VARCHAR2,
      p_db_office_id    IN VARCHAR2 DEFAULT NULL);

   PROCEDURE clear_ts_masks (p_ts_group_id    IN VARCHAR2,
                             p_db_office_id   IN VARCHAR2 DEFAULT NULL);

   PROCEDURE assign_ts_masks_to_ts_group (
      p_ts_group_id       IN VARCHAR2,
      p_ts_mask_list      IN char_183_array_type,
      p_add_remove_list   IN char_16_array_type,
      p_db_office_id      IN VARCHAR2 DEFAULT NULL);

   PROCEDURE create_ts_group (p_ts_group_id     IN VARCHAR2,
                              p_ts_group_desc   IN VARCHAR2,
                              p_db_office_id    IN VARCHAR2 DEFAULT NULL);

   FUNCTION get_admin_cwms_permissions (p_user_name      IN VARCHAR2,
                                        p_db_office_id   IN VARCHAR2)
      RETURN VARCHAR2;

   PROCEDURE get_user_cwms_permissions (
      p_cwms_permissions      OUT SYS_REFCURSOR,
      p_db_office_id       IN     VARCHAR2,
      p_include_all        IN     BOOLEAN DEFAULT FALSE);

   PROCEDURE get_db_users (p_db_users       OUT SYS_REFCURSOR,
                           p_db_office_id       VARCHAR2);

   PROCEDURE set_pd_user_passwd (p_pd_password   IN VARCHAR2,
                                  p_pd_username   IN VARCHAR2);
   PROCEDURE update_user_data (p_userid     IN VARCHAR2,
                               p_fullname   IN VARCHAR2,
                               p_org        IN VARCHAR2,
                               p_office     IN VARCHAR2,
                               p_phone      IN VARCHAR2,
                               p_email      IN VARCHAR2);

END cwms_sec;
/
prompt update for package body cwms_sec
/* Formatted on 5/28/2013 4:17:36 PM (QP5 v5.163.1008.3004) */

/* Formatted on 7/1/2013 1:09:40 PM (QP5 v5.163.1008.3004) */
create or replace package BODY cwms_sec
AS
   FUNCTION is_user_cwms_locked (p_db_office_code IN NUMBER)
      RETURN BOOLEAN
   IS
      l_is_locked   VARCHAR2 (1);
      l_username    VARCHAR2 (31) := cwms_util.get_user_id;
   BEGIN
      --
      -- &cwms_schema, system, sys are ok
      --
      IF l_username IN ('&cwms_schema', 'SYSTEM', 'SYS')
      THEN
         RETURN FALSE;
      END IF;

      --
      -- Check if user's account is locked for the p_db_office_code
      -- portion of the database...
      --

      BEGIN
         SELECT atslu.is_locked
           INTO l_is_locked
           FROM "AT_SEC_LOCKED_USERS" atslu
          WHERE atslu.db_office_code = p_db_office_code
                AND atslu.username = UPPER (l_username);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN TRUE;
      END;

      IF l_is_locked = 'T'
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_user_cwms_locked;

   FUNCTION is_user_admin (p_db_office_code IN NUMBER)
      RETURN BOOLEAN
   IS
      l_count       INTEGER := 0;
      l_is_locked   VARCHAR2 (1);
      l_username    VARCHAR2 (31) := cwms_util.get_user_id;
   BEGIN
      --
      -- &cwms_schema, system, sys are ok
      --
      IF l_username IN ('&cwms_schema', 'SYSTEM', 'SYS')
      THEN
         RETURN TRUE;
      END IF;

      --
      -- Check if user's account is locked for the p_db_office_code
      -- portion of the database...
      --

      IF is_user_cwms_locked (p_db_office_code)
      THEN
         RETURN FALSE;
      END IF;

      --
      -- Check if user's account has either "dba" or "CWMS User Admins"
      -- privileges.
      --
      SELECT COUNT (*)
        INTO l_count
        FROM "AT_SEC_USERS" atsu
       WHERE atsu.db_office_code = p_db_office_code
             AND atsu.user_group_code IN
                    (user_group_code_dba_users, user_group_code_user_admins)
             AND atsu.username = UPPER (l_username);

      IF l_count > 0
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_user_admin;

   FUNCTION is_user_admin (p_db_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN BOOLEAN
   IS
      l_db_office_id     VARCHAR2 (16)
                            := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (l_db_office_id);
   BEGIN
      RETURN is_user_admin (p_db_office_code => l_db_office_code);
   END is_user_admin;


   PROCEDURE confirm_user_admin_priv (p_db_office_code IN NUMBER)
   AS
   BEGIN
      IF is_user_admin (p_db_office_code => p_db_office_code)
      THEN
         NULL;
      ELSE
         cwms_err.raise (
            'ERROR',
            'Permission Denied. Your account needs "CWMS DBA" or "CWMS User Admin" privileges to use the cwms_sec package.');
      END IF;
   END confirm_user_admin_priv;

    PROCEDURE set_user_office_id (p_username              IN VARCHAR2,
                                            p_db_office_id   IN VARCHAR2
                                          )
    AS
        l_db_office_code         NUMBER := cwms_util.get_db_office_code (p_db_office_id);
        l_count                          NUMBER;
        l_username                       VARCHAR2 (31);
    BEGIN
        confirm_user_admin_priv (l_db_office_code);

        SELECT  COUNT (*)
          INTO  l_count
          FROM  at_sec_user_office
         WHERE  username = UPPER (TRIM (p_username));

        IF l_count > 0
        THEN
            UPDATE      at_sec_user_office
                SET     db_office_code = l_db_office_code
             WHERE      username = UPPER (TRIM (p_username));
        ELSE
            cwms_err.
            raise (
                'ERROR',
                    'User: '
                || UPPER (TRIM (p_username))
                || ' is not a valid CWMS account name.'
            );
        END IF;
    END;

   FUNCTION get_max_cwms_ts_group_code
      RETURN NUMBER
   AS
   BEGIN
      RETURN max_cwms_ts_group_code;
   END get_max_cwms_ts_group_code;

   FUNCTION find_lowest_code (p_list_of_codes   IN SYS_REFCURSOR,
                              p_lowest_code     IN NUMBER)
      RETURN NUMBER
   AS
      l_lowest_code   NUMBER;
      l_count         NUMBER;
      l_codes_array   number_tab_t;
   BEGIN
      NULL;

      FETCH p_list_of_codes
      BULK COLLECT INTO l_codes_array;

      CLOSE p_list_of_codes;


      BEGIN
         l_count := l_codes_array.COUNT;
      EXCEPTION
         WHEN COLLECTION_IS_NULL
         THEN
            l_count := 0;
      END;

      IF l_count = 0
      THEN
         RETURN p_lowest_code;
      END IF;

      SELECT MIN (COLUMN_VALUE) INTO l_lowest_code FROM TABLE (l_codes_array);

      IF l_lowest_code != p_lowest_code
      THEN
         RETURN p_lowest_code;
      END IF;

      --
      SELECT MIN (l_code)
        INTO l_lowest_code
        FROM (SELECT COLUMN_VALUE l_code,
                     LEAD (COLUMN_VALUE) OVER (ORDER BY COLUMN_VALUE)
                     - COLUMN_VALUE
                        dif_value
                FROM TABLE (l_codes_array))
       WHERE dif_value > 1;

      IF l_lowest_code IS NULL
      THEN
           SELECT MAX (COLUMN_VALUE)
             INTO l_lowest_code
             FROM TABLE (l_codes_array)
         ORDER BY COLUMN_VALUE;
      END IF;

      RETURN l_lowest_code + 1;
   --
   END find_lowest_code;

   --



   FUNCTION is_member_user_group (p_user_group_code   IN NUMBER,
                                  p_username          IN VARCHAR2,
                                  p_db_office_code    IN NUMBER)
      RETURN BOOLEAN
   AS
      l_count   NUMBER := 0;
   BEGIN
      SELECT COUNT (*)
        INTO l_count
        FROM at_sec_users a
       WHERE     a.db_office_code = p_db_office_code
             AND a.user_group_code = p_user_group_code
             AND a.username = UPPER (TRIM (p_username));

      IF l_count > 0
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_member_user_group;

   PROCEDURE get_user_office_data (p_office_id          OUT VARCHAR2,
                                   p_office_long_name   OUT VARCHAR2)
   IS
   BEGIN
      cwms_util.get_user_office_data (p_office_id, p_office_long_name);
   END get_user_office_data;


   PROCEDURE set_dbi_user (p_dbi_username   IN VARCHAR2,
                           p_db_office_id   IN VARCHAR2)
   AS
      l_dbi_username     VARCHAR2 (30) := UPPER (TRIM (p_dbi_username));
      l_db_office_id     VARCHAR2 (16)
                            := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (l_db_office_id);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      BEGIN
         INSERT INTO at_sec_dbi_user (db_office_code, dbi_username)
              VALUES (l_db_office_code, l_dbi_username);
      EXCEPTION
         WHEN DUP_VAL_ON_INDEX
         THEN
            cwms_err.raise (
               'ERROR',
                  l_dbi_username
               || ' is alrady a registered dbi username for the '
               || l_db_office_id
               || ' db_office_id.');
      END;
   END set_dbi_user;

   /*  cwms_sec.get_my_user_priv_groups(p_priv_groups  OUT sys_refcursor,
                                        p_db_office_id IN  VARCHAR2 DEFAULT NULL)

   This call is callable by anyone and returns a listing of that users
   priv_groups for the identified and/or the users default db_office_id.

   Returns a refcursor of:

   USERNAME
   USER_DB_OFFICE_ID
   DB_OFFICE_ID
   USER_GROUP_TYPE     (either "Privelege User Group" or "TS Collection User Group"
   USER_GROUP_OWNER  ("CWMS" or the owning DB_OFFICE_ID)
   USER_GROUP_ID
   IS_MEMBER            ("T" or "F")
   USER_GROUP_DESC
   */

   FUNCTION get_assigned_priv_groups_tab (
      p_db_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN cat_priv_groups_tab_t
      PIPELINED
   IS
      query_cursor   SYS_REFCURSOR;
      output_row     cat_priv_groups_rec_t;
   BEGIN
      get_assigned_priv_groups (query_cursor, p_db_office_id);

      LOOP
         FETCH query_cursor INTO output_row;

         EXIT WHEN query_cursor%NOTFOUND;
         PIPE ROW (output_row);
      END LOOP;

      CLOSE query_cursor;

      RETURN;
   END get_assigned_priv_groups_tab;

   --

   PROCEDURE get_assigned_priv_groups (
      p_priv_groups       OUT SYS_REFCURSOR,
      p_db_office_id   IN     VARCHAR2 DEFAULT NULL)
   IS
      l_username         VARCHAR2 (31) := cwms_util.get_user_id;
      l_db_office_id     VARCHAR2 (16);
      l_db_office_code   NUMBER;
   BEGIN
      --
      IF p_db_office_id IS NULL
      THEN
         OPEN p_priv_groups FOR
            SELECT username,
                   db_office_id,
                   user_group_type,
                   user_group_owner,
                   user_group_id,
                   is_member,
                   user_group_desc
              FROM av_sec_users
             WHERE username = l_username AND is_member = 'T';
      ELSE
         l_db_office_id := cwms_util.get_db_office_id (p_db_office_id);
         l_db_office_code := cwms_util.get_db_office_code (l_db_office_id);

         OPEN p_priv_groups FOR
            SELECT username,
                   db_office_id,
                   db_office_id,
                   user_group_type,
                   user_group_owner,
                   user_group_id,
                   is_member,
                   user_group_desc
              FROM av_sec_users
             WHERE     db_office_code = l_db_office_code
                   AND username = l_username
                   AND is_member = 'T';
      END IF;
   END get_assigned_priv_groups;

   /*--------------------------------------------------------------------------------
   The get_user_priv_groups procedure returns a refcursor of:

   USERNAME
   USER_DB_OFFICE_ID
   DB_OFFICE_ID
   USER_GROUP_TYPE  (either "Privelege User Group" or "TS Collection User Group"
   USER_GROUP_OWNER  ("CWMS" or the owning DB_OFFICE_ID)
   USER_GROUP_ID
   IS_MEMBER   ("T" or "F")
   USER_GROUP_DESC

   If p_username is null, then all usernames are returned
   If p_db_office_id is null, then the priv groups for all db_office_id's
   associated with the calling username's admin privileges.

   */

   FUNCTION get_user_priv_groups_tab (
      p_username       IN VARCHAR2 DEFAULT NULL,
      p_db_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN cat_priv_groups_tab_t
      PIPELINED
   IS
      query_cursor   SYS_REFCURSOR;
      output_row     cat_priv_groups_rec_t;
   BEGIN
      get_user_priv_groups (query_cursor, p_username, p_db_office_id);

      LOOP
         FETCH query_cursor INTO output_row;

         EXIT WHEN query_cursor%NOTFOUND;
         PIPE ROW (output_row);
      END LOOP;

      CLOSE query_cursor;

      RETURN;
   END get_user_priv_groups_tab;

   --

   PROCEDURE get_user_priv_groups (
      p_priv_groups       OUT SYS_REFCURSOR,
      p_username       IN     VARCHAR2 DEFAULT NULL,
      p_db_office_id   IN     VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_id            VARCHAR2 (16);
      l_username                VARCHAR2 (31);
      l_db_office_code          NUMBER;
      l_retrieve_all_username   BOOLEAN;
      l_retrieve_all_offices    BOOLEAN;
      l_count                   NUMBER;
   BEGIN
      IF p_username IS NULL
      THEN
         l_retrieve_all_username := TRUE;
      ELSE
         l_retrieve_all_username := FALSE;
         l_username := UPPER (TRIM (p_username));
      END IF;

      IF p_db_office_id IS NULL
      THEN
         SELECT COUNT (*)
           INTO l_count
           FROM at_sec_users
          WHERE username = cwms_util.get_user_id
                AND user_group_code IN
                       (user_group_code_dba_users,
                        user_group_code_user_admins);

         IF l_count = 0
         THEN
            cwms_err.raise (
               'ERROR',
               'Permission Denied. Your account needs "CWMS DBA" or "CWMS User Admin" privileges to use the cwms_sec package.');
         END IF;

         l_retrieve_all_offices := TRUE;
      ELSE
         l_retrieve_all_offices := FALSE;
         l_db_office_id := cwms_util.get_db_office_id (p_db_office_id);
         l_db_office_code := cwms_util.get_db_office_code (l_db_office_id);
         confirm_user_admin_priv (l_db_office_code);
      END IF;

      IF (l_retrieve_all_username AND l_retrieve_all_offices)
      THEN
         OPEN p_priv_groups FOR
            SELECT username,
                   db_office_id,
                   user_group_type,
                   user_group_owner,
                   user_group_id,
                   is_member,
                   user_group_desc
              FROM av_sec_users
             WHERE db_office_code IN
                      (SELECT UNIQUE db_office_code
                         FROM at_sec_users
                        WHERE username = cwms_util.get_user_id
                              AND user_group_code IN
                                     (user_group_code_dba_users,
                                      user_group_code_user_admins));
      ELSIF (l_retrieve_all_username AND NOT l_retrieve_all_offices)
      THEN
         OPEN p_priv_groups FOR
            SELECT username,
                   db_office_id,
                   user_group_type,
                   user_group_owner,
                   user_group_id,
                   is_member,
                   user_group_desc
              FROM av_sec_users
             WHERE db_office_code = l_db_office_code;
      ELSIF (NOT l_retrieve_all_username AND NOT l_retrieve_all_offices)
      THEN
         OPEN p_priv_groups FOR
            SELECT username,
                   db_office_id,
                   user_group_type,
                   user_group_owner,
                   user_group_id,
                   is_member,
                   user_group_desc
              FROM av_sec_users
             WHERE db_office_code = l_db_office_code
                   AND username = l_username;
      ELSE
         OPEN p_priv_groups FOR
            SELECT username,
                   db_office_id,
                   user_group_type,
                   user_group_owner,
                   user_group_id,
                   is_member,
                   user_group_desc
              FROM av_sec_users
             WHERE username = l_username AND user_group_code != 10
                   AND db_office_code IN
                          (SELECT db_office_code
                             FROM at_sec_locked_users
                            WHERE username = cwms_util.get_user_id
                                  AND db_office_code IN
                                         (SELECT UNIQUE a.db_office_code
                                            FROM at_sec_users a --, at_sec_locked_users b
                                           WHERE a.username =
                                                    cwms_util.get_user_id
                                                 AND a.user_group_code IN
                                                        (user_group_code_dba_users,
                                                         user_group_code_user_admins))
                                  AND is_locked = 'F');
      END IF;
   END get_user_priv_groups;

   ---
   ---
   /* get_ts_user_group_code return the user_group code for valid
   user_groups that can be coupled with ts_groups.

   Exception is thrown if the user_group is one of the primary
   privilege user groups.

   */

   FUNCTION get_ts_user_group_code (p_user_group_id    IN VARCHAR2,
                                    p_db_office_code   IN NUMBER)
      RETURN NUMBER
   AS
      l_user_group   NUMBER;
   BEGIN
      l_user_group := get_user_group_code (p_user_group_id, p_db_office_code);

      IF l_user_group < 10
      THEN
         cwms_err.raise (
            'ERROR',
            'User Group: ' || p_user_group_id
            || ' is a primary privilege group, which cannot be paired with a TS Group.');
      ELSE
         RETURN l_user_group;
      END IF;
   END get_ts_user_group_code;

   FUNCTION get_ts_group_code (p_ts_group_id      IN VARCHAR2,
                               p_db_office_code   IN NUMBER)
      RETURN NUMBER
   AS
      l_ts_group_code   NUMBER;
   BEGIN
      BEGIN
         SELECT ts_group_code
           INTO l_ts_group_code
           FROM at_sec_ts_groups
          WHERE UPPER (ts_group_id) = UPPER (TRIM (p_ts_group_id))
                AND db_office_code = p_db_office_code;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise (
               'ERROR',
               'The ' || p_ts_group_id || ' is not a valid TS Group.');
      END;

      RETURN l_ts_group_code;
   END get_ts_group_code;

   FUNCTION get_user_office_id
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN cwms_util.user_office_id;
   END get_user_office_id;

   PROCEDURE lock_db_account (p_username IN VARCHAR2)
   IS
      l_db_office_code   NUMBER := cwms_util.get_db_office_code (NULL);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      cwms_dba.cwms_user_admin.lock_db_account (p_username);
   END lock_db_account;

   PROCEDURE unlock_db_account (p_username IN VARCHAR2)
   IS
      l_db_office_code   NUMBER := cwms_util.get_db_office_code (NULL);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      cwms_dba.cwms_user_admin.unlock_db_account (p_username);
   END unlock_db_account;

   PROCEDURE create_cwms_db_account (
      p_username       IN VARCHAR2,
      p_password       IN VARCHAR2,
      p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   IS
      l_username         VARCHAR2 (31) := UPPER (TRIM (p_username));
      l_password         VARCHAR2 (31) := TRIM (p_password);
      l_is_locked        VARCHAR2 (1);
      l_dbi_username     VARCHAR2 (31);
      l_db_office_id     VARCHAR2 (16)
                            := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (l_db_office_id);
      l_count            NUMBER;
   --
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      BEGIN
         SELECT dbi_username
           INTO l_dbi_username
           FROM at_sec_dbi_user
          WHERE db_office_code = l_db_office_code;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise (
               'ERROR',
               'Unable to create user because a dbi_username was not found for this CWMS Oracle Database.');
      END;

      SELECT COUNT (*)
        INTO l_count
        FROM AT_SEC_CWMS_USERS
       WHERE userid = UPPER (p_username);

      IF (l_count = 0)
      THEN
         cwms_upass.update_user_data (p_username,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL);
      END IF;

      cwms_dba.cwms_user_admin.create_cwms_db_account (l_username,
                                                       l_password,
						       l_dbi_username);

       BEGIN
          INSERT INTO at_sec_user_office (username, db_office_code)
              VALUES   (l_username, l_db_office_code);
        EXCEPTION
            WHEN DUP_VAL_ON_INDEX
            THEN
                NULL;
        END;

      BEGIN
         SELECT is_locked
           INTO l_is_locked
           FROM at_sec_locked_users
          WHERE db_office_code = l_db_office_code AND username = l_username;

         IF l_is_locked != 'F'
         THEN
            UPDATE at_sec_locked_users
               SET is_locked = 'F'
             WHERE db_office_code = l_db_office_code
                   AND username = l_username;
         END IF;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            INSERT
              INTO at_sec_locked_users (db_office_code, username, is_locked)
            VALUES (l_db_office_code, l_username, 'F');
      END;

      BEGIN
         INSERT INTO at_sec_users (db_office_code, user_group_code, username)
              VALUES (
                        l_db_office_code,
                        user_group_code_all_users,
                        l_username);
      EXCEPTION
         WHEN DUP_VAL_ON_INDEX
         THEN
            NULL;
      END;

      COMMIT;
   END create_cwms_db_account;

   PROCEDURE delete_cwms_db_account (p_username IN VARCHAR2)
   IS
   BEGIN
      cwms_err.raise (
         'ERROR',
         'Unable to delete user DB account - see your DBA to delete a DB account.');
   END delete_cwms_db_account;

   FUNCTION does_db_account_exist (p_username IN VARCHAR2)
      RETURN BOOLEAN
   IS
      l_count   NUMBER := 0;
   BEGIN
      SELECT COUNT (*)
        INTO l_count
        FROM dba_users
       WHERE username = UPPER (p_username);

      IF l_count = 0
      THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END does_db_account_exist;

   ----------------------------------------------------------------------------
   -- unlock_user
   ----------------------------------------------------------------------------
   /*

   From cwmsdb.CwmsSecJdbc
   unlockUser(String username, String officeId)

   This procedure unlocks p_username for the specified p_db_office_id. This does
   not unock the users Oracle Account, it only unlocks access to data for
   the p_db_office_id.

   Exceptions are thrown if:
   -  If the user runing this procedure is not a member of the "CWMS DBA
   Users" privilege group or the "Users Admin" privilege group for the
   p_db_office_id.
   - If the p_username does not have any exiting privileges on the
   p_db_office_id data.
   -   If the p_username is already unlocked for the p_db_office_id data.
   -   If the p_username's Oracle Account is locked or if the p_username
   does not have an Oracle Account in the database.
   */
   PROCEDURE unlock_user (p_username       IN VARCHAR2,
                          p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (p_db_office_id);
      l_count            NUMBER;
      l_username         VARCHAR2 (31);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);


      l_username := UPPER (TRIM (p_username));
      cwms_dba.cwms_user_admin.unlock_db_account (l_username);

      SELECT COUNT (*)
        INTO l_count
        FROM at_sec_locked_users
       WHERE username = l_username AND db_office_code = l_db_office_code;

      IF l_count = 0
      THEN
         INSERT
           INTO at_sec_locked_users (db_office_code, username, is_locked)
         VALUES (l_db_office_code, l_username, 'F');
      ELSE
         UPDATE at_sec_locked_users
            SET is_locked = 'F'
          WHERE db_office_code = l_db_office_code AND username = l_username;
      END IF;
   END unlock_user;

   ----------------------------------------------------------------------------
   -- add_user_to_group
   ----------------------------------------------------------------------------
   /*

       From cwmsdb.CwmsSecJdbc
                          addUserToGroup(String username, String officeId, String group)

                       This procedure is used to add p_username to the p_user_group.

                              Exceptions are thrown if:
                         - If the user runing this procedure is not a member of the "CWMS DBA
                              Users" privilege group or the "Users Admin" privilege group for the
                        p_db_office_id.
                    - If a non-existing p_user_group_id is passed in.
                         - If the user is already a member of the p_user_group_id.
                           */

   FUNCTION get_user_group_code (p_user_group_id    IN VARCHAR2,
                                 p_db_office_code   IN NUMBER)
      RETURN NUMBER
   IS
      l_user_group_code   NUMBER;
   BEGIN
      BEGIN
         SELECT user_group_code
           INTO l_user_group_code
           FROM at_sec_user_groups
          WHERE UPPER (user_group_id) = UPPER (p_user_group_id)
                AND db_office_code = p_db_office_code;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            cwms_err.raise (
               'ERROR',
               'The ' || p_user_group_id || ' is not a valid user group.');
      END;

      RETURN l_user_group_code;
   END get_user_group_code;

   PROCEDURE insert_noaccess_entry (p_username         IN VARCHAR2,
                                    p_db_office_code      NUMBER)
   IS
      l_count              NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO L_count
        FROM AT_SEC_USER_OFFICE
       WHERE USERNAME = p_username AND db_office_code = p_db_office_code;

      IF l_count = 0
      THEN
         INSERT
           INTO AT_SEC_USER_OFFICE (USERNAME, DB_OFFICE_CODE)
         VALUES (UPPER (p_username), p_db_office_code);

         COMMIT;
      END IF;
   END insert_noaccess_entry;

   PROCEDURE add_user_to_group (p_username         IN VARCHAR2,
                                p_user_group_id    IN VARCHAR2,
                                p_db_office_code   IN NUMBER)
   IS
      l_user_group_code   NUMBER;
      l_username          VARCHAR2 (31) := UPPER (TRIM (p_username));
   BEGIN
      confirm_user_admin_priv (p_db_office_code);


      l_user_group_code :=
         get_user_group_code (p_user_group_id, p_db_office_code);

      BEGIN
         INSERT INTO at_sec_users (db_office_code, user_group_code, username)
              VALUES (p_db_office_code, l_user_group_code, l_username);

         insert_noaccess_entry (p_username, p_db_office_code);
         COMMIT;
      EXCEPTION
         WHEN DUP_VAL_ON_INDEX
         THEN
            NULL;
      END;
   END add_user_to_group;

   PROCEDURE add_user_to_group (p_username        IN VARCHAR2,
                                p_user_group_id   IN VARCHAR2,
                                p_db_office_id    IN VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (p_db_office_id);
   BEGIN
      add_user_to_group (p_username         => p_username,
                         p_user_group_id    => p_user_group_id,
                         p_db_office_code   => l_db_office_code);
   END add_user_to_group;

   PROCEDURE create_cwmsdbi_db_user (
      p_dbi_username   IN VARCHAR2,
      p_dbi_password   IN VARCHAR2 DEFAULT NULL,
      p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_id     VARCHAR2 (16)
                            := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (l_db_office_id);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      cwms_dba.cwms_user_admin.create_cwmsdbi_db_account (p_dbi_username,
                                                          p_dbi_password);

      set_dbi_user (p_dbi_username, p_db_office_id);
   END create_cwmsdbi_db_user;

   PROCEDURE create_logon_trigger (p_username IN VARCHAR2)
   IS
      l_cmd   VARCHAR (1024);
   BEGIN
      l_cmd :=
            'CREATE OR REPLACE TRIGGER '
         || p_username
         || '_logon_trigger AFTER LOGON ON '
         || p_username
         || '.SCHEMA BEGIN cwms_20.cwms_env.set_session_privileges; END;';

      EXECUTE IMMEDIATE l_cmd;

      COMMIT;
   END;

   ----------------------------------------------------------------------------
   -- create_user
   ----------------------------------------------------------------------------

   /*

   From cwmsdb.CwmsSecJdbc
   createUser(String username, List<String> userGroupList,
                   String officeId)

   This procedure will create a new CWMS user associated with the
   identified db_office_id.

   If the p_username is not an existing Oracle username/account,
   then a new Oracle account is created.

   Exceptions are thrown if:
   - If the user runing this procedure is not a member of the "CWMS DBA
   Users" privilege group or the "Users Admin" privilege group for the
   p_db_office_id.
   - If the CWMS user already exists for the p_db_office_id, then an
   exception is thrown that indicates that and and suggest that either
   the add_user_to_group or remove_user_from_group procedures
   should be called.
   - If one or more of the p_user_group_id_list entries is not a valid
   user_group_id for this p_db_office_id,
   */

   PROCEDURE create_user (p_username             IN VARCHAR2,
                          p_password             IN VARCHAR2,
                          p_user_group_id_list   IN char_32_array_type,
                          p_db_office_id         IN VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_id       VARCHAR2 (16)
                              := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code     NUMBER
                              := cwms_util.get_db_office_code (l_db_office_id);
      l_username           VARCHAR2 (31) := UPPER (TRIM (p_username));
      l_user_group_code    NUMBER;
      l_count              NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      IF (p_user_group_id_list IS NOT NULL)
      THEN
         IF p_user_group_id_list.COUNT > 0
         THEN
            FOR i IN p_user_group_id_list.FIRST .. p_user_group_id_list.LAST
            LOOP
               l_user_group_code :=
                  get_user_group_code (p_user_group_id_list (i),
                                       l_db_office_code);
            END LOOP;
         END IF;
      END IF;

      create_cwms_db_account (l_username, p_password, l_db_office_id);

      IF (p_user_group_id_list IS NOT NULL)
      THEN
         IF p_user_group_id_list.COUNT > 0
         THEN
            FOR i IN p_user_group_id_list.FIRST .. p_user_group_id_list.LAST
            LOOP
               add_user_to_group (l_username,
                                  p_user_group_id_list (i),
                                  l_db_office_code);
            END LOOP;
         END IF;
      END IF;

      insert_noaccess_entry (UPPER (p_username), l_db_office_code);

      SELECT COUNT (*)
        INTO l_count
        FROM AT_SEC_CWMS_USERS
       WHERE userid = UPPER (p_username);

      IF (l_count = 0)
      THEN
         cwms_upass.update_user_data (p_username,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL);
      END IF;
      create_logon_trigger(p_username);
      COMMIT;
   END CREATE_USER;

   ----------------------------------------------------------------------------
   -- delete_user
   ----------------------------------------------------------------------------
   /*

       From cwmsdb.CwmsSecJdbc
         deleteUser(String username, String officeId)

       This procedure will delete the p_username from the identified
                         p_db_office_id. It will not delete the Oracle account associated
                 with the p_username. If the p_username is not associated with another
                     db_office_id, then this procedure will Lock the p_username's Oracle
                      Account.

                 Exceptions are thrown if:
                            - If the user runing this procedure is not a member of the "CWMS DBA
                             Users" privilege group or the "Users Admin" privilege group for the
                         p_db_office_id.
                      - If p_username is not associated with the identified p_db_office_id.
                           - If p_username does not have an Oracle Account in the DB, then a Warning
                            exception is thrown indicating that an Oracle Account does not exist
                         for this p_username.

                     */
   /*

   */

   PROCEDURE delete_user (p_username IN VARCHAR2)
   IS
      l_username   VARCHAR2 (31);
      l_count      NUMBER := 0;
   BEGIN
      SELECT COUNT (UNIQUE db_office_code)
        INTO l_count
        FROM at_sec_users
       WHERE username = cwms_util.get_user_id
             AND user_group_code IN
                    (user_group_code_dba_users, user_group_code_user_admins);


      IF l_count > 0
      THEN
         l_username := UPPER (TRIM (p_username));

         DELETE FROM at_sec_users
               WHERE username = l_username
                     AND db_office_code IN
                            (SELECT UNIQUE db_office_code
                               FROM at_sec_users
                              WHERE username = cwms_util.get_user_id
                                    AND user_group_code IN
                                           (user_group_code_dba_users,
                                            user_group_code_user_admins));

         DELETE FROM at_sec_locked_users
               WHERE username = l_username
                     AND db_office_code IN
                            (SELECT UNIQUE db_office_code
                               FROM at_sec_users
                              WHERE username = cwms_util.get_user_id
                                    AND user_group_code IN
                                           (user_group_code_dba_users,
                                            user_group_code_user_admins));

         DELETE FROM at_sec_user_office
               WHERE username = l_username
                     AND db_office_code IN
                            (SELECT UNIQUE db_office_code
                               FROM at_sec_users
                              WHERE username = cwms_util.get_user_id
                                    AND user_group_code IN
                                           (user_group_code_dba_users,
                                            user_group_code_user_admins));


         --DELETE FROM at_sec_cwms_users
         --WHERE userid = l_username;


         COMMIT;
      END IF;
   END delete_user;

   ----------------------------------------------------------------------------
   -- lock_user
   ----------------------------------------------------------------------------
   /*

     From cwmsdb.CwmsSecJdbc
     lockUser(String username, String officeId)

        This procedure locks p_username from the specified p_db_office_id. This does
      not lock the users Oracle Account, it only locks access to data for
      the p_db_office_id.

      Exceptions are thrown if:
      - If the user runing this procedure is not a member of the "CWMS DBA
          Users" privilege group or the "Users Admin" privilege group for the
       p_db_office_id.
        - If the p_username does not have any exiting privileges on the p_db_office_id
      data.
      - if the username has no privileges on the db_office_id database
       - If a username that doesn't exist is passed in.
     */

   PROCEDURE lock_user (p_username       IN VARCHAR2,
                        p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_id     VARCHAR2 (16)
                            := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (l_db_office_id);
      l_count            NUMBER;
      l_username         VARCHAR2 (31);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      l_username := UPPER (TRIM (p_username));

      -- Check if user has a DB Account...

      IF does_db_account_exist (l_username)
      THEN
         --   cwms_err.raise (
         --    'ERROR',
         --    'WARNING: ' || l_username
         --    || ' does not have a valid account, so unable to place a Lock on this username.'
         --   );


         -- Check if this user has any privileges on the p_db_office_id's data...

         --  SELECT COUNT ( * )
         --    INTO l_count
         --    FROM at_sec_users
         --   WHERE username = l_username AND db_office_code = l_db_office_code;
         --
         --  IF l_count = 0
         --  THEN
         --   cwms_err.raise (
         --    'ERROR',
         --     'WARNING: '
         --    || l_username
         --    || ' has no privileges assigned to the '
         --    || l_db_office_id
         --    || '''s data, so unable to place a Lock on this username for this office''s data.'
         --   );
         --  END IF;

         UPDATE at_sec_locked_users
            SET is_locked = 'T'
          WHERE username = l_username AND db_office_code = l_db_office_code;
      END IF;
   END lock_user;


   ----------------------------------------------------------------------------
   -- remove_user_from_group
   ----------------------------------------------------------------------------
   /*
   From cwmsdb.CwmsSecJdbc
   removeUserFromGroup(String username, String officeId,
   String group)

   This procedure is used to remove p_username from the p_user_group.

   Exceptions are thrown if:
   - If the user runing this procedure is not a member of the "CWMS DBA
   Users" privilege group or the "Users Admin" privilege group for the
   p_db_office_id.
   - If a non-existing p_user_group_id is passed in.

   */
   PROCEDURE remove_user_from_group (
      p_username        IN VARCHAR2,
      p_user_group_id   IN VARCHAR2,
      p_db_office_id    IN VARCHAR2 DEFAULT NULL)
   IS
      l_db_office_code    NUMBER
                             := cwms_util.get_db_office_code (p_db_office_id);
      l_user_group_code   NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      l_user_group_code :=
         get_user_group_code (p_user_group_id, l_db_office_code);

      IF l_user_group_code = user_group_code_all_users
      THEN
         cwms_err.raise (
            'ERROR',
            'Cannot remove users from the "All Users" User Group.');
      END IF;

      DELETE FROM at_sec_users
            WHERE     db_office_code = l_db_office_code
                  AND user_group_code = l_user_group_code
                  AND username = UPPER (p_username);

      COMMIT;
   END remove_user_from_group;

   ----------------------------------------------------------------------------
   -- get_user_state
   ----------------------------------------------------------------------------

   /*

    getUserState(String username, String officeId)
        */
   FUNCTION get_user_state (p_username       IN VARCHAR2,
                            p_db_office_id   IN VARCHAR2 DEFAULT NULL)
      RETURN VARCHAR2
   IS
      l_db_office_id     VARCHAR2 (16)
                            := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (l_db_office_id);
      l_account_status   VARCHAR2 (32) := NULL;
      l_is_locked        VARCHAR2 (1);
      l_username         VARCHAR2 (31) := UPPER (TRIM (p_username));
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      BEGIN
         SELECT account_status
           INTO l_account_status
           FROM dba_users
          WHERE username = l_username;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN 'NO ACCOUNT';
      END;

      IF l_account_status != 'OPEN'
      THEN
         RETURN l_account_status;
      ELSE
         BEGIN
            SELECT is_locked
              INTO l_is_locked
              FROM at_sec_locked_users
             WHERE username = l_username
                   AND db_office_code = l_db_office_code;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN acc_state_locked;
         END;

         IF l_is_locked = 'T'
         THEN
            RETURN acc_state_locked;
         ELSE
            RETURN acc_state_unlocked;
         END IF;
      END IF;
   END get_user_state;


   PROCEDURE set_dbi_user_passwd (p_dbi_password   IN VARCHAR2,
                                  p_dbi_username   IN VARCHAR2 DEFAULT NULL,
                                  p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_id     VARCHAR2 (16)
                            := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (l_db_office_id);

      l_dbi_username     VARCHAR2 (31);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);


      -- Confirm that the p_dbi_username is the valid dbi username for the db_office_id
      IF p_dbi_username IS NULL
      THEN
         BEGIN
            SELECT dbi_username
              INTO l_dbi_username
              FROM at_sec_dbi_user
             WHERE db_office_code = l_db_office_code;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               cwms_err.raise (
                  'ERROR',
                  'Sorry, unable to set the DBI User Password because the '
                  || l_db_office_id
                  || ' database does not have a DBI User set.');
            WHEN TOO_MANY_ROWS
            THEN
               cwms_err.raise (
                  'ERROR',
                  'Sorry, unable to set the DBI User Password because there are more than one set DBI Users set for the '
                  || l_db_office_id
                  || ' database. Please specify which DBI User''''s password you wish to reset.');
         END;
      ELSE
         BEGIN
            SELECT dbi_username
              INTO l_dbi_username
              FROM at_sec_dbi_user
             WHERE dbi_username = UPPER (p_dbi_username)
                   AND db_office_code = l_db_office_code;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               cwms_err.raise (
                  'ERROR',
                     'Sorry, unable to set the DBI User Password. '
                  || UPPER (p_dbi_username)
                  || ' is not a registered DBI Username for the '
                  || l_db_office_id
                  || ' database.');
         END;
      END IF;

      -- l_dbi_username should now have a valid username - so reset it's password...

      cwms_dba.cwms_user_admin.set_user_password (l_dbi_username,
                                                  p_dbi_password);
   END set_dbi_user_passwd;

   PROCEDURE assign_ts_group_user_group (
      p_ts_group_id     IN VARCHAR2,
      p_user_group_id   IN VARCHAR2,
      p_privilege       IN VARCHAR2,                    -- none, read or write
      p_db_office_id    IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_id      VARCHAR2 (16)
                             := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code    NUMBER
                             := cwms_util.get_db_office_code (l_db_office_id);
      l_privilege         VARCHAR2 (10);
      l_user_group_code   NUMBER;
      l_ts_group_code     NUMBER;
      l_sum_priv_bit      NUMBER := NULL;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      IF UPPER (TRIM (p_privilege)) = 'READ'
      THEN
         l_privilege := 'READ';
      ELSIF UPPER (TRIM (p_privilege)) = 'READ-WRITE'
      THEN
         l_privilege := 'READ-WRITE';
      ELSIF UPPER (TRIM (p_privilege)) = 'NONE'
      THEN
         l_privilege := 'NONE';
      ELSE
         cwms_err.raise (
            'ERROR',
            'Unrecognized p_privilege: ' || p_privilege
            || ' "None", "Read" or "Read-Write" are the only valid privileges.');
      END IF;

      l_user_group_code :=
         get_ts_user_group_code (p_user_group_id, l_db_office_code);

      l_ts_group_code := get_ts_group_code (p_ts_group_id, l_db_office_code);

      -- Determine if read/write priv's are already set for this group pair..

      SELECT SUM (privilege_bit)
        INTO l_sum_priv_bit
        FROM at_sec_allow
       WHERE     db_office_code = l_db_office_code
             AND ts_group_code = l_ts_group_code
             AND user_group_code = l_user_group_code;

      IF l_sum_priv_bit IS NOT NULL
      THEN
         DELETE FROM at_sec_allow
               WHERE     db_office_code = l_db_office_code
                     AND ts_group_code = l_ts_group_code
                     AND user_group_code = l_user_group_code;
      END IF;

      IF l_privilege IN ('READ', 'READ-WRITE')
      THEN
         INSERT INTO at_sec_allow (db_office_code,
                                   ts_group_code,
                                   user_group_code,
                                   privilege_bit)
              VALUES (l_db_office_code,
                      l_ts_group_code,
                      l_user_group_code,
                      2);
      END IF;

      IF l_privilege IN ('WRITE', 'READ-WRITE')
      THEN
         INSERT INTO at_sec_allow (db_office_code,
                                   ts_group_code,
                                   user_group_code,
                                   privilege_bit)
              VALUES (l_db_office_code,
                      l_ts_group_code,
                      l_user_group_code,
                      4);
      END IF;
   END assign_ts_group_user_group;

   PROCEDURE cat_at_sec_allow (p_at_sec_allow      OUT SYS_REFCURSOR,
                               p_db_office_id   IN     VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (p_db_office_id);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      OPEN p_at_sec_allow FOR
           SELECT db_office_code,
                  user_group_code,
                  ts_group_code,
                  db_office_id,
                  user_group_id,
                  ts_group_id,
                  priv_sum,
                  DECODE (priv_sum,
                          2, 'READ',
                          4, 'WRITE',
                          6, 'READ-WRITE',
                          NULL)
                     priv
             FROM (  SELECT db_office_code,
                            user_group_code,
                            ts_group_code,
                            db_office_id,
                            user_group_id,
                            ts_group_id,
                            SUM (b.privilege_bit) priv_sum
                       FROM    (SELECT a.db_office_code,
                                       a.user_group_code,
                                       c.ts_group_code,
                                       b.office_id db_office_id,
                                       a.user_group_id,
                                       c.ts_group_id
                                  FROM at_sec_user_groups a,
                                       cwms_office b,
                                       at_sec_ts_groups c
                                 WHERE     a.db_office_code = b.office_code
                                       AND a.db_office_code = l_db_office_code
                                       AND c.db_office_code = l_db_office_code
                                       AND a.user_group_code >
                                              max_cwms_priv_ugroup_code) a
                            LEFT OUTER JOIN
                               at_sec_allow b
                            USING (db_office_code, user_group_code, ts_group_code)
                   GROUP BY db_office_code,
                            user_group_code,
                            ts_group_code,
                            db_office_id,
                            user_group_id,
                            ts_group_id) a
         ORDER BY user_group_id, ts_group_id;
   END cat_at_sec_allow;

   FUNCTION cat_at_sec_allow_tab (p_db_office_id IN VARCHAR2 DEFAULT NULL)
      RETURN cat_at_sec_allow_tab_t
      PIPELINED
   IS
      query_cursor   SYS_REFCURSOR;
      output_row     cat_at_sec_allow_rec_t;
   BEGIN
      cat_at_sec_allow (query_cursor, p_db_office_id);

      LOOP
         FETCH query_cursor INTO output_row;

         EXIT WHEN query_cursor%NOTFOUND;
         PIPE ROW (output_row);
      END LOOP;

      CLOSE query_cursor;

      RETURN;
   END cat_at_sec_allow_tab;


   PROCEDURE refresh_mv_sec_ts_privileges
   AS
      l_status   VARCHAR2 (30);
   BEGIN
      SELECT status
        INTO l_status
        FROM dba_objects
       WHERE object_name = 'MV_SEC_TS_PRIVILEGES'
             AND object_type = 'MATERIALIZED VIEW';


      IF l_status != 'VALID'
      THEN
         EXECUTE IMMEDIATE
            'alter materialized view MV_SEC_TS_PRIVILEGES compile';


         DBMS_SNAPSHOT.refresh (
            list                   => '&cwms_schema' || '.MV_SEC_TS_PRIVILEGES',
            push_deferred_rpc      => TRUE,
            refresh_after_errors   => FALSE,
            purge_option           => 1,
            parallelism            => 0,
            atomic_refresh         => TRUE,
            nested                 => FALSE);
      END IF;
   END refresh_mv_sec_ts_privileges;

   PROCEDURE start_refresh_mv_sec_privs_job
   IS
      l_count          BINARY_INTEGER;
      l_user_id        VARCHAR2 (30);
      l_job_id         VARCHAR2 (30) := 'REFRESH_MV_SEC_TS_PRIVS_JOB';
      l_run_interval   VARCHAR2 (8) := '5';
      l_comment        VARCHAR2 (256);

      FUNCTION job_count
         RETURN BINARY_INTEGER
      IS
      BEGIN
         SELECT COUNT (*)
           INTO l_count
           FROM sys.dba_scheduler_jobs
          WHERE job_name = l_job_id AND owner = l_user_id;

         RETURN l_count;
      END;
   BEGIN
      --------------------------------------
      -- make sure we're the correct user --
      --------------------------------------
      l_user_id := cwms_util.get_user_id;

      IF l_user_id != '&cwms_schema'
      THEN
         raise_application_error (
            -20999,
            'Must be &cwms_schema user to start job ' || l_job_id,
            TRUE);
      END IF;

      -------------------------------------------
      -- drop the job if it is already running --
      -------------------------------------------
      IF job_count > 0
      THEN
         DBMS_OUTPUT.put ('Dropping existing job ' || l_job_id || '...');
         DBMS_SCHEDULER.drop_job (l_job_id);

         --------------------------------
         -- verify that it was dropped --
         --------------------------------
         IF job_count = 0
         THEN
            DBMS_OUTPUT.put_line ('done.');
         ELSE
            DBMS_OUTPUT.put_line ('failed.');
         END IF;
      END IF;

      IF job_count = 0
      THEN
         BEGIN
            ---------------------
            -- restart the job --
            ---------------------

            DBMS_SCHEDULER.create_job (
               job_name          => l_job_id,
               job_type          => 'stored_procedure',
               job_action        => 'cwms_sec.refresh_mv_sec_ts_privileges',
               start_date        => NULL,
               repeat_interval   => 'freq=minutely; interval='
                                   || l_run_interval,
               end_date          => NULL,
               job_class         => 'default_job_class',
               enabled           => TRUE,
               auto_drop         => FALSE,
               comments          => 'Refreshes mv_sec_ts_privileges when needed.');

            IF job_count = 1
            THEN
               DBMS_OUTPUT.put_line (
                     'Job '
                  || l_job_id
                  || ' successfully scheduled to execute every '
                  || l_run_interval
                  || ' minutes.');
            ELSE
               cwms_err.raise ('ITEM_NOT_CREATED', 'job', l_job_id);
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               cwms_err.raise ('ITEM_NOT_CREATED',
                               'job',
                               l_job_id || ':' || SQLERRM);
         END;
      END IF;
   END start_refresh_mv_sec_privs_job;

   /*
   storePrivilegeGroups(String username, String officeId,
       List<String> groupNameList, List<String> groupOfficeIdList,
       List<Boolean> groupAssignedList)
   */

   PROCEDURE store_priv_groups (p_username             IN VARCHAR2,
                                p_user_group_id_list   IN char_32_array_type,
                                p_db_office_id_list    IN char_16_array_type,
                                p_is_member_list       IN char_16_array_type)
   IS
      l_db_office_code_list   number_tab_t := number_tab_t ();
      l_is_member_list        char_16_array_type := char_16_array_type ();
      l_user_group_code       NUMBER;
      l_username              VARCHAR2 (31);
   BEGIN
      -- confirm user exicuting this call has privileges on all db_offices
      --   in the p_db_office_id_list
      IF p_db_office_id_list.COUNT = 0
      THEN
         RETURN;
      ELSE
         FOR i IN p_db_office_id_list.FIRST .. p_db_office_id_list.LAST
         LOOP
            l_db_office_code_list.EXTEND;
            l_db_office_code_list (i) :=
               cwms_util.get_db_office_code (p_db_office_id_list (i));
            confirm_user_admin_priv (l_db_office_code_list (i));

            l_user_group_code :=
               get_user_group_code (p_user_group_id_list (i),
                                    l_db_office_code_list (i));

            l_is_member_list.EXTEND;
            l_is_member_list (i) :=
               cwms_util.return_t_or_f_flag (p_is_member_list (i));

            IF l_is_member_list (i) = 'F'
               AND l_user_group_code = user_group_code_all_users
            THEN
               cwms_err.raise (
                  'ERROR',
                  'Cannot remove users from the "All Users" User Group.');
            END IF;
         END LOOP;
      END IF;

      --
      l_username := UPPER (TRIM (p_username));

      --
      -- Calling user has USER ADMIN privileges and all user groups are valid so
      -- make the assignements...
      --
      FOR i IN p_db_office_id_list.FIRST .. p_db_office_id_list.LAST
      LOOP
         IF l_is_member_list (i) = 'T'
         THEN
            add_user_to_group (
               p_username         => l_username,
               p_user_group_id    => p_user_group_id_list (i),
               p_db_office_code   => l_db_office_code_list (i));
         ELSE
            remove_user_from_group (
               p_username        => l_username,
               p_user_group_id   => p_user_group_id_list (i),
               p_db_office_id    => p_db_office_id_list (i));
         END IF;
      END LOOP;
   END store_priv_groups;

   --

   PROCEDURE change_user_group_id (
      p_user_group_id_old   IN VARCHAR2,
      p_user_group_id_new   IN VARCHAR2,
      p_db_office_id        IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code        NUMBER
                                 := cwms_util.get_db_office_code (p_db_office_id);
      l_user_group_code       NUMBER;
      l_user_group_code_new   NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      --
      BEGIN
         l_user_group_code :=
            get_user_group_code (p_user_group_id    => p_user_group_id_old,
                                 p_db_office_code   => l_db_office_code);
      EXCEPTION
         WHEN OTHERS
         THEN
            cwms_err.raise (
               'ERROR',
                  'Cannot rename '
               || TRIM (p_user_group_id_old)
               || ' because it does not exist.');
      END;

      IF l_user_group_code <= max_cwms_ts_ugroup_code
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot rename '
            || TRIM (p_user_group_id_old)
            || ' because it is owned by the system.');
      END IF;

      BEGIN
         l_user_group_code_new :=
            get_user_group_code (p_user_group_id    => p_user_group_id_new,
                                 p_db_office_code   => l_db_office_code);
         l_user_group_code_new := 0;
      EXCEPTION
         WHEN OTHERS
         THEN
            l_user_group_code_new := 1;
      END;

      IF l_user_group_code_new = 0
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot rename '
            || TRIM (p_user_group_id_old)
            || ' to '
            || TRIM (p_user_group_id_new)
            || ' because '
            || TRIM (p_user_group_id_new)
            || ' already exists.');
      END IF;

      UPDATE at_sec_user_groups
         SET user_group_id = TRIM (p_user_group_id_new)
       WHERE user_group_code = l_user_group_code
             AND db_office_code = l_db_office_code;

      COMMIT;
   END change_user_group_id;

   PROCEDURE change_user_group_desc (
      p_user_group_id     IN VARCHAR2,
      p_user_group_desc   IN VARCHAR2,
      p_db_office_id      IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code    NUMBER
                             := cwms_util.get_db_office_code (p_db_office_id);
      l_user_group_code   NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      --
      BEGIN
         l_user_group_code :=
            get_user_group_code (p_user_group_id    => p_user_group_id,
                                 p_db_office_code   => l_db_office_code);
      EXCEPTION
         WHEN OTHERS
         THEN
            cwms_err.raise (
               'ERROR',
                  'Cannot change the User Group Description of the '
               || TRIM (p_user_group_id)
               || ' because the user group does not exist.');
      END;

      IF l_user_group_code <= max_cwms_ts_ugroup_code
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot change the User Group Description of the '
            || TRIM (p_user_group_id)
            || ' because it is owned by the system.');
      END IF;

      UPDATE at_sec_user_groups
         SET user_group_desc = TRIM (p_user_group_desc)
       WHERE user_group_code = l_user_group_code
             AND db_office_code = l_db_office_code;

      COMMIT;
   END change_user_group_desc;


   PROCEDURE delete_user_group (p_user_group_id   IN VARCHAR2,
                                p_db_office_id    IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code    NUMBER
                             := cwms_util.get_db_office_code (p_db_office_id);
      l_user_group_code   NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      --
      BEGIN
         l_user_group_code :=
            get_user_group_code (p_user_group_id    => p_user_group_id,
                                 p_db_office_code   => l_db_office_code);
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN;                   -- silent when user_group does not exist
      END;

      IF l_user_group_code <= max_cwms_ts_ugroup_code
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot delete '
            || TRIM (p_user_group_id)
            || ' because it is owned by the system.');
      END IF;

      --
      -- delete all at_sec_allow pairings with this user_group...
      --
      DELETE FROM at_sec_allow
            WHERE user_group_code = l_user_group_code
                  AND db_office_code = l_db_office_code;

      --
      -- delete all at_sec_users entries with this user_code...
      --
      DELETE FROM at_sec_users
            WHERE user_group_code = l_user_group_code
                  AND db_office_code = l_db_office_code;

      --
      -- finally delete the user_group from at_sec_user_groups...
      --
      DELETE FROM at_sec_user_groups
            WHERE user_group_code = l_user_group_code
                  AND db_office_code = l_db_office_code;

      --
      COMMIT;
   --
   END delete_user_group;


   PROCEDURE create_user_group (p_user_group_id     IN VARCHAR2,
                                p_user_group_desc   IN VARCHAR2,
                                p_db_office_id      IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code     NUMBER
                              := cwms_util.get_db_office_code (p_db_office_id);
      l_lowest_code        NUMBER;
      l_user_group_desc    VARCHAR2 (256);
      l_user_group_id      VARCHAR2 (32);
      l_error              BOOLEAN := TRUE;
      l_user_group_codes   SYS_REFCURSOR;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);
      --
      l_user_group_id := TRIM (p_user_group_id);

      --
      -- Confirm that the new user_group_id is unique
      --
      BEGIN
         SELECT user_group_desc
           INTO l_user_group_desc
           FROM at_sec_user_groups
          WHERE     db_office_code = l_db_office_code
                AND user_group_code > max_cwms_ts_ugroup_code
                AND UPPER (user_group_id) = UPPER (l_user_group_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            l_error := FALSE;
      END;

      --
      IF l_error
      THEN
         cwms_err.raise (
            'ERROR',
               'Unable to create new User Group. The User Group '
            || l_user_group_id
            || ' already exists. The existing User Group Description of: '
            || l_user_group_desc);
      END IF;

      --
      -- Determine lowest available user_group_code
      --
      OPEN l_user_group_codes FOR
         SELECT user_group_code
           FROM at_sec_user_groups
          WHERE db_office_code = l_db_office_code
                AND user_group_code > max_cwms_ts_ugroup_code;

      --
      l_lowest_code :=
         find_lowest_code (l_user_group_codes, max_cwms_ts_ugroup_code + 1);

      --
      INSERT INTO at_sec_user_groups (db_office_code,
                                      user_group_code,
                                      user_group_id,
                                      user_group_desc)
           VALUES (l_db_office_code,
                   l_lowest_code,
                   l_user_group_id,
                   TRIM (p_user_group_desc));
   END create_user_group;


   PROCEDURE delete_ts_group (p_ts_group_id    IN VARCHAR2,
                              p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (p_db_office_id);
      l_ts_group_code    NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      --
      BEGIN
         l_ts_group_code :=
            get_ts_group_code (p_ts_group_id      => p_ts_group_id,
                               p_db_office_code   => l_db_office_code);
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN;                   -- silent when user_group does not exist
      END;

      IF l_ts_group_code <= max_cwms_ts_group_code
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot delete '
            || TRIM (p_ts_group_id)
            || ' because it is owned by the system.');
      END IF;

      --
      -- delete all at_sec_allow pairings with this user_group...
      --
      DELETE FROM at_sec_allow
            WHERE ts_group_code = l_ts_group_code
                  AND db_office_code = l_db_office_code;

      --
      -- delete all at_sec_users entries with this user_code...
      --
      DELETE FROM at_sec_ts_group_masks
            WHERE ts_group_code = l_ts_group_code
                  AND db_office_code = l_db_office_code;

      --
      -- finally delete the user_group from at_sec_user_groups...
      --
      DELETE FROM at_sec_ts_groups
            WHERE ts_group_code = l_ts_group_code
                  AND db_office_code = l_db_office_code;

      --
      COMMIT;
   --
   END delete_ts_group;

   PROCEDURE change_ts_group_id (
      p_ts_group_id_old   IN VARCHAR2,
      p_ts_group_id_new   IN VARCHAR2,
      p_db_office_id      IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code      NUMBER
                               := cwms_util.get_db_office_code (p_db_office_id);
      l_ts_group_code       NUMBER;
      l_ts_group_code_new   NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      --
      BEGIN
         l_ts_group_code :=
            get_ts_group_code (p_ts_group_id      => p_ts_group_id_old,
                               p_db_office_code   => l_db_office_code);
      EXCEPTION
         WHEN OTHERS
         THEN
            cwms_err.raise (
               'ERROR',
                  'Cannot rename '
               || TRIM (p_ts_group_id_old)
               || ' because it does not exist.');
      END;

      IF l_ts_group_code <= max_cwms_ts_group_code
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot rename '
            || TRIM (p_ts_group_id_old)
            || ' because it is owned by the system.');
      END IF;

      BEGIN
         l_ts_group_code_new :=
            get_ts_group_code (p_ts_group_id      => p_ts_group_id_new,
                               p_db_office_code   => l_db_office_code);
         l_ts_group_code_new := 0;
      EXCEPTION
         WHEN OTHERS
         THEN
            l_ts_group_code_new := 1;
      END;

      IF l_ts_group_code_new = 0
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot rename '
            || TRIM (p_ts_group_id_old)
            || ' to '
            || TRIM (p_ts_group_id_new)
            || ' because '
            || TRIM (p_ts_group_id_new)
            || ' already exists.');
      END IF;

      UPDATE at_sec_ts_groups
         SET ts_group_id = TRIM (p_ts_group_id_new)
       WHERE ts_group_code = l_ts_group_code
             AND db_office_code = l_db_office_code;

      COMMIT;
   END change_ts_group_id;

   PROCEDURE change_ts_group_desc (
      p_ts_group_id     IN VARCHAR2,
      p_ts_group_desc   IN VARCHAR2,
      p_db_office_id    IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (p_db_office_id);
      l_ts_group_code    NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      --
      BEGIN
         l_ts_group_code :=
            get_ts_group_code (p_ts_group_id      => p_ts_group_id,
                               p_db_office_code   => l_db_office_code);
      EXCEPTION
         WHEN OTHERS
         THEN
            cwms_err.raise (
               'ERROR',
                  'Cannot change the TS Group Description of the '
               || TRIM (p_ts_group_id)
               || ' because the TS Group does not exist.');
      END;

      IF l_ts_group_code <= max_cwms_ts_group_code
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot change the TS Group Description of the '
            || TRIM (p_ts_group_id)
            || ' because it is owned by the system.');
      END IF;

      UPDATE at_sec_ts_groups
         SET ts_group_desc = TRIM (p_ts_group_desc)
       WHERE ts_group_code = l_ts_group_code
             AND db_office_code = l_db_office_code;

      COMMIT;
   END change_ts_group_desc;

   PROCEDURE create_ts_group (p_ts_group_id     IN VARCHAR2,
                              p_ts_group_desc   IN VARCHAR2,
                              p_db_office_id    IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (p_db_office_id);
      l_lowest_code      NUMBER;
      l_ts_group_desc    VARCHAR2 (256);
      l_ts_group_id      VARCHAR2 (32);
      l_error            BOOLEAN := TRUE;
      l_ts_group_codes   SYS_REFCURSOR;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);

      l_ts_group_id := TRIM (p_ts_group_id);

      --
      --Confirm that the new ts_group_id is unique
      --

      BEGIN
         SELECT ts_group_desc
           INTO l_ts_group_desc
           FROM at_sec_ts_groups
          WHERE     db_office_code = l_db_office_code
                AND ts_group_code > max_cwms_ts_group_code
                AND UPPER (ts_group_id) = UPPER (l_ts_group_id);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            l_error := FALSE;
      END;

      --
      IF l_error
      THEN
         cwms_err.raise (
            'ERROR',
            'Unable to create new TS Collection. The TS Group '
            || l_ts_group_id
            || ' already exists. The existing Collection Group has a Description of: '
            || l_ts_group_desc);
      END IF;

      --
      -- Determine lowest available ts_group_code
      --
      OPEN l_ts_group_codes FOR
         SELECT ts_group_code
           FROM at_sec_ts_groups
          WHERE db_office_code = l_db_office_code
                AND ts_group_code > max_cwms_ts_group_code;

      --
      l_lowest_code :=
         find_lowest_code (l_ts_group_codes, max_cwms_ts_group_code + 1);

      --
      INSERT INTO at_sec_ts_groups (db_office_code,
                                    ts_group_code,
                                    ts_group_id,
                                    ts_group_desc)
           VALUES (l_db_office_code,
                   l_lowest_code,
                   l_ts_group_id,
                   TRIM (p_ts_group_desc));
   END create_ts_group;


   PROCEDURE assign_ts_masks_to_ts_group (
      p_ts_group_id       IN VARCHAR2,
      p_ts_mask_list      IN char_183_array_type,
      p_add_remove_list   IN char_16_array_type,
      p_db_office_id      IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (p_db_office_id);
      l_ts_group_code    NUMBER;
      l_count            NUMBER;
      l_ts_mask          VARCHAR2 (183);
   BEGIN
      confirm_user_admin_priv (l_db_office_code);
      --
      l_ts_group_code := get_ts_group_code (p_ts_group_id, l_db_office_code);

      IF l_ts_group_code <= max_cwms_ts_group_code
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot assign/reassign TS Masks from the '
            || TRIM (p_ts_group_id)
            || ' TS Group because it is owned by the system.');
      END IF;

      BEGIN
         l_count := p_ts_mask_list.COUNT;
      EXCEPTION
         WHEN COLLECTION_IS_NULL
         THEN
            cwms_err.raise ('ERROR', 'The p_ts_mask_list has not records.');
      END;

      --
      IF p_ts_mask_list.COUNT != p_add_remove_list.COUNT
      THEN
         cwms_err.raise (
            'ERROR',
            'Unable to assign/reassign TS masks because the p_ts_mask_list and p_add_remove_lists are mismatched. The p_ts_mask_list has '
            || p_ts_mask_list.COUNT
            || ' elements and the p_add_remove_list has '
            || p_add_remove_list.COUNT
            || ' elements.');
      END IF;

      SELECT COUNT (*)
        INTO l_count
        FROM TABLE (p_add_remove_list)
       WHERE UPPER (TRIM (COLUMN_VALUE)) NOT IN ('ADD', 'REMOVE');

      IF l_count > 0
      THEN
         cwms_err.raise (
            'ERROR',
            'Unable to assign/reassign TS Masks because the p_add_remove_list contains invalid values. Valid values are "Add" or "Remove".');
      END IF;

      --
      FOR i IN 1 .. p_add_remove_list.LAST
      LOOP
         l_ts_mask :=
            cwms_util.normalize_wildcards (UPPER (TRIM (p_ts_mask_list (i))));

         IF UPPER (TRIM (p_add_remove_list (i))) = 'ADD'
         THEN
            BEGIN
               INSERT
                 INTO at_sec_ts_group_masks (db_office_code,
                                             ts_group_code,
                                             ts_group_mask)
               VALUES (l_db_office_code, l_ts_group_code, l_ts_mask);
            EXCEPTION
               WHEN DUP_VAL_ON_INDEX
               THEN
                  NULL;
            END;
         ELSE
            DELETE FROM at_sec_ts_group_masks
                  WHERE db_office_code = l_db_office_code
                        AND UPPER (ts_group_mask) = l_ts_mask;
         END IF;

         COMMIT;
      END LOOP;
   END assign_ts_masks_to_ts_group;

   /*
   clear_ts_masks deletes all ts masks from the identified ts_group_id.
   */
   PROCEDURE clear_ts_masks (p_ts_group_id    IN VARCHAR2,
                             p_db_office_id   IN VARCHAR2 DEFAULT NULL)
   AS
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (p_db_office_id);
      l_ts_group_code    NUMBER;
   BEGIN
      confirm_user_admin_priv (l_db_office_code);
      --
      l_ts_group_code := get_ts_group_code (p_ts_group_id, l_db_office_code);

      IF l_ts_group_code <= max_cwms_ts_group_code
      THEN
         cwms_err.raise (
            'ERROR',
               'Cannot clear TS Masks from the '
            || TRIM (p_ts_group_id)
            || ' TS Group because it is owned by the system.');
      END IF;

      DELETE FROM at_sec_ts_group_masks
            WHERE ts_group_code = l_ts_group_code
                  AND db_office_code = l_db_office_code;

      COMMIT;
   END clear_ts_masks;

   FUNCTION get_this_db_office_code
      RETURN NUMBER
   IS
      l_db_office_code   NUMBER;
   BEGIN
      SELECT MOD (min_value, 100)
        INTO l_db_office_code
        FROM user_sequences
       WHERE sequence_name = 'CWMS_SEQ';

      RETURN l_db_office_code;
   END get_this_db_office_code;

   FUNCTION get_this_db_office_id
      RETURN VARCHAR2
   IS
      l_db_office_id     VARCHAR2 (16);
      l_db_office_code   NUMBER := get_this_db_office_code;
   BEGIN
      SELECT office_id
        INTO l_db_office_id
        FROM cwms_office
       WHERE office_code = l_db_office_code;

      RETURN l_db_office_id;
   END get_this_db_office_id;

   FUNCTION get_this_db_office_name
      RETURN VARCHAR2
   IS
      l_db_office_name   VARCHAR2 (80);
      l_db_office_code   NUMBER := get_this_db_office_code;
   BEGIN
      SELECT long_name
        INTO l_db_office_name
        FROM cwms_office
       WHERE office_code = l_db_office_code;

      RETURN l_db_office_name;
   END get_this_db_office_name;

   FUNCTION is_user_admin (P_USERNAME VARCHAR2, P_DB_OFFICE_ID VARCHAR2)
      RETURN BOOLEAN
   IS
      l_count   NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_count
        FROM "AT_SEC_USERS" atsu
       WHERE atsu.db_office_code =
                CWMS_UTIL.GET_DB_OFFICE_CODE (P_DB_OFFICE_ID)
             AND atsu.user_group_code IN
                    (user_group_code_dba_users, user_group_code_user_admins)
             AND atsu.username = UPPER (p_username);

      IF l_count > 0
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_user_admin;

   FUNCTION is_user_server_admin (P_USERNAME        VARCHAR2,
                                  P_DB_OFFICE_ID    VARCHAR2)
      RETURN BOOLEAN
   IS
      l_count   NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_count
        FROM "AT_SEC_USERS" atsu
       WHERE atsu.db_office_code =
                CWMS_UTIL.GET_DB_OFFICE_CODE (P_DB_OFFICE_ID)
             AND atsu.user_group_code IN
                    (user_group_code_dba_users, user_group_code_user_admins)
             AND atsu.username = UPPER (p_username);

      IF l_count > 0
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_user_server_admin;

   FUNCTION get_admin_cwms_permissions (p_user_name      IN VARCHAR2,
                                        p_db_office_id   IN VARCHAR2)
      RETURN VARCHAR2
   IS
      l_permissions   VARCHAR2 (128);
   BEGIN
      IF (IS_USER_SERVER_ADMIN (p_user_name, p_db_office_id))
      THEN
         l_permissions := 'serverAdmin-configure';
      ELSE
         l_permissions := 'serverAdmin-No Access';
      END IF;

      IF (IS_USER_ADMIN (p_user_name, p_db_office_id))
      THEN
         l_permissions := l_permissions || ',serverAdminUsers-configure,';
      ELSE
         l_permissions := l_permissions || ',serverAdminUsers-No Access,';
      END IF;

      RETURN l_permissions;
   END get_admin_cwms_permissions;

   PROCEDURE get_user_cwms_permissions (
      p_cwms_permissions      OUT SYS_REFCURSOR,
      p_db_office_id       IN     VARCHAR2,
      p_include_all        IN     BOOLEAN DEFAULT FALSE)
   AS
      l_db_office_id     VARCHAR2 (16)
                            := cwms_util.get_db_office_id (p_db_office_id);
      l_db_office_code   NUMBER
                            := cwms_util.get_db_office_code (l_db_office_id);
      l_username         VARCHAR2 (31) := CWMS_UTIL.GET_USER_ID;
      l_is_locked        VARCHAR2 (1);
      l_query            VARCHAR2 (1256);
      l_count            NUMBER;
      l_include_all      BOOLEAN := P_INCLUDE_ALL;
   BEGIN  
      SELECT COUNT (*)
        INTO l_count
        FROM at_sec_cwms_users
       WHERE userid = l_username;

      IF l_count = 0 OR l_db_office_id = 'UNK'
      THEN
         cwms_err.raise (
            'ERROR',
               'No CWMS Permissions Set. Account '
            || l_username
            || ' has no CWMS Permissions set for db_office_id: '
            || l_db_office_id
            || '. Please see your CWMS Application Administrator.');
      END IF;

      IF is_user_cwms_locked (p_db_office_code => l_db_office_code)
      THEN
         cwms_err.raise (
            'ERROR',
               'Account is Locked. Account '
            || l_username
            || ' is locked for db_office_id: '
            || l_db_office_id
            || '. Please see your CWMS Application Administrator.');
      END IF;

      IF P_INCLUDE_ALL AND NOT IS_USER_ADMIN
      THEN
         L_INCLUDE_ALL := FALSE;
      END IF;

      IF L_INCLUDE_ALL THEN
         open p_cwms_permissions for
            SELECT createdby
                   || '|'
                   ||  p.username
                   || '|x|'
                   || CWMS_SEC.GET_ADMIN_CWMS_PERMISSIONS (p.username, l_db_office_id)
                   || '|'
                   ||  case when fullname is null or length(fullname)=0 then ' ' else fullname end
              FROM at_sec_user_office p,
                   at_sec_cwms_users u
             WHERE p.username=u.userid
               AND p.db_office_code=l_db_office_code;
      ELSE
         open p_cwms_permissions for
            SELECT createdby
                   || '|'
                   ||  p.username
                   || '|x|'
                   || CWMS_SEC.GET_ADMIN_CWMS_PERMISSIONS (p.username, l_db_office_id)
                   || '|'
                   ||  case when fullname is null or length(fullname)=0 then ' ' else fullname end
              FROM at_sec_user_office p,
                   at_sec_cwms_users u
             WHERE p.username=u.userid
               AND p.db_office_code=l_db_office_code
               AND p.username = l_username;
      END IF;

   END get_user_cwms_permissions;

   PROCEDURE get_db_users (p_db_users       OUT SYS_REFCURSOR,
                           p_db_office_id       VARCHAR2)
   IS
	l_upass_id VARCHAR2(32);
   BEGIN
      l_upass_id := CWMS_PROPERTIES.GET_PROPERTY('CWMSDB','sec.upass.id','UPASSADM','CWMS');
      OPEN p_db_users FOR
         SELECT CASE
                   WHEN s.fullname IS NULL THEN a.username
                   ELSE a.username || '|' || s.fullname || '|' || s.createdby
                END
                   fullname
           FROM    (  SELECT username
                        FROM all_users
                       WHERE username NOT IN
                                ('ANONYMOUS',
                                 'APPQOSSYS',
				 'CCP',
                                 '&cwms_schema',
                                 'CWMS_DBX',
                                 'CWMS_DBA',
                                 'CWMS_STR_ADM',
                                 'CTXSYS',
                                 'DBSNMP',
                                 'DIP',
                                 'EXFSYS',
                                 'FLOWS_FILES',
                                 'MDDATA',
                                 'MDSYS',
                                 'MGMT_VIEW',
                                 'ORACLE_OCM',
                                 'ORDDATA',
                                 'ORDSYS',
                                 'OUTLN',
                                 'ORDPLUGINS',
				 'RDL',
                                 'SI_INFORMTN_SCHEMA',
                                 'SPATIAL_CSW_ADMIN_USR',
                                 'SPATIAL_WFS_ADMIN_USR',
                                 'SYS',
                                 'SYSTEM',
                                 'SYSMAN',
                                 l_upass_id,
                                 'WMSYS',
                                 'XDB',
                                 'XS$NULL')
                             AND username NOT LIKE '%DBI'
                             AND username NOT LIKE 'APEX_%'
                             AND username NOT IN
                                    (SELECT username
                                       FROM at_sec_user_office
                                      WHERE DB_OFFICE_CODE =
                                               cwms_util.get_db_office_code (
                                                  p_db_office_id))
                    ORDER BY username) a
                LEFT JOIN
                   at_sec_cwms_users s
                ON A.USERNAME = S.userid;
   END get_db_users;
   PROCEDURE set_pd_user_passwd (p_pd_password   IN VARCHAR2,
                                  p_pd_username   IN VARCHAR2)
   IS
   BEGIN
	NULL;
   END;
   PROCEDURE update_user_data (p_userid     IN VARCHAR2,
                               p_fullname   IN VARCHAR2,
                               p_org        IN VARCHAR2,
                               p_office     IN VARCHAR2,
                               p_phone      IN VARCHAR2,
                               p_email      IN VARCHAR2)
   IS
   BEGIN
      cwms_upass.update_user_data(p_userid,p_fullname,p_org,p_office,p_phone,p_email);
   END update_user_data;
END cwms_sec;
/
show errors

prompt update for package spec cwms_upass
create or replace package cwms_upass
AS
   PROCEDURE update_user_data (p_userid     IN VARCHAR2,
                               p_fullname   IN VARCHAR2,
                               p_org        IN VARCHAR2,
                               p_office     IN VARCHAR2,
                               p_phone      IN VARCHAR2,
                               p_email      IN VARCHAR2);

   PROCEDURE update_cwms_user (p_userid        IN VARCHAR2,
                               p_lastname      IN VARCHAR2,
                               p_middlename   IN VARCHAR2,
                               p_firstname     IN VARCHAR2,
                               p_org           IN VARCHAR2,
                               p_office        IN VARCHAR2,
                               p_phone        IN VARCHAR2,
                               p_email        IN VARCHAR2,
                               p_control_code IN VARCHAR2
                               );
END cwms_upass;
/


prompt update for package body cwms_upass
create or replace package BODY cwms_upass
AS
   PROCEDURE delete_upass_user (p_userid IN VARCHAR2)
   IS
   BEGIN
         DELETE FROM at_sec_users
               WHERE username = UPPER (p_userid);

         DELETE FROM at_sec_locked_users
               WHERE username = UPPER (p_userid);

         DELETE FROM at_sec_user_office
               WHERE username = UPPER (p_userid);

         DELETE FROM at_sec_cwms_users
               WHERE USERID = UPPER (p_userid);

         COMMIT;
         CWMS_MSG.LOG_DB_MESSAGE (
            'UPASS',
            CWMS_MSG.MSG_LEVEL_NORMAL,
            'User ' || UPPER (p_userid) || ' is deleted by UPASS');
   END delete_upass_user;

   PROCEDURE update_user_data (p_userid     IN VARCHAR2,
                               p_fullname   IN VARCHAR2,
                               p_org        IN VARCHAR2,
                               p_office     IN VARCHAR2,
                               p_phone      IN VARCHAR2,
                               p_email      IN VARCHAR2)
   IS
      l_count   NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_count
        FROM AT_SEC_CWMS_USERS
       WHERE USERID = UPPER(p_userid);

      IF (l_count = 0)
      THEN
         INSERT INTO AT_SEC_CWMS_USERS (userid,
                                        fullname,
                                        org,
                                        office,
                                        phone,
                                        email,
                                        createdby)
              VALUES (p_userid,
                      p_fullname,
                      p_org,
                      p_office,
                      p_phone,
                      p_email,
                      CWMS_UTIL.GET_USER_ID);
      ELSE
         UPDATE AT_SEC_CWMS_USERS
            SET fullname = p_fullname,
                org = p_org,
                office = p_office,
                phone = p_phone,
                email = p_email,
                createdby = CWMS_UTIL.GET_USER_ID
          WHERE userid = UPPER(p_userid);
      END IF;
      COMMIT;
   END UPDATE_USER_DATA;

   PROCEDURE update_cwms_user (p_userid         IN VARCHAR2,
                               p_lastname       IN VARCHAR2,
                               p_middlename     IN VARCHAR2,
                               p_firstname      IN VARCHAR2,
                               p_org            IN VARCHAR2,
                               p_office         IN VARCHAR2,
                               p_phone          IN VARCHAR2,
                               p_email          IN VARCHAR2,
                               p_control_code   IN VARCHAR2)
   IS
   BEGIN
      IF ( ( (UPPER (p_control_code)) = 'C') OR ( (UPPER (p_control_code)) = 'A'))
      THEN
         update_user_data (p_userid,
                           p_firstname || ' ' || 
                           p_middlename || ' ' ||
                           p_lastname,
                           p_org,
                           p_office,
                           p_phone,
                           p_email);
         commit;
      ELSIF ( (UPPER (p_control_code)) = 'D')
      THEN
         DELETE_UPASS_USER (p_userid);
      ELSE
	CWMS_MSG.LOG_DB_MESSAGE ('UPASS',
                                  CWMS_MSG.MSG_LEVEL_NORMAL,
                                  'Invalid UPASS update code');
        commit;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
	CWMS_MSG.LOG_DB_MESSAGE (
            'UPASS',
            CWMS_MSG.MSG_LEVEL_NORMAL,
               'Exception while update user metadata in UPASS: '
            || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
   END update_cwms_user;
END cwms_upass;
/


prompt update for view av_usgs_agency
update at_clob set value='
/**
 * Contains agency ids and names used by the USGS
 *
 * @since CWMS 3.0
 *
 * @param agcy_id   The USGS ID for the agency
 * @param agcy_name The name of the agency 
 */
' where office_code = 53 and id = '/VIEWDOCS/AV_USGS_AGENCY';
create or replace force  view av_usgs_agency(
   agcy_id,
   agcy_name)
as
   select agcy_id, 
          agcy_name 
     from cwms_usgs_agency
     with read only 
/

create or replace public synonym cwms_v_usgs_agency for av_usgs_agency;

whenever sqlerror continue
drop public synonym cwms_v_usgs_agency;
whenever sqlerror exit sql.sqlcode
create public synonym cwms_v_usgs_agency for &cwms_schema..av_usgs_agency;
prompt update for view av_base_parm_display_units
update at_clob set value='
/**
 * Displays AV_BASE_PARM_DISPLAY_UNITS  information
 *
 * @since CWMS 3.0
 *
 * @field BASE_PARAMETER_CODE        The..
 * @field BASE_PARAMETER_ID          The..
 * @field UNIT_CODE                  The..
 * @field UNIT_ID                    The..
 * @field UNIT_SYSTEM                The..
 */
' where office_code = 53 and id = '/VIEWDOCS/AV_BASE_PARM_DISPLAY_UNITS';
create or replace force  VIEW AV_BASE_PARM_DISPLAY_UNITS
(
   BASE_PARAMETER_CODE,
   BASE_PARAMETER_ID,
   UNIT_CODE,
   UNIT_ID,
   UNIT_SYSTEM
)
AS
   SELECT cbp.base_parameter_code base_parameter_code,
          cbp.base_parameter_id base_parameter_id,
          cbp.display_unit_code_si unit_code,
          cu.unit_id unit_id,
          'SI' unit_system
     FROM cwms_base_parameter cbp, cwms_unit cu
    WHERE cbp.display_unit_code_si = cu.unit_code
   UNION
   SELECT cbp.base_parameter_code base_parameter_code,
          cbp.base_parameter_id base_parameter_id,
          cbp.display_unit_code_en unit_code,
          cu.unit_id unit_id,
          'EN' unit_system
     FROM cwms_base_parameter cbp, cwms_unit cu
    WHERE cbp.display_unit_code_en = cu.unit_code;
/

whenever sqlerror continue
drop public synonym cwms_v_base_parm_display_units;
whenever sqlerror exit sql.sqlcode
create public synonym cwms_v_base_parm_display_units for &cwms_schema..av_base_parm_display_units;
prompt update for view av_screening_control
update at_clob set value='
/**
 * [description needed]
 *
 * @since CWMS 3.0
 *
 * @field screening_code               [description needed]
 * @field db_office_id                 [description needed]
 * @field screening_id                 [description needed]
 * @field range_active_flag            [description needed]
 * @field rate_change_active_flag     [description needed]
 * @field const_active_flag            [description needed]
 * @field dur_mag_active_flag            [description needed]
 * @field rate_change_disp_interval_id    [description needed]
 */
' where office_code = 53 and id = '/VIEWDOCS/AV_SCREENING_CONTROL';
create or replace force  VIEW AV_SCREENING_CONTROL
(
   SCREENING_CODE,
   DB_OFFICE_ID,
   SCREENING_ID,
   RANGE_ACTIVE_FLAG,
   RATE_CHANGE_ACTIVE_FLAG,
   CONST_ACTIVE_FLAG,
   DUR_MAG_ACTIVE_FLAG,
   RATE_CHANGE_DISP_INTERVAL_ID
)
AS
   SELECT atsi.screening_code,
          co.office_id db_office_id,
          atsi.screening_id,
          asctl.range_active_flag,
          asctl.rate_change_active_flag,
          asctl.const_active_flag,
          asctl.dur_mag_active_flag,
          ci.interval_id rate_change_disp_interval_id
     FROM at_screening_id atsi,
          cwms_office co,
          cwms_interval ci,
          at_screening_control asctl
    WHERE     co.office_code = atsi.db_office_code
          AND atsi.screening_code = asctl.screening_code(+)
          AND asctl.rate_change_disp_interval_code = ci.interval_code(+);
/

whenever sqlerror continue
drop public synonym cwms_v_screening_control;
whenever sqlerror exit sql.sqlcode
create public synonym cwms_v_screening_control for &cwms_schema..av_screening_control;
prompt update for view av_screening_criteria
update at_clob set value='
/**
 * [description needed]
 *
 * @since CWMS 2.1
 *
 * @field screening_code               [description needed]
 * @field db_office_id                 [description needed]
 * @field screening_id                 [description needed]
 * @field screening_id_desc            [description needed]
 * @field base_parameter_id            [description needed]
 * @field sub_parameter_id             [description needed]
 * @field parameter_id                 [description needed]
 * @field parameter_type_id            [description needed]
 * @field duration_id                  [description needed]
 * @field season_start_day             [description needed]
 * @field season_start_month           [description needed]
 * @field unit_system                  [description needed]
 * @field unit_id                      [description needed]
 * @field range_reject_lo              [description needed]
 * @field range_reject_hi              [description needed]
 * @field range_question_lo            [description needed]
 * @field range_question_hi            [description needed]
 * @field rate_change_reject_rise      [description needed]
 * @field rate_change_reject_fall      [description needed]
 * @field rate_change_quest_rise       [description needed]
 * @field rate_change_quest_fall       [description needed]
 * @field rate_change_disp_interval    [description needed]
 * @field const_reject_duration        [description needed]
 * @field const_reject_min             [description needed]
 * @field const_reject_tolerance       [description needed]
 * @field const_reject_n_miss          [description needed]
 * @field const_quest_duration         [description needed]
 * @field const_quest_min              [description needed]
 * @field const_quest_tolerance        [description needed]
 * @field const_quest_n_miss           [description needed]
 * @field estimate_expression          [description needed]
 * @field range_active_flag            [description needed]
 * @field rate_change_active_flag      [description needed]
 * @field const_active_flag            [description needed]
 * @field dur_mag_active_flag          [description needed]
 * @field rate_change_disp_interval_id [description needed]
 */
' where office_code = 53 and id = '/VIEWDOCS/AV_SCREENING_CRITERIA';
create or replace force  VIEW AV_SCREENING_CRITERIA
(
   SCREENING_CODE,
   DB_OFFICE_ID,
   SCREENING_ID,
   SCREENING_ID_DESC,
   BASE_PARAMETER_ID,
   SUB_PARAMETER_ID,
   PARAMETER_ID,
   PARAMETER_TYPE_ID,
   DURATION_ID,
   SEASON_START_DAY,
   SEASON_START_MONTH,
   UNIT_SYSTEM,
   UNIT_ID,
   RANGE_REJECT_LO,
   RANGE_REJECT_HI,
   RANGE_QUESTION_LO,
   RANGE_QUESTION_HI,
   RATE_CHANGE_REJECT_RISE,
   RATE_CHANGE_REJECT_FALL,
   RATE_CHANGE_QUEST_RISE,
   RATE_CHANGE_QUEST_FALL,
   RATE_CHANGE_DISP_INTERVAL,
   CONST_REJECT_DURATION,
   CONST_REJECT_MIN,
   CONST_REJECT_TOLERANCE,
   CONST_REJECT_N_MISS,
   CONST_QUEST_DURATION,
   CONST_QUEST_MIN,
   CONST_QUEST_TOLERANCE,
   CONST_QUEST_N_MISS,
   ESTIMATE_EXPRESSION,
   RANGE_ACTIVE_FLAG,
   RATE_CHANGE_ACTIVE_FLAG,
   CONST_ACTIVE_FLAG,
   DUR_MAG_ACTIVE_FLAG,
   RATE_CHANGE_DISP_INTERVAL_ID
)
AS
   SELECT atsi.screening_code,
          co.office_id db_office_id,
          atsi.screening_id,
          atsi.screening_id_desc,
          cbp.base_parameter_id,
          atp.sub_parameter_id,
             cbp.base_parameter_id
          || SUBSTR ('-', 1, LENGTH (atp.sub_parameter_id))
          || atp.sub_parameter_id
             parameter_id,
          cpt.parameter_type_id,
          cd.duration_id,
          MOD (avsc.season_start_date, 30) season_start_day,
            (avsc.season_start_date - MOD (avsc.season_start_date, 30)) / 30
          + 1
             season_start_month,
          bpdu.unit_system,
          cuc.to_unit_id unit_id,
          avsc.range_reject_lo * cuc.factor + cuc.offset range_reject_lo,
          avsc.range_reject_hi * cuc.factor + cuc.offset range_reject_hi,
          avsc.range_question_lo * cuc.factor + cuc.offset range_question_lo,
          avsc.range_question_hi * cuc.factor + cuc.offset range_question_hi,
          avsc.rate_change_reject_rise * cuc.factor + cuc.offset
             rate_change_reject_rise,
          avsc.rate_change_reject_fall * cuc.factor + cuc.offset
             rate_change_reject_fall,
          avsc.rate_change_quest_rise * cuc.factor + cuc.offset
             rate_change_quest_rise,
          avsc.rate_change_quest_fall * cuc.factor + cuc.offset
             rate_change_quest_fall,
          CASE
             WHEN asctl.rate_change_disp_interval_code IS NULL
             THEN
                'Unknown'
             ELSE
                (SELECT interval_id
                   FROM cwms_interval
                  WHERE interval_code = asctl.rate_change_disp_interval_code)
          END
             rate_change_disp_interval,
          CASE
             WHEN avsc.const_reject_duration_code IS NULL
             THEN
                'Unknown'
             ELSE
                (SELECT duration_id
                   FROM cwms_duration
                  WHERE duration_code = avsc.const_reject_duration_code)
          END
             const_reject_duration,
          avsc.const_reject_min * cuc.factor + cuc.offset const_reject_min,
          avsc.const_reject_tolerance * cuc.factor + cuc.offset
             const_reject_tolerance,
          avsc.const_reject_n_miss,
          CASE
             WHEN avsc.const_quest_duration_code IS NULL
             THEN
                'Unknown'
             ELSE
                (SELECT duration_id
                   FROM cwms_duration
                  WHERE duration_code = avsc.const_quest_duration_code)
          END
             const_quest_duration,
          avsc.const_quest_min * cuc.factor + cuc.offset const_quest_min,
          avsc.const_quest_tolerance * cuc.factor + cuc.offset
             const_quest_tolerance,
          avsc.const_quest_n_miss,
          avsc.estimate_expression,
          asctl.range_active_flag,
          asctl.rate_change_active_flag,
          asctl.const_active_flag,
          asctl.dur_mag_active_flag,
          ci.interval_id rate_change_disp_interval_id
     FROM at_screening_id atsi,
          cwms_office co,
          at_parameter atp,
          cwms_base_parameter cbp,
          cwms_parameter_type cpt,
          cwms_duration cd,
          cwms_interval ci,
          av_base_parm_display_units bpdu,
          cwms_unit_conversion cuc,
          at_screening_criteria avsc,
          at_screening_control asctl
    WHERE     co.office_code = atsi.db_office_code
          AND cbp.base_parameter_code = atsi.base_parameter_code
          AND atp.parameter_code = atsi.parameter_code
          AND atsi.parameter_type_code = cpt.parameter_type_code(+)
          AND atsi.duration_code = cd.duration_code(+)
          AND atsi.screening_code = avsc.screening_code(+)
          AND cbp.unit_code = cuc.from_unit_code
          AND bpdu.unit_code = cuc.to_unit_code
          AND atsi.base_parameter_code = bpdu.base_parameter_code
          AND avsc.screening_code = asctl.screening_code(+)
          AND asctl.rate_change_disp_interval_code = ci.interval_code(+);
/

whenever sqlerror continue
drop public synonym cwms_v_screening_criteria;
whenever sqlerror exit sql.sqlcode
create public synonym cwms_v_screening_criteria for &cwms_schema..av_screening_criteria;
prompt update for view av_screening_dur_mag
update at_clob set value='
/**
 * [description needed]
 *
 * @since CWMS 2.1
 *
 * @field screening_code      [description needed]
 * @field db_office_id        [description needed]
 * @field screening_id        [description needed]
 * @field screening_id_desc   [description needed]
 * @field base_parameter_id   [description needed]
 * @field sub_parameter_id    [description needed]
 * @field parameter_id        [description needed]
 * @field parameter_type_id   [description needed]
 * @field duration_id         [description needed]
 * @field season_start_day    [description needed]
 * @field season_start_month  [description needed]
 * @field unit_system         [description needed]
 * @field unit_id             [description needed]
 * @field dur_mag_duration_id [description needed]
 * @field reject_lo           [description needed]
 * @field reject_hi           [description needed]
 * @field question_lo         [description needed]
 * @field question_hi         [description needed]
 */
' where office_code = 53 and id = '/VIEWDOCS/AV_SCREENING_DUR_MAG';
create or replace force  VIEW AV_SCREENING_DUR_MAG
(
   SCREENING_CODE,
   DB_OFFICE_ID,
   SCREENING_ID,
   SCREENING_ID_DESC,
   BASE_PARAMETER_ID,
   SUB_PARAMETER_ID,
   PARAMETER_ID,
   PARAMETER_TYPE_ID,
   DURATION_ID,
   SEASON_START_DAY,
   SEASON_START_MONTH,
   UNIT_SYSTEM,
   UNIT_ID,
   DUR_MAG_DURATION_ID,
   REJECT_LO,
   REJECT_HI,
   QUESTION_LO,
   QUESTION_HI
)
AS
   SELECT atsdm.screening_code,
          co.office_id db_office_id,
          atsi.screening_id,
          atsi.screening_id_desc,
          cbp.base_parameter_id,
          atp.sub_parameter_id,
             cbp.base_parameter_id
          || SUBSTR ('-', 1, LENGTH (atp.sub_parameter_id))
          || atp.sub_parameter_id
             parameter_id,
          cpt.parameter_type_id,
          cd.duration_id,
          MOD (atsdm.season_start_date, 30) season_start_day,
              (atsdm.season_start_date - MOD (atsdm.season_start_date, 30))
            / 30
          + 1
             season_start_month,
          bpdu.unit_system,
          cuc.to_unit_id unit_id,
          cd2.duration_id dur_mag_duration_id,
          atsdm.reject_lo * cuc.factor + cuc.offset reject_lo,
          atsdm.reject_hi * cuc.factor + cuc.offset reject_hi,
          atsdm.question_lo * cuc.factor + cuc.offset question_lo,
          atsdm.question_hi * cuc.factor + cuc.offset question_hi
     FROM at_screening_id atsi,
          cwms_office co,
          at_parameter atp,
          cwms_base_parameter cbp,
          cwms_parameter_type cpt,
          cwms_duration cd,
          cwms_duration cd2,
          av_base_parm_display_units bpdu,
          cwms_unit_conversion cuc,
          at_screening_dur_mag atsdm
    WHERE     co.office_code = atsi.db_office_code
          AND cbp.base_parameter_code = atsi.base_parameter_code
          AND atp.parameter_code = atsi.parameter_code
          AND atsi.parameter_type_code = cpt.parameter_type_code(+)
          AND atsi.duration_code = cd.duration_code(+)
          AND atsdm.duration_code = cd2.duration_code
          AND atsi.screening_code = atsdm.screening_code
          AND cbp.unit_code = cuc.from_unit_code
          AND bpdu.unit_code = cuc.to_unit_code
          AND atsi.base_parameter_code = bpdu.base_parameter_code;
/

whenever sqlerror continue
drop public synonym cwms_v_screening_dur_mag;
whenever sqlerror exit sql.sqlcode
create public synonym cwms_v_screening_dur_mag for &cwms_schema..av_screening_dur_mag;
prompt update for script ../compileAll
set echo off
whenever sqlerror exit sql.sqlcode
prompt Invalid objects...
  select substr(object_name, 1, 31) "INVALID OBJECT", object_type
    from dba_objects
   where owner = '&cwms_schema'
     and status = 'INVALID'
order by object_name, object_type asc;
prompt Recompiling all invalid objects...
exec sys.utl_recomp.recomp_serial('&cwms_schema');
--  Some of the packages/types don't compile first time
commit;
exec dbms_lock.sleep(10);
exec sys.utl_recomp.recomp_serial('&cwms_schema');
/

prompt Remaining invalid objects...
  select substr(object_name, 1, 31) "INVALID OBJECT", object_type
    from dba_objects
   where owner = '&cwms_schema'
     and status = 'INVALID'
order by object_name, object_type asc;

declare
   obj_count integer;
begin
   select count(*)
     into obj_count
     from dba_objects
    where owner = '&cwms_schema'
      and status = 'INVALID';
   if obj_count > 0 then
      dbms_output.put_line('' || obj_count || ' objects are still invalid.');
      raise_application_error(-20999, 'Some objects are still invalid.');
   else
      dbms_output.put_line('All invalid objects successfully compiled.');
   end if;
end;
/


prompt update for script create_logon_triggers
BEGIN
   FOR C IN (SELECT UNIQUE username
               FROM at_sec_user_office
              WHERE username IN (SELECT username
                                   FROM all_users))
   LOOP
      CWMS_SEC.CREATE_LOGON_TRIGGER (c.username);
   END LOOP;
END;
/
show errors
prompt update for script 3_0_3_Updates
MERGE INTO CWMS_20.CWMS_DURATION A USING
 (SELECT
  29 as DURATION_CODE,
  '0' as DURATION_ID,
  0 as DURATION,
  'Measurement applies intantaneously at time stamp or from previous time stamp' as DESCRIPTION
  FROM DUAL) B
ON (A.DURATION_CODE = B.DURATION_CODE)
WHEN NOT MATCHED THEN 
INSERT (
  DURATION_CODE, DURATION_ID, DURATION, DESCRIPTION)
VALUES (
  B.DURATION_CODE, B.DURATION_ID, B.DURATION, B.DESCRIPTION)
WHEN MATCHED THEN
UPDATE SET 
  A.DURATION_ID = B.DURATION_ID,
  A.DURATION = B.DURATION,
  A.DESCRIPTION = B.DESCRIPTION;

MERGE INTO CWMS_20.CWMS_DURATION A USING
 (SELECT
  60 as DURATION_CODE,
  '0BOP' as DURATION_ID,
  0 as DURATION,
  'Measurement applies intantaneously at time stamp or until next time stamp' as DESCRIPTION
  FROM DUAL) B
ON (A.DURATION_CODE = B.DURATION_CODE)
WHEN NOT MATCHED THEN 
INSERT (
  DURATION_CODE, DURATION_ID, DURATION, DESCRIPTION)
VALUES (
  B.DURATION_CODE, B.DURATION_ID, B.DURATION, B.DESCRIPTION)
WHEN MATCHED THEN
UPDATE SET 
  A.DURATION_ID = B.DURATION_ID,
  A.DURATION = B.DURATION,
  A.DESCRIPTION = B.DESCRIPTION;

MERGE INTO CWMS_20.CWMS_ERROR A USING
 (SELECT
  -20048 as ERR_CODE,
  'NO_WRITE_PRIVILEGE' as ERR_NAME,
  'User doesnt have write privileges' as ERR_MSG
  FROM DUAL) B
ON (A.ERR_CODE = B.ERR_CODE)
WHEN NOT MATCHED THEN 
INSERT (
  ERR_CODE, ERR_NAME, ERR_MSG)
VALUES (
  B.ERR_CODE, B.ERR_NAME, B.ERR_MSG)
WHEN MATCHED THEN
UPDATE SET 
  A.ERR_NAME = B.ERR_NAME,
  A.ERR_MSG = B.ERR_MSG;

GRANT SELECT ON CWMS_20.AV_BASE_PARM_DISPLAY_UNITS TO CWMS_USER;
GRANT SELECT ON CWMS_20.AV_SCREENING_CONTROL TO CWMS_USER;
GRANT SELECT ON CWMS_20.AV_USGS_AGENCY TO CWMS_USER;
whenever sqlerror continue;
drop index at_loc_lvl_indicator_u1;
whenever sqlerror exit;
create unique index at_loc_lvl_indicator_u1 on at_loc_lvl_indicator (
   location_code,
   specified_level_code,
   parameter_code,
   duration_code,
   level_indicator_id,
   cwms_rounding.round_f(attr_value, 12),
   attr_parameter_code,
   ref_specified_level_code,
   ref_attr_value);

COMMIT;


prompt update for script ../cwms/create_sec_triggers
DECLARE
   l_cmd   VARCHAR2 (1024);
   l_trig VARCHAR2(64);
   l_upass VARCHAR2(128) := '';
BEGIN
   FOR c IN (SELECT table_name
               FROM user_tables
              WHERE table_name LIKE 'AT\_%' ESCAPE '\' AND TEMPORARY = 'N' AND table_name <> 'AT_PROPERTIES')
   LOOP
      l_trig := replace(c.table_name,'AT_','ST_');
      if(c.table_name = 'AT_SEC_USERS' OR c.table_name='AT_SEC_LOCKED_USERS' OR c.table_name='AT_SEC_USER_OFFICE' OR
	c.table_name = 'AT_LOG_MESSAGE' or c.table_name='AT_LOG_MESSAGE_PROPERTIES' or c.table_name = 'AT_SEC_CWMS_USERS')
      THEN
	l_upass := ' AND user <>  UPPER(CWMS_PROPERTIES.GET_PROPERTY(''CWMSDB'',''sec.upass.id'',''UPASSADM'',''CWMS''))';
      ELSE
	l_upass := '';
      END IF;
      --DBMS_OUTPUT.PUT_LINE(c.table_name || ':' || l_upass);
      l_cmd :=
            'CREATE OR REPLACE TRIGGER '
         || l_trig
         || ' BEFORE DELETE OR INSERT OR UPDATE
              ON '
         || c.table_name
         || ' REFERENCING NEW AS NEW OLD AS OLD

             DECLARE
    
             l_priv   VARCHAR2 (16);
             BEGIN
             SELECT SYS_CONTEXT (''CWMS_ENV'', ''CWMS_PRIVILEGE'') INTO l_priv FROM DUAL;
             IF ((l_priv is NULL OR l_priv <> ''CAN_WRITE'') AND user NOT IN (''SYS'', ''CWMS_20'')'
          || l_upass 
          || ')
             THEN
     
               CWMS_20.CWMS_ERR.RAISE(''NO_WRITE_PRIVILEGE'');
     
             END IF;
           END;';
   --DBMS_OUTPUT.PUT_LINE(l_cmd);
   execute immediate l_cmd;
   END LOOP;
END;
/

prompt update for script ../cwms_version
insert into cwms_db_change_log (application,
                              ver_major,
                              ver_minor,
                              ver_build,
                              ver_date,
                              title,
                              description)
     values ('CWMS', 
             3,
             0,
             3,
             to_date ('20JAN2016', 'DDMONYYYY'),
             'CWMS Database Release 3.0.3',
             'Added supoort for read-only implementation.
Added views needed for CCP datchk validation
');

commit;
whenever sqlerror exit;



commit;


exit;

